<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>TBH个人博客</title>
  
  <subtitle>记录点滴生活</subtitle>
  <link href="https://tbghg.github.io/atom.xml" rel="self"/>
  
  <link href="https://tbghg.github.io/"/>
  <updated>2023-03-04T12:56:53.000Z</updated>
  <id>https://tbghg.github.io/</id>
  
  <author>
    <name>TBgHg</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>跨域问题详细讨论</title>
    <link href="https://tbghg.github.io/2023-03-04/c3368a89a099/"/>
    <id>https://tbghg.github.io/2023-03-04/c3368a89a099/</id>
    <published>2023-03-04T12:56:53.000Z</published>
    <updated>2023-03-04T12:56:53.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是CSRF"><a href="#什么是CSRF" class="headerlink" title="什么是CSRF"></a>什么是CSRF</h2><p>CSRF（Cross-Site Request Forgery）指的是跨站请求伪造，是一种网络攻击方式。攻击者通过伪造请求让用户在不知情的情况下执行一些操作，例如在用户登录了某个网站之后，攻击者伪造一个请求，在用户不知情的情况下向该网站发送请求，执行一些不良操作，例如修改用户密码、转账等。</p><p>举个例子，假设你在某个网站上登录了账号，然后你打开了一个恶意网站，该网站中嵌入了一个伪造请求，向该网站发送了一个修改密码的请求。此时，因为你已经登录了该网站，浏览器会自动带上你的登录信息，并发送该请求，而你并没有意识到这一点。这样，攻击者就可以在你不知情的情况下修改你的密码，或者进行其他的不良操作。</p><h2 id="同源策略与跨域发送"><a href="#同源策略与跨域发送" class="headerlink" title="同源策略与跨域发送"></a>同源策略与跨域发送</h2><h3 id="同源策略"><a href="#同源策略" class="headerlink" title="同源策略"></a>同源策略</h3><p>同源策略是一种安全策略，指浏览器只允许在当前域名下访问该域名下的资源，而不允许跨域访问其他域名下的资源。</p><p>同源指的是协议、域名、端口号三者完全相同，只要有任何一个不同，就算是跨域。</p><p>同源策略可以有效地防止恶意网站通过脚本获取用户的敏感信息。如果浏览器不限制跨域访问，那么恶意网站就可以通过脚本访问其他域名下的资源，从而窃取用户的敏感信息。</p><h3 id="如何跨域发送信息"><a href="#如何跨域发送信息" class="headerlink" title="如何跨域发送信息"></a>如何跨域发送信息</h3><p>要在 A 网站的前端页面中向 B 网站发起跨域请求，需要使用特定的技术手段，如跨域资源共享（CORS）、JSONP、postMessage、iframe、代理等。</p><p>其中，跨域资源共享（CORS）是最常用的跨域解决方案之一。它通过在 B 网站的服务器端设置响应头，允许 A 网站的前端页面发送跨域请求。在发送请求时，需要在请求头中添加特定的参数，如 Origin，表示请求来源。如果 B 网站的服务器端设置了允许跨域请求的响应头，请求就会被成功响应。</p><p>举个例子，如果 A 网站的前端页面想要获取 B 网站的数据，可以在 JavaScript 中使用 Fetch API 或 AJAX 发起跨域请求，并在请求头中添加 Origin 参数，B 网站的服务器端需要设置允许跨域请求的响应头，例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Access</span>-<span class="title class_">Control</span>-<span class="title class_">Allow</span>-<span class="title class_">Origin</span>: *</span><br><span class="line"><span class="title class_">Access</span>-<span class="title class_">Control</span>-<span class="title class_">Allow</span>-<span class="title class_">Methods</span>: <span class="variable constant_">GET</span>, <span class="variable constant_">POST</span>, <span class="variable constant_">PUT</span>, <span class="variable constant_">DELETE</span></span><br><span class="line"><span class="title class_">Access</span>-<span class="title class_">Control</span>-<span class="title class_">Allow</span>-<span class="title class_">Headers</span>: <span class="title class_">Content</span>-<span class="title class_">Type</span></span><br></pre></td></tr></table></figure><p>这样，在 A 网站的前端页面中就可以成功获取 B 网站的数据了。当然，要注意跨域请求可能会存在一些安全问题，需要进行相应的防护措施，如验证请求来源、使用 CSRF Token 等。</p><h3 id="CORS"><a href="#CORS" class="headerlink" title="CORS"></a>CORS</h3><p>跨域资源共享（CORS）是一种常用的跨域解决方案，可以允许前端页面向其他域名下的服务器发送跨域请求，并在服务器端得到响应。在使用 CORS 时，需要在服务器端设置允许跨域请求的响应头，以及在前端页面中添加 Origin 参数，表示请求的来源。</p><p>CORS定义了一组HTTP头部，用于告诉浏览器哪些跨域请求是被允许的。在跨域请求中，浏览器会发送一个预检请求（OPTIONS请求）到目标服务器，该请求包含了一些CORS相关的头部信息，目标服务器通过检查这些头部信息来判断该请求是否被允许。</p><p>通过CORS，Web应用程序可以在浏览器中安全地与不同域名的服务器交互，而无需破坏浏览器的同源策略。CORS是现代Web应用程序开发中非常重要的一个方面，许多现代浏览器都支持CORS，并提供了相应的API和工具来管理和配置CORS。</p><h2 id="跨域请求与cookie"><a href="#跨域请求与cookie" class="headerlink" title="跨域请求与cookie"></a>跨域请求与cookie</h2><p>如果用户在A网站登录了B网站，然后在A网站中向B网站发送请求，这个请求会自动携带B网站的Cookie信息。</p><p>这是因为，Cookie 是一种客户端存储数据的机制，当用户在B网站登录时，B网站会在响应中设置一个Cookie，并将其保存在用户的浏览器中。在用户后续访问B网站时，浏览器会自动将该Cookie附加到每个请求中，以便B网站能够识别用户身份。</p><p>当用户访问A网站时，如果A网站需要向B网站发送请求，那么这个请求会自动携带浏览器中保存的B网站的Cookie信息，即使用户没有在A网站中手动设置Cookie。这也就是为什么在 CSRF 攻击中，攻击者可以利用用户的Cookie信息来模拟用户发起请求的原因。</p><h2 id="如何预防CSRF"><a href="#如何预防CSRF" class="headerlink" title="如何预防CSRF"></a>如何预防CSRF</h2><p>要防止 CSRF 攻击，开发人员可以使用以下一些方法：</p><ol><li>验证 HTTP Referer 头部信息：在服务器端检查 HTTP Referer 头部信息，确保请求是从允许的域名中发起的。这种方法可以检查请求的来源是否合法，但也有可能被伪造。</li><li>验证 CSRF Token：在每个表单中添加一个 CSRF Token，提交表单时验证这个 Token 是否正确。攻击者很难伪造这个 Token，因为它通常是随机生成的。</li></ol><p>举个例子，假设有一个网站，其中包含一个表单用于提交评论。为了防止 CSRF 攻击，该网站可以在每个表单中添加一个随机生成的 Token，例如 CSRF Token。当用户提交评论时，服务器会检查该 Token 是否正确。如果 Token 不正确，服务器会拒绝该请求。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span> <span class="attr">action</span>=<span class="string">&quot;/comment&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;hidden&quot;</span> <span class="attr">name</span>=<span class="string">&quot;CSRFToken&quot;</span> <span class="attr">value</span>=<span class="string">&quot;随机生成的 Token&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;comment&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;提交&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在这个例子中，如果攻击者想要发起 CSRF 攻击，他必须知道正确的 CSRF Token，这通常是不可能的。因此，这种方法可以有效地防止 CSRF 攻击。</p><h3 id="CSRF-Token"><a href="#CSRF-Token" class="headerlink" title="CSRF Token"></a>CSRF Token</h3><p>CSRF Token 可以存储在多个地方，通常来说，将CSRF Token存储在cookie中是更为常见的方式，但需要注意对cookie的安全设置，避免被恶意代码窃取。也可以选择存储在 表单隐藏域 中。</p><p>如果使用 cookie 存储 CSRF Token，服务器会在用户登录时，在用户的 cookie 中设置一个随机 Token，当发送请求时，将该CSRF Token作为请求头的一部分发送给服务端。这样做的好处是 CSRF Token 会随着 cookie 自动发送，不需要手动在每个请求中添加。</p><p>如果使用表单隐藏域存储 CSRF Token，服务器在用户登录时生成一个 Token，然后在每个表单中添加一个隐藏域，将 Token 填写到隐藏域中，最后提交给服务器。这种方式的好处是 CSRF Token 不会随着 cookie 发送，可以防止 CSRF 攻击者通过 JavaScript 获取到 Token。</p><p>除此之外，CSRF Token 还可以存储在 HTTP 请求头中，例如 X-CSRF-Token，或者在 URL 参数中，例如 <a class="link"   href="http://www.example.com/path/to/resource?csrf_token=xxxxx" >http://www.example.com/path/to/resource?csrf_token&#x3D;xxxxx<i class="fas fa-external-link-alt"></i></a>。不同的存储位置对于不同的应用场景有不同的优劣点，需要根据实际情况进行选择。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;什么是CSRF&quot;&gt;&lt;a href=&quot;#什么是CSRF&quot; class=&quot;headerlink&quot; title=&quot;什么是CSRF&quot;&gt;&lt;/a&gt;什么是CSRF&lt;/h2&gt;&lt;p&gt;CSRF（Cross-Site Request Forgery）指的是跨站请求伪造，是一种网络攻击方</summary>
      
    
    
    
    
    <category term="后端" scheme="https://tbghg.github.io/tags/%E5%90%8E%E7%AB%AF/"/>
    
    <category term="跨域" scheme="https://tbghg.github.io/tags/%E8%B7%A8%E5%9F%9F/"/>
    
  </entry>
  
  <entry>
    <title>kratos框架中的bm是什么</title>
    <link href="https://tbghg.github.io/2023-03-03/e2545287b58e/"/>
    <id>https://tbghg.github.io/2023-03-03/e2545287b58e/</id>
    <published>2023-03-03T12:55:40.000Z</published>
    <updated>2023-03-03T12:55:40.000Z</updated>
    
    <content type="html"><![CDATA[<p>kratos框架中的bm是什么？(Blademaster)</p><blockquote><p>我在学习kratos框架中发现http部分经常用blademaster出现，请帮我推测下blademaster指的是什么吧？</p></blockquote><p>在Kratos框架中，Blademaster是一个HTTP框架，提供了基于协程和事件驱动的高性能网络通信能力。Blademaster能够帮助Kratos用户快速开发高性能的HTTP服务。</p><p>Blademaster作为Kratos框架的HTTP服务组件之一，提供了路由、中间件、请求和响应等HTTP相关功能，同时也支持HTTPS和Websocket协议。</p><p>Blademaster框架的特点是轻量、易用、高性能。它采用了协程的方式来处理HTTP请求，从而能够在单线程的情况下支持高并发请求，并且不会受到线程切换带来的性能损耗。同时，Blademaster还提供了灵活的中间件机制，使得用户能够在HTTP请求处理过程中插入自定义的逻辑。</p><p>因此，Blademaster是Kratos框架中非常重要的一个组件，对于开发高性能的HTTP服务具有很大的帮助。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;kratos框架中的bm是什么？(Blademaster)&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;我在学习kratos框架中发现http部分经常用blademaster出现，请帮我推测下blademaster指的是什么吧？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在Kr</summary>
      
    
    
    
    
    <category term="kratos" scheme="https://tbghg.github.io/tags/kratos/"/>
    
  </entry>
  
  <entry>
    <title>开发环境区别</title>
    <link href="https://tbghg.github.io/2023-03-03/07a23e20ef0d/"/>
    <id>https://tbghg.github.io/2023-03-03/07a23e20ef0d/</id>
    <published>2023-03-03T12:55:40.000Z</published>
    <updated>2023-03-03T12:55:40.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>目标：了解FAT, UAT, PRE, PROD环境的区别</p></blockquote><ul><li>FAT (Feature Acceptance Test environment) : 功能验收测试环境，用于软件测试者测试使用</li><li>UAT(User Acceptance Test environment): 用户验收测试环境，用于生产环境下的软件测试者测试使用</li><li>PRE ：灰度环境，外部用户可以访问，但是服务器配置相对低，其它和生产一样，外部用户可以访问，版本发布初期，正式版本发布前</li><li>PROD（Production environment）：生产环境，面向外部用户的环境，正式环境，连接上互联网即可访问</li></ul><p>补充：</p><ul><li>SIT(System Integration Test ): 系统集成测试，开发人员自己测试流程是否走通</li><li>TEST: 测试环境，外部用户无法访问，专门给测试人员使用的，版本相对稳定</li><li>DEV （Development environment） ： 开发环境，外部用户无法访问，开发人员使用，版本变动很大</li></ul><blockquote><p>什么是CI&#x2F;CD</p></blockquote><ul><li>CI：持续集成（CONTINUOUS INTEGRATION）</li><li>CD：持续部署（CONTINUOUS DEPLOYMENT）</li><li>CD：持续交付（CONTINUOUS DELIVERY）</li></ul><p>持续集成（Continuous Integration）简称CI，持续集成强调开发人员提交了新代码之后，立刻自动的进行构建、（单元）测试。根据测试结果，我们可以确定新代码和原有代码能否正确地集成在一起。 </p><p>持续部署（Continuous Deployment）  代码通过评审之后，自动部署到生产环境中。持续部署是持续交付的最高阶段。  强调  1、持续部署是自动的  2、持续部署是持续交付的最高阶段  3、持续交付表示的是一种能力，持续部署则是一种方式</p><p>参考文章</p><ul><li><a class="link"   href="https://blog.csdn.net/shunnianlv/article/details/106384384" >环境整理（pro、sit、uat、test、pre、dev、fat ）<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://cloud.tencent.com/developer/article/2016846" >软件运维开发过程中常用的名称解释DEV、FAT 、UAT、PRO 、CI、CD<i class="fas fa-external-link-alt"></i></a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;目标：了解FAT, UAT, PRE, PROD环境的区别&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;FAT (Feature Acceptance Test environment) : 功能验收测试环境，用于软件测试者测试使用&lt;/l</summary>
      
    
    
    
    
    <category term="开发环境" scheme="https://tbghg.github.io/tags/%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/"/>
    
  </entry>
  
  <entry>
    <title>回溯算法总结[更新ing]</title>
    <link href="https://tbghg.github.io/2023-03-01/daf6fe842456/"/>
    <id>https://tbghg.github.io/2023-03-01/daf6fe842456/</id>
    <published>2023-03-01T14:54:17.000Z</published>
    <updated>2023-03-01T14:54:17.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Golang写回溯注意事项"><a href="#Golang写回溯注意事项" class="headerlink" title="Golang写回溯注意事项"></a>Golang写回溯注意事项</h2><ol><li>闭包写完回溯函数后，不要忘记 <strong>调用回溯函数</strong></li><li>将<code>path</code>装入<code>result</code>时，不可直接添加需要复制</li><li><code>for</code>循环内部调用时，注意<code>dfs</code>里传入<code>start</code>(初始值) 还是<code>i</code>(当前值) 还是 其他</li></ol><p>复制数组时，可以<code>copy</code>，也可以<code>...</code>拆分后重组</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方法一：copy</span></span><br><span class="line">tmp := <span class="built_in">make</span>([]<span class="type">int</span>,<span class="built_in">len</span>(path)) <span class="comment">// 注意：长度必须和path一致</span></span><br><span class="line"><span class="built_in">copy</span>(tmp, path)</span><br><span class="line">res = <span class="built_in">append</span>(res, tmp)</span><br><span class="line"><span class="comment">// 方法二：拆分后重组</span></span><br><span class="line">res = <span class="built_in">append</span>(res,<span class="built_in">append</span>([]<span class="type">int</span>&#123;&#125;,path...))</span><br></pre></td></tr></table></figure><p>注意copy的用法：不会因为<code>srcSlice</code>大而发生扩容，<code>destSlice</code>分配过多少空间就写多少空间</p><p><code>copy( destSlice, srcSlice []T) int</code></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>原本不想写的，但回溯算法规律性太强了，写个总结以后也方便复习。根据代码随想录总结的，插了些自己的看法</p><h2 id="回溯介绍"><a href="#回溯介绍" class="headerlink" title="回溯介绍"></a>回溯介绍</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>回溯法也可以叫做回溯搜索法，它是一种搜索的方式。<strong>回溯的本质是穷举</strong>，但也可以加一些剪枝的操作</p><p>有的问题暴力直接写写不出来，此时需要借助回溯实现暴力，回溯可解决的常见问题有：</p><ul><li>组合问题：N个数里面按一定规则找出k个数的集合</li><li>切割问题：一个字符串按一定规则有几种切割方式</li><li>子集问题：一个N个数的集合里有多少符合条件的子集</li><li>排列问题：N个数按一定规则全排列，有几种排列方式</li><li>棋盘问题：N皇后，解数独等</li></ul><p><strong>回溯法解决的问题都可以抽象为树形结构</strong></p><p><img                       lazyload                     alt="image"                     data-src="https://s2.loli.net/2023/01/25/U9JqYyg7jOBasep.png"                      alt="回溯算法理论基础"                ></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">backtracking</span><span class="params">(参数)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (终止条件) &#123;</span><br><span class="line">        存放结果;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) &#123;</span><br><span class="line">        处理节点;</span><br><span class="line">        <span class="built_in">backtracking</span>(路径，选择列表); <span class="comment">// 递归</span></span><br><span class="line">        回溯，撤销处理结果</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要注意力扣中全局变量的用法：<a href="https://tbghg.github.io/2022-12-14/9161b2cfd0a9/">力扣全局变量</a>，力扣里面，全局变量只初始化一次，之后只是调用目标函数，所以在函数内部初始化</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> (</span><br><span class="line">path   []<span class="type">int</span></span><br><span class="line">result [][]<span class="type">int</span></span><br><span class="line">)</span><br><span class="line"><span class="comment">// 假设combine为力扣入口函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">combine</span><span class="params">(n <span class="type">int</span>, k <span class="type">int</span>)</span></span> [][]<span class="type">int</span> &#123;</span><br><span class="line">path = <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">0</span>,k)<span class="comment">// 全局变量必须函数内部再次初始化</span></span><br><span class="line">result = <span class="built_in">make</span>([][]<span class="type">int</span>, <span class="number">0</span>)</span><br><span class="line">backtrack(n, k, <span class="number">1</span>)</span><br><span class="line"><span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我这里推荐直接写闭包，个人喜欢将回溯函数命名<code>dfs</code></p><h3 id="题目分类"><a href="#题目分类" class="headerlink" title="题目分类"></a>题目分类</h3><ul><li>组合<ul><li><a class="link"   href="https://leetcode.cn/problems/combinations/" >77 组合<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://leetcode.cn/problems/letter-combinations-of-a-phone-number/" >17 电话号码的字母组合<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://leetcode.cn/problems/combination-sum/" >39 组合总和<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://leetcode.cn/problems/combination-sum-ii/" >40 组合总和 II<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://leetcode.cn/problems/combination-sum-iii/" >216 组合总和 III<i class="fas fa-external-link-alt"></i></a></li></ul></li><li>分割<ul><li><a class="link"   href="https://leetcode.cn/problems/palindrome-partitioning/" >131 分割回文串<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://leetcode.cn/problems/restore-ip-addresses/" >93 复原 IP 地址<i class="fas fa-external-link-alt"></i></a></li></ul></li><li>子集<ul><li><a class="link"   href="https://leetcode.cn/problems/subsets/" >78 子集<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://leetcode.cn/problems/subsets-ii/" >90 子集 II<i class="fas fa-external-link-alt"></i></a></li></ul></li><li>排序<ul><li><a class="link"   href="https://leetcode.cn/problems/permutations/" >46 全排列<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://leetcode.cn/problems/permutations-ii/" >47 全排列 II<i class="fas fa-external-link-alt"></i></a></li></ul></li><li>棋盘<ul><li><a class="link"   href="https://leetcode.cn/problems/n-queens/" >51 N 皇后<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://leetcode.cn/problems/sudoku-solver/" >37 解数独<i class="fas fa-external-link-alt"></i></a></li></ul></li><li>其他<ul><li><a class="link"   href="https://leetcode.cn/problems/non-decreasing-subsequences/" >491 递增子序列<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://leetcode.cn/problems/reconstruct-itinerary/" >332 重新安排行程<i class="fas fa-external-link-alt"></i></a></li></ul></li></ul><h2 id="组合问题"><a href="#组合问题" class="headerlink" title="组合问题"></a>组合问题</h2><h3 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h3><h3 id="77-组合"><a href="#77-组合" class="headerlink" title="77 组合"></a><a class="link"   href="https://leetcode.cn/problems/combinations/" >77 组合<i class="fas fa-external-link-alt"></i></a></h3><p>给定两个整数 <code>n</code> 和 <code>k</code>，返回范围 <code>[1, n]</code> 中所有可能的 <code>k</code> 个数的组合。你可以按 <strong>任何顺序</strong> 返回答案。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 4, k = 2</span><br><span class="line">输出：</span><br><span class="line">[</span><br><span class="line">  [2,4],</span><br><span class="line">  [3,4],</span><br><span class="line">  [2,3],</span><br><span class="line">  [1,2],</span><br><span class="line">  [1,3],</span><br><span class="line">  [1,4],</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 1, k = 1</span><br><span class="line">输出：[[1]]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= n &lt;= 20</code></li><li><code>1 &lt;= k &lt;= n</code></li></ul><p><img                       lazyload                     alt="image"                     data-src="https://s2.loli.net/2023/01/25/9QRPDqpnI8iFlcC.png"                                     ></p><p><strong>重点</strong>：左侧取1的那个分支 会包含 所有 取数组中下表为0的情况，所以之后从2、3、4开始取时不用管那个1了，这个是在回溯内部的<code>for</code>循环中实现的，而 树往下延申 是 通过回溯实现</p><p><strong>图中可以发现n相当于树的宽度，k相当于树的深度</strong>，<strong>每次搜索到了叶子节点，我们就找到了一个结果</strong></p><p>只需要把达到叶子节点的结果收集起来，就可以求得n个数中k个数的组合集合</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">combine</span><span class="params">(n <span class="type">int</span>, k <span class="type">int</span>)</span></span> [][]<span class="type">int</span> &#123;</span><br><span class="line">path := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">0</span>, k)</span><br><span class="line">res := <span class="built_in">make</span>([][]<span class="type">int</span>, <span class="number">0</span>)</span><br><span class="line"><span class="keyword">var</span> dfs <span class="function"><span class="keyword">func</span><span class="params">(<span class="type">int</span>)</span></span></span><br><span class="line">dfs = <span class="function"><span class="keyword">func</span><span class="params">(idx <span class="type">int</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(path) == k &#123;</span><br><span class="line">res = <span class="built_in">append</span>(res, <span class="built_in">append</span>([]<span class="type">int</span>&#123;&#125;, path...))</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> i := idx; i &lt;= n; i++ &#123;</span><br><span class="line">path = <span class="built_in">append</span>(path, i)</span><br><span class="line"><span class="comment">// 进入包含下标为i的分支</span></span><br><span class="line">dfs(i+<span class="number">1</span>)  <span class="comment">// 子节点不再重复选自己，所以 i+1</span></span><br><span class="line">path = path[:<span class="built_in">len</span>(path)<span class="number">-1</span>]</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">dfs(<span class="number">1</span>)  <span class="comment">// 记着调用</span></span><br><span class="line"><span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，回溯的题都要考虑是否可以 <u>剪枝优化</u></p><p>这道题，当 还剩的节点数目 + path中已经选中的 &lt; k ，即<code> n-i+1 + len(path) &lt; k</code>该节点及其子节点肯定都不满足，没必要接着<code>for</code>循环了，直接<code>return</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">combine</span><span class="params">(n <span class="type">int</span>, k <span class="type">int</span>)</span></span> [][]<span class="type">int</span> &#123;</span><br><span class="line">path := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">0</span>, k)</span><br><span class="line">res := <span class="built_in">make</span>([][]<span class="type">int</span>, <span class="number">0</span>)</span><br><span class="line"><span class="keyword">var</span> dfs <span class="function"><span class="keyword">func</span><span class="params">(<span class="type">int</span>)</span></span></span><br><span class="line">dfs = <span class="function"><span class="keyword">func</span><span class="params">(idx <span class="type">int</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(path) == k &#123;</span><br><span class="line">res = <span class="built_in">append</span>(res, <span class="built_in">append</span>([]<span class="type">int</span>&#123;&#125;, path...))</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> i := idx; i &lt;= n; i++ &#123;</span><br><span class="line">            <span class="keyword">if</span> n - i + <span class="number">1</span> &lt; k - <span class="built_in">len</span>(path) &#123; <span class="comment">// 剪枝</span></span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">path = <span class="built_in">append</span>(path, i)</span><br><span class="line"><span class="comment">// 进入包含下标为i的分支</span></span><br><span class="line">dfs(i+<span class="number">1</span>)  <span class="comment">// 子节点不再重复选自己，所以 i+1</span></span><br><span class="line">path = path[:<span class="built_in">len</span>(path)<span class="number">-1</span>]</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">dfs(<span class="number">1</span>)  <span class="comment">// 记着调用</span></span><br><span class="line"><span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="216-组合总和-III"><a href="#216-组合总和-III" class="headerlink" title="216 组合总和 III"></a>216 组合总和 III</h3><p>找出所有相加之和为 <code>n</code> 的 <code>k</code> 个数的组合，且满足下列条件：</p><ul><li>只使用数字1到9</li><li>每个数字 <strong>最多使用一次</strong></li></ul><p>返回 <em>所有可能的有效组合的列表</em> 。该列表不能包含相同的组合两次，组合可以以任何顺序返回。</p><p><strong>示例 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入: k = 3, n = 7</span><br><span class="line">输出: [[1,2,4]]</span><br><span class="line">解释:</span><br><span class="line">1 + 2 + 4 = 7</span><br><span class="line">没有其他符合的组合了。</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入: k = 3, n = 9</span><br><span class="line">输出: [[1,2,6], [1,3,5], [2,3,4]]</span><br><span class="line">解释:</span><br><span class="line">1 + 2 + 6 = 9</span><br><span class="line">1 + 3 + 5 = 9</span><br><span class="line">2 + 3 + 4 = 9</span><br><span class="line">没有其他符合的组合了。</span><br></pre></td></tr></table></figure><p><strong>示例 3:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: k = 4, n = 1</span><br><span class="line">输出: []</span><br><span class="line">解释: 不存在有效的组合。</span><br><span class="line">在[1,9]范围内使用4个不同的数字，我们可以得到的最小和是1+2+3+4 = 10，因为10 &gt; 1，没有有效的组合。</span><br></pre></td></tr></table></figure><p><strong>提示:</strong></p><ul><li><code>2 &lt;= k &lt;= 9</code></li><li><code>1 &lt;= n &lt;= 60</code></li></ul><p>k 相当于树的深度，9（因为整个集合就是9个数）就是树的宽度</p><p>例如 k &#x3D; 2，n &#x3D; 4 的话，就是在集合[1,2,3,4,5,6,7,8,9]中求 k（个数） &#x3D; 2, n（和） &#x3D; 4的组合。</p><p><img                       lazyload                     alt="image"                     data-src="https://s2.loli.net/2023/03/01/lA2FOaiPr7zVky9.png"                      alt="216.组合总和III1"                ></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Golang写回溯注意事项&quot;&gt;&lt;a href=&quot;#Golang写回溯注意事项&quot; class=&quot;headerlink&quot; title=&quot;Golang写回溯注意事项&quot;&gt;&lt;/a&gt;Golang写回溯注意事项&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;闭包写完回溯函数后，不要忘记 &lt;stro</summary>
      
    
    
    
    
    <category term="算法" scheme="https://tbghg.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>k8s集群搭建记录</title>
    <link href="https://tbghg.github.io/2023-02-07/f76372a212bb/"/>
    <id>https://tbghg.github.io/2023-02-07/f76372a212bb/</id>
    <published>2023-02-07T07:47:33.000Z</published>
    <updated>2023-02-07T07:47:33.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本次环境搭建需要安装三台Centos服务器（一主二从），然后在每台服务器中分别安装docker（18.06.3），kubeadm（1.17.4）、kubelet（1.17.4）、kubectl（1.17.4）程序</p><p>之前配置hadoop集群的时候配置过hosts，设置过免密登录，这里直接拿来用了，参考黑马程序员的配置过程进行配置的</p><p>有个坑需要注意一下，我一开始是登录三个tbh-0001主机，然后免密登录直接切换，同时执行reboot命令可能会造成混乱，所以推荐直接登录三台主机</p><h2 id="环境初始化"><a href="#环境初始化" class="headerlink" title="环境初始化"></a>环境初始化</h2><ol><li>检查操作系统的版本</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">此方式下安装kubernetes集群要求Centos版本要在7.5或之上</span></span><br><span class="line">[root@tbh-0001 ~]# cat /etc/redhat-release </span><br><span class="line">CentOS Linux release 7.6.1810 (Core) </span><br></pre></td></tr></table></figure><ol start="2"><li>主机名解析</li></ol><p>以前搭建hadoop集群实验时做过了，正好接着用，同时都配置了免密登录</p><p>企业中建议配置DNS服务器</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@tbh-0001 ~]# cat /etc/hosts</span><br><span class="line">::1localhostlocalhost.localdomainlocalhost6localhost6.localdomain6</span><br><span class="line">192.168.0.181tbh-0001tbh-0001</span><br><span class="line">192.168.0.75tbh-0003tbh-0003</span><br><span class="line">192.168.0.105tbh-0002tbh-0002</span><br><span class="line"></span><br><span class="line">127.0.0.1localhostlocalhost.localdomainlocalhost4localhost4.localdomain4</span><br><span class="line">127.0.0.1tbhtbh</span><br></pre></td></tr></table></figure><ol start="3"><li>时间同步</li></ol><p>kubernetes要求集群中的节点时间必须精确一致，这里直接使用chronyd服务从网络同步时间</p><p>企业中建议配置内部的时间同步服务器</p><p>这里三个都要配，我这里用的是xshell的“发送键至所有的会话框”，下面就展示一个了</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">启动chronyd服务</span></span><br><span class="line">[root@tbh-0001 ~]# systemctl start chronyd</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">设置chronyd服务开机自启</span></span><br><span class="line">[root@tbh-0001 ~]# systemctl enable chronyd</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">chronyd服务启动稍等几秒钟，就可以使用<span class="built_in">date</span>命令验证时间了</span></span><br><span class="line">[root@tbh-0001 ~]# date</span><br></pre></td></tr></table></figure><p>看到三个的输出时间一致证明配置成功</p><ol start="4"><li>禁用iptables和firewalld服务</li></ol><p>kubernetes和docker在运行中会产生大量的iptables规则，为了不让系统规则跟它们混淆，直接关闭系统的规则</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1 关闭firewalld服务</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">tbh</span>-<span class="number">0001</span> ~]<span class="comment"># systemctl stop firewalld</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">tbh</span>-<span class="number">0001</span> ~]<span class="comment"># systemctl disable firewalld</span></span><br><span class="line"><span class="comment"># 2 关闭iptables服务</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">tbh</span>-<span class="number">0001</span> ~]<span class="comment"># systemctl stop iptables</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">tbh</span>-<span class="number">0001</span> ~]<span class="comment"># systemctl disable iptables</span></span><br></pre></td></tr></table></figure><ol start="5"><li>禁用selinux</li></ol><p> selinux是linux系统下的一个安全服务，如果不关闭它，在安装集群中会产生各种各样的奇葩问题</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 编辑 /etc/selinux/config 文件，修改SELINUX的值为disabled</span></span><br><span class="line"><span class="comment"># 注意修改完毕之后需要重启linux服务</span></span><br><span class="line">SELINUX=disabled</span><br></pre></td></tr></table></figure><ol start="6"><li>禁用swap分区</li></ol><p>swap分区指的是虚拟内存分区，它的作用是在物理内存使用完之后，将磁盘空间虚拟成内存来使用</p><p>启用swap设备会对系统的性能产生非常负面的影响，因此kubernetes要求每个节点都要禁用swap设备</p><p>但是如果因为某些原因确实不能关闭swap分区，就需要在集群安装过程中通过明确的参数进行配置说明</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 编辑分区配置文件/etc/fstab，注释掉swap分区一行</span></span><br><span class="line"><span class="comment"># 注意修改完毕之后需要重启linux服务</span></span><br><span class="line"> UUID=<span class="number">455</span>cc753<span class="literal">-7a60-4c17-a424-7741728c44a1</span> /boot    xfs     defaults        <span class="number">0</span> <span class="number">0</span></span><br><span class="line"> /dev/mapper/centos<span class="literal">-home</span> /home                      xfs     defaults        <span class="number">0</span> <span class="number">0</span></span><br><span class="line"><span class="comment"># /dev/mapper/centos-swap swap                      swap    defaults        0 0</span></span><br></pre></td></tr></table></figure><p>7）修改linux的内核参数</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 修改linux的内核参数，添加网桥过滤和地址转发功能</span></span><br><span class="line"><span class="comment"># 编辑/etc/sysctl.d/kubernetes.conf文件，添加如下配置:</span></span><br><span class="line">net.bridge.bridge<span class="literal">-nf-call-ip6tables</span> = <span class="number">1</span></span><br><span class="line">net.bridge.bridge<span class="literal">-nf-call-iptables</span> = <span class="number">1</span></span><br><span class="line">net.ipv4.ip_forward = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 重新加载配置</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">tbh</span>-<span class="number">0001</span> ~]<span class="comment"># sysctl -p</span></span><br><span class="line">vm.swappiness = <span class="number">0</span></span><br><span class="line">net.core.somaxconn = <span class="number">1024</span></span><br><span class="line">net.ipv4.tcp_max_tw_buckets = <span class="number">5000</span></span><br><span class="line">net.ipv4.tcp_max_syn_backlog = <span class="number">1024</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 加载网桥过滤模块</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">tbh</span>-<span class="number">0001</span> ~]<span class="comment"># modprobe br_netfilter</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看网桥过滤模块是否加载成功</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">tbh</span>-<span class="number">0001</span> ~]<span class="comment"># lsmod | grep br_netfilter</span></span><br><span class="line">br_netfilter           <span class="number">22256</span>  <span class="number">0</span> </span><br><span class="line">bridge                <span class="number">151336</span>  <span class="number">1</span> br_netfilter</span><br></pre></td></tr></table></figure><ol start="8"><li>配置ipvs功能</li></ol><p>在kubernetes中service有两种代理模型，一种是基于iptables的，一种是基于ipvs的</p><p>两者比较的话，ipvs的性能明显要高一些，但是如果要使用它，需要手动载入ipvs模块</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1 安装ipset和ipvsadm</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">tbh</span>-<span class="number">0001</span> ~]<span class="comment"># yum install ipset ipvsadmin -y</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2 添加需要加载的模块写入脚本文件</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">tbh</span>-<span class="number">0001</span> ~]<span class="comment"># cat &lt;&lt;EOF &gt;  /etc/sysconfig/modules/ipvs.modules</span></span><br><span class="line"><span class="comment">#!/bin/bash</span></span><br><span class="line">modprobe <span class="literal">--</span> ip_vs</span><br><span class="line">modprobe <span class="literal">--</span> ip_vs_rr</span><br><span class="line">modprobe <span class="literal">--</span> ip_vs_wrr</span><br><span class="line">modprobe <span class="literal">--</span> ip_vs_sh</span><br><span class="line">modprobe <span class="literal">--</span> nf_conntrack_ipv4</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3 为脚本文件添加执行权限</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">tbh</span>-<span class="number">0001</span> ~]<span class="comment"># chmod +x /etc/sysconfig/modules/ipvs.modules</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 4 执行脚本文件</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">tbh</span>-<span class="number">0001</span> ~]<span class="comment"># /bin/bash /etc/sysconfig/modules/ipvs.modules</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 5 查看对应的模块是否加载成功</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">tbh</span>-<span class="number">0001</span> ~]<span class="comment"># lsmod | grep -e ip_vs -e nf_conntrack_ipv4</span></span><br></pre></td></tr></table></figure><ol start="9"><li>重启服务器</li></ol><p>上面步骤完成之后，需要重新启动linux系统</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="type">root</span>@<span class="type">tbh</span>-<span class="number">0001</span> ~]<span class="comment"># reboot</span></span><br></pre></td></tr></table></figure><h2 id="安装docker"><a href="#安装docker" class="headerlink" title="安装docker"></a>安装docker</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">1 切换镜像源</span></span><br><span class="line">[root@tbh-0001 ~]# wget https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo -O /etc/yum.repos.d/docker-ce.repo</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">2 查看当前镜像源中支持的docker版本</span></span><br><span class="line">[root@tbh-0001 ~]# yum list docker-ce --showduplicates</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">3 安装特定版本的docker-ce</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">必须指定--<span class="built_in">setopt</span>=obsoletes=0，否则yum会自动安装更高版本</span></span><br><span class="line">[root@tbh-0001 ~]# yum install --setopt=obsoletes=0 docker-ce-18.06.3.ce-3.el7 -y</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">4 添加一个配置文件</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Docker在默认情况下使用的Cgroup Driver为cgroupfs，而kubernetes推荐使用systemd来代替cgroupfs</span></span><br><span class="line">[root@tbh-0001 ~]# mkdir /etc/docker</span><br><span class="line">[root@tbh-0001 ~]# cat &lt;&lt;EOF &gt;  /etc/docker/daemon.json</span><br><span class="line">&#123;</span><br><span class="line">  &quot;exec-opts&quot;: [&quot;native.cgroupdriver=systemd&quot;],</span><br><span class="line">  &quot;registry-mirrors&quot;: [&quot;https://kn0t2bca.mirror.aliyuncs.com&quot;]</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">5 启动docker</span></span><br><span class="line">[root@tbh-0001 ~]# systemctl restart docker</span><br><span class="line">[root@tbh-0001 ~]# systemctl enable docker</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">6 检查docker状态和版本</span></span><br><span class="line">[root@tbh-0001 ~]# docker version</span><br></pre></td></tr></table></figure><h2 id="安装kubernetes组件"><a href="#安装kubernetes组件" class="headerlink" title="安装kubernetes组件"></a>安装kubernetes组件</h2><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 由于kubernetes的镜像源在国外，速度比较慢，这里切换成国内的镜像源</span></span><br><span class="line"><span class="comment"># 编辑/etc/yum.repos.d/kubernetes.repo，添加下面的配置 </span></span><br><span class="line">[<span class="type">kubernetes</span>]</span><br><span class="line">name=Kubernetes</span><br><span class="line">baseurl=http://mirrors.aliyun.com/kubernetes/yum/repos/kubernetes<span class="literal">-el7-x86_64</span></span><br><span class="line">enabled=<span class="number">1</span></span><br><span class="line">gpgcheck=<span class="number">0</span></span><br><span class="line">repo_gpgcheck=<span class="number">0</span></span><br><span class="line">gpgkey=http://mirrors.aliyun.com/kubernetes/yum/doc/yum<span class="literal">-key</span>.gpg</span><br><span class="line">       http://mirrors.aliyun.com/kubernetes/yum/doc/rpm<span class="literal">-package-key</span>.gpg</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装kubeadm、kubelet和kubectl</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">tbh</span>-<span class="number">0001</span> ~]<span class="comment"># yum install --setopt=obsoletes=0 kubeadm-1.17.4-0 kubelet-1.17.4-0 kubectl-1.17.4-0 -y</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 配置kubelet的cgroup</span></span><br><span class="line"><span class="comment"># 编辑/etc/sysconfig/kubelet，添加下面的配置</span></span><br><span class="line">KUBELET_CGROUP_ARGS=<span class="string">&quot;--cgroup-driver=systemd&quot;</span></span><br><span class="line">KUBE_PROXY_MODE=<span class="string">&quot;ipvs&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 4 设置kubelet开机自启</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">tbh</span>-<span class="number">0001</span> ~]<span class="comment"># systemctl enable kubelet</span></span><br></pre></td></tr></table></figure><h2 id="准备集群镜像"><a href="#准备集群镜像" class="headerlink" title="准备集群镜像"></a>准备集群镜像</h2><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在安装kubernetes集群之前，必须要提前准备好集群需要的镜像，所需镜像可以通过下面命令查看</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">tbh</span>-<span class="number">0001</span> ~]<span class="comment"># kubeadm config images list</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 下载镜像</span></span><br><span class="line"><span class="comment"># 此镜像在kubernetes的仓库中,由于网络原因,无法连接，下面提供了一种替代方案</span></span><br><span class="line">images=(</span><br><span class="line">    kube<span class="literal">-apiserver</span>:v1.<span class="number">17.4</span></span><br><span class="line">    kube<span class="literal">-controller-manager</span>:v1.<span class="number">17.4</span></span><br><span class="line">    kube<span class="literal">-scheduler</span>:v1.<span class="number">17.4</span></span><br><span class="line">    kube<span class="literal">-proxy</span>:v1.<span class="number">17.4</span></span><br><span class="line">    pause:<span class="number">3.1</span></span><br><span class="line">    etcd:<span class="number">3.4</span>.<span class="number">3</span><span class="literal">-0</span></span><br><span class="line">    coredns:<span class="number">1.6</span>.<span class="number">5</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> imageName <span class="keyword">in</span> <span class="variable">$</span>&#123;images[<span class="selector-tag">@</span>]&#125; ; <span class="keyword">do</span></span><br><span class="line">docker pull registry.cn<span class="literal">-hangzhou</span>.aliyuncs.com/google_containers/<span class="variable">$imageName</span></span><br><span class="line">docker tag registry.cn<span class="literal">-hangzhou</span>.aliyuncs.com/google_containers/<span class="variable">$imageName</span> k8s.gcr.io/<span class="variable">$imageName</span></span><br><span class="line">docker rmi registry.cn<span class="literal">-hangzhou</span>.aliyuncs.com/google_containers/<span class="variable">$imageName</span></span><br><span class="line">done</span><br></pre></td></tr></table></figure><h3 id="集群初始化"><a href="#集群初始化" class="headerlink" title="集群初始化"></a>集群初始化</h3><p>下面开始对集群进行初始化，并将node节点加入到集群中</p><blockquote><p>下面的操作只需要在<code>tbh-0001</code>节点上执行即可</p></blockquote><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建集群</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">tbh</span>-<span class="number">0001</span> ~]<span class="comment"># kubeadm init \</span></span><br><span class="line"><span class="literal">--kubernetes-version</span>=v1.<span class="number">17.4</span> \</span><br><span class="line">    <span class="literal">--pod-network-cidr</span>=<span class="number">10.244</span>.<span class="number">0.0</span>/<span class="number">16</span> \</span><br><span class="line">    <span class="literal">--service-cidr</span>=<span class="number">10.96</span>.<span class="number">0.0</span>/<span class="number">12</span> \</span><br><span class="line">    <span class="literal">--apiserver-advertise-address</span>=<span class="number">192.168</span>.<span class="number">0.181</span></span><br></pre></td></tr></table></figure><p>直接<code>kubectl get nodes</code>会报错：<code>The connection to the server localhost:8080 was refused - did you specify the right host or port?</code>，出现这个问题的原因是kubectl命令需要使用kubernetes-admin来运行，上文输出中提示了解决办法：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建必要文件</span></span><br><span class="line">[root@tbh-0001 ~]# mkdir -p $HOME/.kube</span><br><span class="line">[root@tbh-0001 ~]# sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config</span><br><span class="line">[root@tbh-0001 ~]# sudo chown $(id -u):$(id -g) $HOME/.kube/config</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">成功运行</span></span><br><span class="line">[root@tbh-0001 ~]# kubectl get nodes</span><br><span class="line">NAME       STATUS     ROLES    AGE    VERSION</span><br><span class="line">tbh-0001   NotReady   tbh-0001   5m7s   v1.17.4</span><br></pre></td></tr></table></figure><blockquote><p>下面的操作只需要在<code>node</code>节点上执行即可</p></blockquote><p>在tbh-0001上执行后会输出node节点加入集群所需要输入的命令，直接复制即可</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将node节点加入集群</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">tbh</span>-<span class="number">0002</span> ~]<span class="comment"># kubeadm join 192.168.0.181:6443 --token 1p2izv.b6arlpik2red8wyq \</span></span><br><span class="line">    <span class="literal">--discovery-token-ca-cert-hash</span> \ </span><br><span class="line">    sha256:<span class="number">514</span>ef66c3a916ef5a9174e3414140d668e24db612ebd24ca068eedcc288d07e1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看集群状态 此时的集群状态为NotReady，这是因为还没有配置网络插件</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">tbh</span>-<span class="number">0001</span> ~]<span class="comment"># kubectl get nodes</span></span><br><span class="line">NAME       STATUS     ROLES    AGE     VERSION</span><br><span class="line">tbh<span class="literal">-0001</span>   NotReady   tbh<span class="literal">-0001</span>   <span class="number">8</span>m10s   v1.<span class="number">17.4</span></span><br><span class="line">tbh<span class="literal">-0002</span>   NotReady   &lt;none&gt;   <span class="number">11</span>s     v1.<span class="number">17.4</span></span><br><span class="line">tbh<span class="literal">-0003</span>   NotReady   &lt;none&gt;   <span class="number">4</span>s      v1.<span class="number">17.4</span></span><br></pre></td></tr></table></figure><h3 id="安装网络插件"><a href="#安装网络插件" class="headerlink" title="安装网络插件"></a>安装网络插件</h3><p>kubernetes支持多种网络插件，比如flannel、calico、canal等等，任选一种使用即可，本次选择flannel</p><blockquote><p>下面操作依旧只在<code>tbh-0001</code>节点执行即可，插件使用的是DaemonSet的控制器，它会在每个节点上都运行</p></blockquote><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 获取fannel的配置文件</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">tbh</span>-<span class="number">0001</span> ~]<span class="comment"># wget https://raw.githubusercontent.com/coreos/flannel/tbh-0001/Documentation/kube-flannel.yml</span></span><br><span class="line"></span><br><span class="line">vim kube<span class="literal">-flannel</span>.yml</span><br><span class="line"><span class="comment"># 查询image，注释掉第一个留下带mirror的那个即可(换源)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用配置文件启动fannel</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">tbh</span>-<span class="number">0001</span> ~]<span class="comment"># kubectl apply -f kube-flannel.yml</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 稍等片刻，再次查看集群节点的状态(得等一会儿)</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">tbh</span>-<span class="number">0001</span> ~]<span class="comment"># kubectl get nodes</span></span><br><span class="line">NAME       STATUS   ROLES    AGE   VERSION</span><br><span class="line">tbh<span class="literal">-0001</span>   Ready    tbh<span class="literal">-0001</span>   <span class="number">21</span>m   v1.<span class="number">17.4</span></span><br><span class="line">tbh<span class="literal">-0002</span>   Ready    &lt;none&gt;   <span class="number">13</span>m   v1.<span class="number">17.4</span></span><br><span class="line">tbh<span class="literal">-0003</span>   Ready    &lt;none&gt;   <span class="number">13</span>m   v1.<span class="number">17.4</span></span><br></pre></td></tr></table></figure><p>至此，kubernetes的集群环境搭建完成</p><h2 id="服务部署"><a href="#服务部署" class="headerlink" title="服务部署"></a>服务部署</h2><p>接下来在kubernetes集群中部署一个nginx程序，测试下集群是否在正常工作。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 部署nginx</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">tbh</span>-<span class="number">0001</span> ~]<span class="comment"># kubectl create deployment nginx --image=nginx:1.14-alpine</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 暴露端口</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">tbh</span>-<span class="number">0001</span> ~]<span class="comment"># kubectl expose deployment nginx --port=80 --type=NodePort</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看服务状态</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">tbh</span>-<span class="number">0001</span> ~]<span class="comment"># kubectl get pods,service</span></span><br><span class="line">NAME                         READY   STATUS              RESTARTS   AGE</span><br><span class="line">pod/nginx<span class="literal">-6867cdf567-flcfc</span>   <span class="number">0</span>/<span class="number">1</span>     ContainerCreating   <span class="number">0</span>          <span class="number">13</span>s</span><br><span class="line"></span><br><span class="line">NAME                 <span class="built_in">TYPE</span>        CLUSTER<span class="literal">-IP</span>      EXTERNAL<span class="literal">-IP</span>   PORT(S)        AGE</span><br><span class="line">service/kubernetes   ClusterIP   <span class="number">10.96</span>.<span class="number">0.1</span>       &lt;none&gt;        <span class="number">443</span>/TCP        <span class="number">23</span>m</span><br><span class="line">service/nginx        NodePort    <span class="number">10.99</span>.<span class="number">122.158</span>   &lt;none&gt;        <span class="number">80</span>:<span class="number">31450</span>/TCP   <span class="number">7</span>s</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 4 最后访问下部署的nginx服务</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">tbh</span>-<span class="number">0001</span> ~]<span class="comment"># curl 192.168.0.181:31450</span></span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;title&gt;Welcome to nginx!&lt;/title&gt;</span><br><span class="line">&lt;style&gt;</span><br><span class="line">    body &#123;</span><br><span class="line">        width: <span class="number">35</span>em;</span><br><span class="line">        margin: <span class="number">0</span> auto;</span><br><span class="line">        font<span class="literal">-family</span>: Tahoma, Verdana, Arial, sans<span class="literal">-serif</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;h1&gt;Welcome to nginx!&lt;/h1&gt;</span><br><span class="line">&lt;p&gt;<span class="keyword">If</span> you see this page, the nginx web server is successfully installed and</span><br><span class="line">working. Further configuration is required.&lt;/p&gt;</span><br><span class="line"></span><br><span class="line">&lt;p&gt;<span class="keyword">For</span> online documentation and support please refer to</span><br><span class="line">&lt;a href=<span class="string">&quot;http://nginx.org/&quot;</span>&gt;nginx.org&lt;/a&gt;.&lt;br/&gt;</span><br><span class="line">Commercial support is available at</span><br><span class="line">&lt;a href=<span class="string">&quot;http://nginx.com/&quot;</span>&gt;nginx.com&lt;/a&gt;.&lt;/p&gt;</span><br><span class="line"></span><br><span class="line">&lt;p&gt;&lt;em&gt;Thank you <span class="keyword">for</span> <span class="keyword">using</span> nginx.&lt;/em&gt;&lt;/p&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>k8s部署测试成功！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;本次环境搭建需要安装三台Centos服务器（一主二从），然后在每台服务器中分别安装docker（18.06.3），kubeadm（1.17.</summary>
      
    
    
    
    
    <category term="k8s" scheme="https://tbghg.github.io/tags/k8s/"/>
    
  </entry>
  
  <entry>
    <title>go-设计模式-精简版-创建型模式</title>
    <link href="https://tbghg.github.io/2023-01-31/63ddef404aa2/"/>
    <id>https://tbghg.github.io/2023-01-31/63ddef404aa2/</id>
    <published>2023-01-31T10:23:39.000Z</published>
    <updated>2023-01-31T10:23:39.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>整理自刘丹冰老师的<a class="link"   href="https://www.yuque.com/aceld/lfhu8y" >《Easy 搞定 Golang设计模式》<i class="fas fa-external-link-alt"></i></a></p><p>说是整理，到最后发现基本都是文章中的内容:p</p><h2 id="Go中的组合与继承"><a href="#Go中的组合与继承" class="headerlink" title="Go中的组合与继承"></a>Go中的组合与继承</h2><p>参考文章：<a class="link"   href="https://www.cnblogs.com/watermelonjuice/p/11745156.html" >go继承<i class="fas fa-external-link-alt"></i></a></p><p>go中没有继承，只能通过组合来实现继承</p><p>继承就是子类继承了父类的特征和行为，使得子类实例具有父类的行为和方法<br>组合就是通过对现有对象的拼装从而获得实现更为复杂的行为的方法</p><ul><li>一个struct嵌套了另外一个匿名的struct从而实现了继承，嵌套多个匿名struct实现多重继承。</li><li>一个struct嵌套了另外一个struct的实例实现了组合。</li></ul><p>示例出处：<a class="link"   href="https://www.topgoer.com/go%E5%9F%BA%E7%A1%80/%E7%BB%93%E6%9E%84%E4%BD%93.html#%E7%BB%93%E6%9E%84%E4%BD%93%E7%9A%84%E7%BB%A7%E6%89%BF" >go结构体的“继承”<i class="fas fa-external-link-alt"></i></a></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Animal 动物</span></span><br><span class="line"><span class="keyword">type</span> Animal <span class="keyword">struct</span> &#123;</span><br><span class="line">    name <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *Animal)</span></span> move() &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;%s会动！\n&quot;</span>, a.name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Dog 狗</span></span><br><span class="line"><span class="keyword">type</span> Dog <span class="keyword">struct</span> &#123;</span><br><span class="line">    Feet    <span class="type">int8</span></span><br><span class="line">    *Animal <span class="comment">//通过嵌套匿名结构体实现继承</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *Dog)</span></span> wang() &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;%s会汪汪汪~\n&quot;</span>, d.name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    d1 := &amp;Dog&#123;</span><br><span class="line">        Feet: <span class="number">4</span>,</span><br><span class="line">        Animal: &amp;Animal&#123; <span class="comment">//注意嵌套的是结构体指针</span></span><br><span class="line">            name: <span class="string">&quot;乐乐&quot;</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;</span><br><span class="line">    d1.wang() <span class="comment">//乐乐会汪汪汪~</span></span><br><span class="line">    d1.move() <span class="comment">//乐乐会动！</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>go继承是通过嵌套匿名struct实现继承。</li><li>go继承在本质上还是组合。</li><li>子类要调用父类的实现可以通过调用组合中的父类对象的方法。</li><li>多重继承中不允许多个父类出现相同的方法。(编译不通过)</li></ol><h2 id="设计模式概述"><a href="#设计模式概述" class="headerlink" title="设计模式概述"></a>设计模式概述</h2><p>设计模式是在特定环境下人们解决某类重复出现问题的一套成功或有效的解决方案。</p><p>GoF给软件设计模式提供了定义，如下：“软件设计模式(Design Pattern)是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结，使用设计模式是为了可重用代码、让代码更容易被他人理解并且保证代码可靠性。”<br>一句大白话可以总结：“在一定环境下，用固定套路解决问题。”</p><p>GoF提出的设计模式有23个，包括：</p><ul><li>创建型(Creational)模式：如何创建对象；</li><li>结构型(Structural )模式：如何实现类或对象的组合；</li><li>行为型(Behavioral)模式：类或对象怎样交互以及怎样分配职责。</li></ul><p>有一个“简单工厂模式”不属于GoF 23种设计模式，但大部分的设计模式书籍都会对它进行专门的介绍。<br>设计模式目前种类： GoF的23种   + “简单工厂模式” &#x3D; 24种。</p><p>学习设计模式的作用：</p><ol><li>如何将代码分散在几个不同的类中？</li><li>为什么要有“接口”？</li><li>何谓针对抽象编程？</li><li>何时不应该使用继承？</li><li>如果不修改源代码增加新功能？</li><li>更好地阅读和理解现有类库与其他系统中的源代码。</li></ol><p>设计模式的基础是：多态。</p><p><a class="link"   href="https://www.yuque.com/aceld/lfhu8y/pebesh?inner=qSWMX" >https://www.yuque.com/aceld/lfhu8y/pebesh?inner=qSWMX<i class="fas fa-external-link-alt"></i></a></p><p><img                       lazyload                     alt="image"                     data-src="https://s2.loli.net/2023/01/31/aG2JCZeXmgwHBOr.png"                      alt="image-20230131164759525"                ></p><p><img                       lazyload                     alt="image"                     data-src="https://s2.loli.net/2023/01/31/XZptWMU8Vlhuwcq.png"                      alt="image-20230131164911533"                ></p><p><img                       lazyload                     alt="image"                     data-src="https://s2.loli.net/2023/01/31/zxtGFLCVS58AlPd.png"                      alt="image-20230131164934491"                ></p><p><img                       lazyload                     alt="image"                     data-src="https://s2.loli.net/2023/01/31/2t15ohVWPiFJw4r.png"                      alt="image-20230131165009691"                ></p><h2 id="面向对象设计原则"><a href="#面向对象设计原则" class="headerlink" title="面向对象设计原则"></a>面向对象设计原则</h2><p>对于面向对象软件系统的设计而言，在支持可维护性的同时，提高系统的可复用性是一个至关重要的问题，<strong>如何同时提高一个软件系统的可维护性和可复用性是面向对象设计需要解决的核心问题之一</strong>。在面向对象设计中，可维护性的复用是以设计原则为基础的。每一个原则都蕴含一些面向对象设计的思想，可以从不同的角度提升一个软件结构的设计水平。</p><p><strong>面向对象设计原则为支持可维护性复用而诞生，这些原则蕴含在很多设计模式中，它们是从许多设计方案中总结出的指导性原则</strong>。面向对象设计原则也是我们用于评价一个设计模式的使用效果的重要指标之一。</p><p>原则的目的： 高内聚，低耦合</p><table><thead><tr><th>名称</th><th>定义</th></tr></thead><tbody><tr><td>单一职责原则 (Single Responsibility Principle, SRP) ★★★★☆</td><td>类的职责单一，对外只提供一种功能，而引起类变化的原因都应该只有一个。</td></tr><tr><td>开闭原则 (Open-Closed Principle, OCP) ★★★★★</td><td>类的改动是通过增加代码进行的，而不是修改源代码。（对扩展开放，对修改封闭）</td></tr><tr><td>里氏代换原则 (Liskov Substitution Principle, LSP ★★★★★</td><td>任何抽象类（interface接口）出现的地方都可以用他的实现类进行替换，实际就是虚拟机制，语言级别实现面向对象功能。</td></tr><tr><td>依赖倒转原则 (Dependence  Inversion Principle, DIP) ★★★★★</td><td>依赖于抽象(接口)，不要依赖具体的实现(类)，也就是针对接口编程。</td></tr><tr><td>接口隔离原则 (Interface Segregation Principle, ISP ★★☆☆☆</td><td>不应该强迫用户的程序依赖他们不需要的接口方法。一个接口应该只提供一种对外功能，不应该把所有操作都封装到一个接口中去。</td></tr><tr><td>合成复用原则 (Composite Reuse Principle, CRP) ★★★★☆</td><td>如果使用继承，会导致父类的任何变换都可能影响到子类的行为。如果使用对象组合，就降低了这种依赖关系。对于继承和组合，优先使用组合。</td></tr><tr><td>迪米特法则 (Law of Demeter, LoD ★★★☆☆</td><td>一个对象应当对其他对象尽可能少的了解，从而降低各个对象之间的耦合，提高系统的可维护性。例如在一个程序中，各个模块之间相互调用时，通常会提供一个统一的接口来实现。这样其他模块不需要了解另外一个模块的内部实现细节，这样当一个模块内部的实现发生改变时，不会影响其他模块的使用。（黑盒原理）</td></tr></tbody></table><h3 id="单一职责原则"><a href="#单一职责原则" class="headerlink" title="单一职责原则"></a>单一职责原则</h3><p>类的职责单一，对外只提供一种功能，而引起类变化的原因都应该只有一个。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> ClothesShop <span class="keyword">struct</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(cs *ClothesShop)</span></span> OnShop() &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;休闲的装扮&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> ClothesWork <span class="keyword">struct</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(cw *ClothesWork)</span></span> OnWork() &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;工作的装扮&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">//工作的时候</span></span><br><span class="line">cw := <span class="built_in">new</span>(ClothesWork)</span><br><span class="line">cw.OnWork()</span><br><span class="line"></span><br><span class="line"><span class="comment">//shopping的时候</span></span><br><span class="line">cs := <span class="built_in">new</span>(ClothesShop)</span><br><span class="line">cs.OnShop()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在面向对象编程的过程中，设计一个类，建议对外提供的功能单一，接口单一，影响一个类的范围就只限定在这一个接口上，一个类的一个接口具备这个类的功能含义，职责单一不复杂。</p><h3 id="开闭原则"><a href="#开闭原则" class="headerlink" title="开闭原则"></a>开闭原则</h3><p>对扩展开放，对修改封闭</p><ul><li>对扩展开放，意味着有新的需求或变化时，可以对现有代码进行扩展，以适应新的情况。</li><li>对修改封闭，意味着类一旦设计完成，就可以独立完成其工作，而不要对已有代码进行任何修改</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//抽象的银行业务员</span></span><br><span class="line"><span class="keyword">type</span> AbstractBanker <span class="keyword">interface</span>&#123;</span><br><span class="line">DoBusi()<span class="comment">//抽象的处理业务接口</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//存款的业务员</span></span><br><span class="line"><span class="keyword">type</span> SaveBanker <span class="keyword">struct</span> &#123;</span><br><span class="line"><span class="comment">//AbstractBanker</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(sb *SaveBanker)</span></span> DoBusi() &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;进行了存款&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//转账的业务员</span></span><br><span class="line"><span class="keyword">type</span> TransferBanker <span class="keyword">struct</span> &#123;</span><br><span class="line"><span class="comment">//AbstractBanker</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(tb *TransferBanker)</span></span> DoBusi() &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;进行了转账&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//支付的业务员</span></span><br><span class="line"><span class="keyword">type</span> PayBanker <span class="keyword">struct</span> &#123;</span><br><span class="line"><span class="comment">//AbstractBanker</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pb *PayBanker)</span></span> DoBusi() &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;进行了支付&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//实现架构层(基于抽象层进行业务封装-针对interface接口进行封装)</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BankerBusiness</span><span class="params">(banker AbstractBanker)</span></span> &#123;</span><br><span class="line"><span class="comment">//通过接口来向下调用，(多态现象)</span></span><br><span class="line">banker.DoBusi()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">BankerBusiness(&amp;SaveBanker&#123;&#125;)</span><br><span class="line">BankerBusiness(&amp;TransferBanker&#123;&#125;)</span><br><span class="line">BankerBusiness(&amp;PayBanker&#123;&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="依赖倒转原则"><a href="#依赖倒转原则" class="headerlink" title="依赖倒转原则"></a>依赖倒转原则</h3><p>依赖于抽象(接口)，不要依赖具体的实现(类)，也就是针对接口编程</p><h4 id="耦合度极高的模块关系设计"><a href="#耦合度极高的模块关系设计" class="headerlink" title="耦合度极高的模块关系设计"></a>耦合度极高的模块关系设计</h4><p><img                       lazyload                     alt="image"                     data-src="https://s2.loli.net/2023/01/31/L4RFymXboPaUjSi.png"                      alt="42-混乱的依赖关系.png"                ></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// === &gt; 奔驰汽车 &lt;===</span></span><br><span class="line"><span class="keyword">type</span> Benz <span class="keyword">struct</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *Benz)</span></span> Run() &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;Benz is running...&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// === &gt; 宝马汽车  &lt;===</span></span><br><span class="line"><span class="keyword">type</span> BMW <span class="keyword">struct</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *BMW)</span></span> Run() &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;BMW is running ...&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//===&gt; 司机张三  &lt;===</span></span><br><span class="line"><span class="keyword">type</span> Zhang3 <span class="keyword">struct</span> &#123;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(zhang3 *Zhang3)</span></span> DriveBenZ(benz *Benz) &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;zhang3 Drive Benz&quot;</span>)</span><br><span class="line">benz.Run()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(zhang3 *Zhang3)</span></span> DriveBMW(bmw *BMW) &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;zhang3 drive BMW&quot;</span>)</span><br><span class="line">bmw.Run()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//===&gt; 司机李四 &lt;===</span></span><br><span class="line"><span class="keyword">type</span> Li4 <span class="keyword">struct</span> &#123;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(li4 *Li4)</span></span> DriveBenZ(benz *Benz) &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;li4 Drive Benz&quot;</span>)</span><br><span class="line">benz.Run()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(li4 *Li4)</span></span> DriveBMW(bmw *BMW) &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;li4 drive BMW&quot;</span>)</span><br><span class="line">bmw.Run()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">//业务1 张3开奔驰</span></span><br><span class="line">benz := &amp;Benz&#123;&#125;</span><br><span class="line">zhang3 := &amp;Zhang3&#123;&#125;</span><br><span class="line">zhang3.DriveBenZ(benz)</span><br><span class="line"></span><br><span class="line"><span class="comment">//业务2 李四开宝马</span></span><br><span class="line">bmw := &amp;BMW&#123;&#125;</span><br><span class="line">li4 := &amp;Li4&#123;&#125;</span><br><span class="line">li4.DriveBMW(bmw)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>假设现在要增加一个 <u>丰田汽车</u> 或者 <u>司机王五</u>， 那么模块和模块的依赖关系将成指数级递增，想蜘蛛网一样越来越难维护和捋顺</p><h3 id="面向抽象层依赖倒转"><a href="#面向抽象层依赖倒转" class="headerlink" title="面向抽象层依赖倒转"></a>面向抽象层依赖倒转<img                       lazyload                     alt="image"                     data-src="https://s2.loli.net/2023/01/31/MBTP3elEIfOp4Fs.png"                      alt="img"                ></h3><p>在设计一个系统的时候，将模块分为3个层次，抽象层、实现层、业务逻辑层。那么，我们首先将抽象层的模块和接口定义出来，这里就需要了interface接口的设计，然后我们依照抽象层，依次实现每个实现层的模块，在我们写实现层代码的时候，实际上我们只需要参考对应的抽象层实现就好了，实现每个模块，也和其他的实现的模块没有关系，这样也符合了上面介绍的开闭原则。这样实现起来每个模块只依赖对象的接口，而和其他模块没关系，依赖关系单一。系统容易扩展和维护。</p><p>在指定业务逻辑也是一样，只需要参考抽象层的接口来业务就好了，抽象层暴露出来的接口就是我们业务层可以使用的方法，然后可以通过多态的线下，接口指针指向哪个实现模块，调用了就是具体的实现方法，这样我们业务逻辑层也是依赖抽象成编程。</p><p>我们就将这种的设计原则叫做 <u>依赖倒转原则</u></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ===== &gt;   抽象层  &lt; ========</span></span><br><span class="line"><span class="keyword">type</span> Car <span class="keyword">interface</span> &#123;</span><br><span class="line">Run()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Driver <span class="keyword">interface</span> &#123;</span><br><span class="line">Drive(car Car)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ===== &gt;   实现层  &lt; ========</span></span><br><span class="line"><span class="keyword">type</span> BenZ <span class="keyword">struct</span> &#123;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(benz * BenZ)</span></span> Run() &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;Benz is running...&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Bmw <span class="keyword">struct</span> &#123;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bmw * Bmw)</span></span> Run() &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;Bmw is running...&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Zhang_3 <span class="keyword">struct</span> &#123;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(zhang3 *Zhang_3)</span></span> Drive(car Car) &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;Zhang3 drive car&quot;</span>)</span><br><span class="line">car.Run()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Li_4 <span class="keyword">struct</span> &#123;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(li4 *Li_4)</span></span> Drive(car Car) &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;li4 drive car&quot;</span>)</span><br><span class="line">car.Run()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// ===== &gt;   业务逻辑层  &lt; ========</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">//张3 开 宝马</span></span><br><span class="line"><span class="keyword">var</span> bmw Car</span><br><span class="line">bmw = &amp;Bmw&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> zhang3 Driver</span><br><span class="line">zhang3 = &amp;Zhang_3&#123;&#125;</span><br><span class="line"></span><br><span class="line">zhang3.Drive(bmw)</span><br><span class="line"></span><br><span class="line"><span class="comment">//李4 开 奔驰</span></span><br><span class="line"><span class="keyword">var</span> benz Car</span><br><span class="line">benz = &amp;BenZ&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> li4 Driver</span><br><span class="line">li4 = &amp;Li_4&#123;&#125;</span><br><span class="line"></span><br><span class="line">li4.Drive(benz)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="合成复用原则"><a href="#合成复用原则" class="headerlink" title="合成复用原则"></a>合成复用原则</h3><p>如果使用继承，会导致父类的任何变换都可能影响到子类的行为。如果使用对象组合，就降低了这种依赖关系。对于继承和组合，优先使用组合。</p><h3 id="迪米特法则"><a href="#迪米特法则" class="headerlink" title="迪米特法则"></a>迪米特法则</h3><p>一个对象应当对其他对象尽可能少的了解，从而降低各个对象之间的耦合，提高系统的可维护性。</p><p>例如在一个程序中，各个模块之间相互调用时，通常会提供一个统一的接口来实现。这样其他模块不需要了解另外一个模块的内部实现细节，这样当一个模块内部的实现发生改变时，不会影响其他模块的使用。（黑盒原理）</p><h2 id="创建型模式"><a href="#创建型模式" class="headerlink" title="创建型模式"></a>创建型模式</h2><h3 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h3><h4 id="为什么需要工厂"><a href="#为什么需要工厂" class="headerlink" title="为什么需要工厂"></a>为什么需要工厂</h4><p>没有工厂模式，在开发者创建一个类的对象时，如果有很多不同种类的对象将会如何实现，代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//水果类</span></span><br><span class="line"><span class="keyword">type</span> Fruit <span class="keyword">struct</span> &#123;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *Fruit)</span></span> Show(name <span class="type">string</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> name == <span class="string">&quot;apple&quot;</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;我是苹果&quot;</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> name == <span class="string">&quot;banana&quot;</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;我是香蕉&quot;</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> name == <span class="string">&quot;pear&quot;</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;我是梨&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建一个Fruit对象</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewFruit</span><span class="params">(name <span class="type">string</span>)</span></span> *Fruit &#123;</span><br><span class="line">fruit := <span class="built_in">new</span>(Fruit)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> name == <span class="string">&quot;apple&quot;</span> &#123;</span><br><span class="line"><span class="comment">//创建apple逻辑</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> name == <span class="string">&quot;banana&quot;</span> &#123;</span><br><span class="line"><span class="comment">//创建banana逻辑</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> name == <span class="string">&quot;pear&quot;</span> &#123;</span><br><span class="line"><span class="comment">//创建pear逻辑</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> fruit</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">apple := NewFruit(<span class="string">&quot;apple&quot;</span>)</span><br><span class="line">apple.Show(<span class="string">&quot;apple&quot;</span>)</span><br><span class="line"></span><br><span class="line">banana := NewFruit(<span class="string">&quot;banana&quot;</span>)</span><br><span class="line">banana.Show(<span class="string">&quot;banana&quot;</span>)</span><br><span class="line"></span><br><span class="line">pear := NewFruit(<span class="string">&quot;pear&quot;</span>)</span><br><span class="line">pear.Show(<span class="string">&quot;pear&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>业务逻辑层 —&gt; 基础类模块</p><ul><li>在Fruit类中包含很多“if…else…”代码块，整个类的代码相当冗长，代码越长，阅读难度、维护难度和测试难度也越大；而且大量条件语句的存在还将影响系统的性能，程序在执行过程中需要做大量的条件判断</li><li>Fruit类的职责过重，它负责初始化和显示所有的水果对象，将各种水果对象的初始化代码和显示代码集中在一个类中实现，<u>违反了“单一职责原则”</u>，不利于类的重用和维护</li><li>当需要增加新类型的水果时，必须修改Fruit类的构造函数NewFruit()和其他相关方法源代码，<u>违反了“开闭原则”</u></li></ul><p>在中间加一层工厂模块层，来降低业务逻辑层对基础模块层的直接依赖和耦合关联。</p><p>业务逻辑层 —&gt; 工厂模块 —&gt; 基础类模块</p><h4 id="简单工厂模式角色和职责"><a href="#简单工厂模式角色和职责" class="headerlink" title="简单工厂模式角色和职责"></a>简单工厂模式角色和职责</h4><p>简单工厂模式并不属于GoF的23种设计模式。他是开发者自发认为的一种非常简易的设计模式，其角色和职责如下：</p><ul><li><strong>工厂</strong>：简单工厂模式的核心，它负责实现创建所有实例的内部逻辑。工厂类可以被外界直接调用，创建所需的产品对象。</li><li><strong>抽象产品</strong>：简单工厂模式所创建的所有对象的父类，它负责描述所有实例所共有的公共接口。</li><li><strong>具体产品</strong>：简单工厂模式所创建的具体实例对象。</li></ul><p><img                       lazyload                     alt="image"                     data-src="https://s2.loli.net/2023/01/31/gkuiEJanmBCRy78.png"                      alt="image-20230131172743146"                ></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ======= 抽象层 =========</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//水果类(抽象接口)</span></span><br><span class="line"><span class="keyword">type</span> Fruit <span class="keyword">interface</span> &#123;</span><br><span class="line">Show() <span class="comment">//接口的某方法</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ======= 基础类模块 =========</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Apple <span class="keyword">struct</span> &#123;</span><br><span class="line">Fruit  <span class="comment">//为了易于理解显示继承(此行可以省略)</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(apple *Apple)</span></span> Show() &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;我是苹果&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Banana <span class="keyword">struct</span> &#123;</span><br><span class="line">Fruit</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(banana *Banana)</span></span> Show() &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;我是香蕉&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Pear <span class="keyword">struct</span> &#123;</span><br><span class="line">Fruit</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pear *Pear)</span></span> Show() &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;我是梨&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ========= 工厂模块  =========</span></span><br><span class="line"><span class="comment">//一个工厂， 有一个生产水果的机器，返回一个抽象水果的指针</span></span><br><span class="line"><span class="keyword">type</span> Factory <span class="keyword">struct</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(fac *Factory)</span></span> CreateFruit(kind <span class="type">string</span>) Fruit &#123;</span><br><span class="line"><span class="keyword">var</span> fruit Fruit</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> kind == <span class="string">&quot;apple&quot;</span> &#123;</span><br><span class="line">fruit = <span class="built_in">new</span>(Apple)</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> kind == <span class="string">&quot;banana&quot;</span> &#123;</span><br><span class="line">fruit = <span class="built_in">new</span>(Banana)</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> kind == <span class="string">&quot;pear&quot;</span> &#123;</span><br><span class="line">fruit = <span class="built_in">new</span>(Pear)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> fruit</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// ==========业务逻辑层==============</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">factory := <span class="built_in">new</span>(Factory)</span><br><span class="line"></span><br><span class="line">apple := factory.CreateFruit(<span class="string">&quot;apple&quot;</span>)</span><br><span class="line">apple.Show()</span><br><span class="line"></span><br><span class="line">banana := factory.CreateFruit(<span class="string">&quot;banana&quot;</span>)</span><br><span class="line">banana.Show()</span><br><span class="line"></span><br><span class="line">pear := factory.CreateFruit(<span class="string">&quot;pear&quot;</span>)</span><br><span class="line">pear.Show()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h4><p>优点： </p><ul><li>实现了对象创建和使用的分离</li><li>不需要记住具体类名，记住参数即可，减少使用者记忆量。</li></ul><p>缺点：</p><ul><li>对工厂类职责过重，一旦不能工作，系统受到影响</li><li>增加系统中类的个数，复杂度和理解度增加</li><li>违反“开闭原则”，添加新产品需要修改工厂逻辑，工厂越来越复杂</li></ul><h4 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h4><ul><li>工厂类负责创建的对象比较少，由于创建的对象较少，不会造成工厂方法中的业务逻辑太过复杂</li><li>客户端只知道传入工厂类的参数，对于如何创建对象并不关心</li></ul><h3 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h3><h4 id="角色和职责"><a href="#角色和职责" class="headerlink" title="角色和职责"></a>角色和职责</h4><ul><li><strong>抽象工厂</strong>：工厂方法模式的核心，任何工厂类都必须实现这个接口。</li><li><strong>工厂</strong>：具体工厂类是抽象工厂的一个实现，负责实例化产品对象。</li><li><strong>抽象产品</strong>：工厂方法模式所创建的所有对象的父类，它负责描述所有实例所共有的公共接口。</li><li><strong>具体产品</strong>：工厂方法模式所创建的具体实例对象。</li></ul><p>简单工厂模式  + “开闭原则” &#x3D;    工厂方法模式</p><p><img                       lazyload                     alt="image"                     data-src="https://s2.loli.net/2023/01/31/D7kSYmexgt5XLEw.png"                      alt="image-20230131174849288"                ></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ======= 抽象层 =========</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//水果类(抽象接口)</span></span><br><span class="line"><span class="keyword">type</span> Fruit <span class="keyword">interface</span> &#123;</span><br><span class="line">Show() <span class="comment">//接口的某方法</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//工厂类(抽象接口)</span></span><br><span class="line"><span class="keyword">type</span> AbstractFactory <span class="keyword">interface</span> &#123;</span><br><span class="line">CreateFruit() Fruit <span class="comment">//生产水果类(抽象)的生产器方法</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ======= 基础类模块 =========</span></span><br><span class="line"><span class="keyword">type</span> Apple <span class="keyword">struct</span> &#123;</span><br><span class="line">Fruit  <span class="comment">//为了易于理解显示继承(此行可以省略)</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(apple *Apple)</span></span> Show() &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;我是苹果&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Banana <span class="keyword">struct</span> &#123;</span><br><span class="line">Fruit</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(banana *Banana)</span></span> Show() &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;我是香蕉&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Pear <span class="keyword">struct</span> &#123;</span><br><span class="line">Fruit</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pear *Pear)</span></span> Show() &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;我是梨&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//(+) 新增一个&quot;日本苹果&quot;</span></span><br><span class="line"><span class="keyword">type</span> JapanApple <span class="keyword">struct</span> &#123;</span><br><span class="line">Fruit</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(jp *JapanApple)</span></span> Show() &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;我是日本苹果&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ========= 工厂模块  =========</span></span><br><span class="line"><span class="comment">//具体的苹果工厂</span></span><br><span class="line"><span class="keyword">type</span> AppleFactory <span class="keyword">struct</span> &#123;</span><br><span class="line">AbstractFactory</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(fac *AppleFactory)</span></span> CreateFruit() Fruit &#123;</span><br><span class="line"><span class="keyword">var</span> fruit Fruit</span><br><span class="line"></span><br><span class="line"><span class="comment">//生产一个具体的苹果</span></span><br><span class="line">fruit = <span class="built_in">new</span>(Apple)</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> fruit</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//具体的香蕉工厂</span></span><br><span class="line"><span class="keyword">type</span> BananaFactory <span class="keyword">struct</span> &#123;</span><br><span class="line">AbstractFactory</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(fac *BananaFactory)</span></span> CreateFruit() Fruit &#123;</span><br><span class="line"><span class="keyword">var</span> fruit Fruit</span><br><span class="line"></span><br><span class="line"><span class="comment">//生产一个具体的香蕉</span></span><br><span class="line">fruit = <span class="built_in">new</span>(Banana)</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> fruit</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//具体的梨工厂</span></span><br><span class="line"><span class="keyword">type</span> PearFactory <span class="keyword">struct</span> &#123;</span><br><span class="line">AbstractFactory</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(fac *PearFactory)</span></span> CreateFruit() Fruit &#123;</span><br><span class="line"><span class="keyword">var</span> fruit Fruit</span><br><span class="line"></span><br><span class="line"><span class="comment">//生产一个具体的梨</span></span><br><span class="line">fruit = <span class="built_in">new</span>(Pear)</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> fruit</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//具体的日本工厂</span></span><br><span class="line"><span class="keyword">type</span> JapanAppleFactory <span class="keyword">struct</span> &#123;</span><br><span class="line">AbstractFactory</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(fac *JapanAppleFactory)</span></span> CreateFruit() Fruit &#123;</span><br><span class="line"><span class="keyword">var</span> fruit Fruit</span><br><span class="line"></span><br><span class="line"><span class="comment">//生产一个具体的日本苹果</span></span><br><span class="line">fruit = <span class="built_in">new</span>(JapanApple)</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> fruit</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ========= 业务逻辑层  =========</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">本案例为了突出根据依赖倒转原则与面向接口编程特性。</span></span><br><span class="line"><span class="comment">    一些变量的定义将使用显示类型声明方式</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//需求1：需要一个具体的苹果对象</span></span><br><span class="line"><span class="comment">//1-先要一个具体的苹果工厂</span></span><br><span class="line"><span class="keyword">var</span> appleFac AbstractFactory</span><br><span class="line">appleFac = <span class="built_in">new</span>(AppleFactory)</span><br><span class="line"><span class="comment">//2-生产相对应的具体水果</span></span><br><span class="line"><span class="keyword">var</span> apple Fruit</span><br><span class="line">apple = appleFac.CreateFruit()</span><br><span class="line"></span><br><span class="line">apple.Show()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//需求2：需要一个具体的香蕉对象</span></span><br><span class="line"><span class="comment">//1-先要一个具体的香蕉工厂</span></span><br><span class="line"><span class="keyword">var</span> bananaFac AbstractFactory</span><br><span class="line">bananaFac = <span class="built_in">new</span>(BananaFactory)</span><br><span class="line"><span class="comment">//2-生产相对应的具体水果</span></span><br><span class="line"><span class="keyword">var</span> banana Fruit</span><br><span class="line">banana = bananaFac.CreateFruit()</span><br><span class="line"></span><br><span class="line">banana.Show()</span><br><span class="line"></span><br><span class="line"><span class="comment">//需求3：需要一个具体的梨对象</span></span><br><span class="line"><span class="comment">//1-先要一个具体的梨工厂</span></span><br><span class="line"><span class="keyword">var</span> pearFac AbstractFactory</span><br><span class="line">pearFac = <span class="built_in">new</span>(PearFactory)</span><br><span class="line"><span class="comment">//2-生产相对应的具体水果</span></span><br><span class="line"><span class="keyword">var</span> pear Fruit</span><br><span class="line">pear = pearFac.CreateFruit()</span><br><span class="line"></span><br><span class="line">pear.Show()</span><br><span class="line"></span><br><span class="line"><span class="comment">//需求4：需要一个日本的苹果？</span></span><br><span class="line"><span class="comment">//1-先要一个具体的日本评估工厂</span></span><br><span class="line"><span class="keyword">var</span> japanAppleFac AbstractFactory</span><br><span class="line">japanAppleFac = <span class="built_in">new</span>(JapanAppleFactory)</span><br><span class="line"><span class="comment">//2-生产相对应的具体水果</span></span><br><span class="line"><span class="keyword">var</span> japanApple Fruit</span><br><span class="line">japanApple = japanAppleFac.CreateFruit()</span><br><span class="line"></span><br><span class="line">japanApple.Show()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="优缺点-1"><a href="#优缺点-1" class="headerlink" title="优缺点"></a>优缺点</h4><p>优点： </p><ol><li>不需要记住具体类名，甚至连具体参数都不用记忆</li><li>实现了对象创建和使用的分离</li><li>系统的可扩展性也就变得非常好，无需修改接口和原类</li><li>对于新产品的创建，符合开闭原则</li></ol><p>缺点：</p><ol><li>增加系统中类的个数，复杂度和理解度增加</li><li>增加了系统的抽象性和理解难度</li></ol><h4 id="适用场景-1"><a href="#适用场景-1" class="headerlink" title="适用场景"></a>适用场景</h4><ol><li>客户端不知道它所需要的对象的类</li><li>抽象工厂类通过其子类来指定创建哪个对象</li></ol><h3 id="抽象工厂方法模式"><a href="#抽象工厂方法模式" class="headerlink" title="抽象工厂方法模式"></a>抽象工厂方法模式</h3><p>工厂方法模式通过引入工厂等级结构，解决了简单工厂模式中工厂类职责太重的问题，但由于工厂方法模式中的每个工厂只生产一类产品，可能会导致系统中存在大量的工厂类，势必会增加系统的开销。</p><p>因此，可以考虑将一些相关的产品组成一个“产品族”，由同一个工厂来统一生产，这就是本文将要学习的抽象工厂模式的基本思想。</p><p>“抽象工厂方法模式”引出了“产品族”和“产品等级结构”概念，其目的是为了更加高效的生产同一个产品组产品</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ======= 抽象层 =========</span></span><br><span class="line"><span class="keyword">type</span> AbstractApple <span class="keyword">interface</span> &#123;</span><br><span class="line">ShowApple()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> AbstractBanana <span class="keyword">interface</span> &#123;</span><br><span class="line">ShowBanana()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> AbstractPear <span class="keyword">interface</span> &#123;</span><br><span class="line">ShowPear()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//抽象工厂</span></span><br><span class="line"><span class="keyword">type</span> AbstractFactory <span class="keyword">interface</span> &#123;</span><br><span class="line">CreateApple() AbstractApple</span><br><span class="line">CreateBanana() AbstractBanana</span><br><span class="line">CreatePear() AbstractPear</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ======== 实现层 =========</span></span><br><span class="line"><span class="comment">/*  中国产品族 */</span></span><br><span class="line"><span class="keyword">type</span> ChinaApple <span class="keyword">struct</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ca *ChinaApple)</span></span> ShowApple() &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;中国苹果&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> ChinaBanana <span class="keyword">struct</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(cb *ChinaBanana)</span></span> ShowBanana() &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;中国香蕉&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> ChinaPear <span class="keyword">struct</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(cp *ChinaPear)</span></span> ShowPear() &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;中国梨&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> ChinaFactory <span class="keyword">struct</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(cf *ChinaFactory)</span></span> CreateApple() AbstractApple &#123;</span><br><span class="line"><span class="keyword">var</span> apple AbstractApple</span><br><span class="line"></span><br><span class="line">apple = <span class="built_in">new</span>(ChinaApple)</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> apple</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(cf *ChinaFactory)</span></span> CreateBanana() AbstractBanana &#123;</span><br><span class="line"><span class="keyword">var</span> banana AbstractBanana</span><br><span class="line"></span><br><span class="line">banana = <span class="built_in">new</span>(ChinaBanana)</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> banana</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(cf *ChinaFactory)</span></span> CreatePear() AbstractPear &#123;</span><br><span class="line"><span class="keyword">var</span> pear AbstractPear</span><br><span class="line"></span><br><span class="line">pear = <span class="built_in">new</span>(ChinaPear)</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> pear</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*  日本产品族 */</span></span><br><span class="line"><span class="keyword">type</span> JapanApple <span class="keyword">struct</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ja *JapanApple)</span></span> ShowApple() &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;日本苹果&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> JapanBanana <span class="keyword">struct</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(jb *JapanBanana)</span></span> ShowBanana() &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;日本香蕉&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> JapanPear <span class="keyword">struct</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(cp *JapanPear)</span></span> ShowPear() &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;日本梨&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> JapanFactory <span class="keyword">struct</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(jf *JapanFactory)</span></span> CreateApple() AbstractApple &#123;</span><br><span class="line"><span class="keyword">var</span> apple AbstractApple</span><br><span class="line"></span><br><span class="line">apple = <span class="built_in">new</span>(JapanApple)</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> apple</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(jf *JapanFactory)</span></span> CreateBanana() AbstractBanana &#123;</span><br><span class="line"><span class="keyword">var</span> banana AbstractBanana</span><br><span class="line"></span><br><span class="line">banana = <span class="built_in">new</span>(JapanBanana)</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> banana</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(cf *JapanFactory)</span></span> CreatePear() AbstractPear &#123;</span><br><span class="line"><span class="keyword">var</span> pear AbstractPear</span><br><span class="line"></span><br><span class="line">pear = <span class="built_in">new</span>(JapanPear)</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> pear</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*  美国产品族 */</span></span><br><span class="line"><span class="keyword">type</span> AmericanApple <span class="keyword">struct</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(aa *AmericanApple)</span></span> ShowApple() &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;美国苹果&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> AmericanBanana <span class="keyword">struct</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ab *AmericanBanana)</span></span> ShowBanana() &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;美国香蕉&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> AmericanPear <span class="keyword">struct</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ap *AmericanPear)</span></span> ShowPear() &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;美国梨&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> AmericanFactory <span class="keyword">struct</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(af *AmericanFactory)</span></span> CreateApple() AbstractApple &#123;</span><br><span class="line"><span class="keyword">var</span> apple AbstractApple</span><br><span class="line"></span><br><span class="line">apple = <span class="built_in">new</span>(AmericanApple)</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> apple</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(af *AmericanFactory)</span></span> CreateBanana() AbstractBanana &#123;</span><br><span class="line"><span class="keyword">var</span> banana AbstractBanana</span><br><span class="line"></span><br><span class="line">banana = <span class="built_in">new</span>(AmericanBanana)</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> banana</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(af *AmericanFactory)</span></span> CreatePear() AbstractPear &#123;</span><br><span class="line"><span class="keyword">var</span> pear AbstractPear</span><br><span class="line"></span><br><span class="line">pear = <span class="built_in">new</span>(AmericanPear)</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> pear</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ======== 业务逻辑层 =======</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">//需求1: 需要美国的苹果、香蕉、梨 等对象</span></span><br><span class="line"><span class="comment">//1-创建一个美国工厂</span></span><br><span class="line"><span class="keyword">var</span> aFac AbstractFactory</span><br><span class="line">aFac = <span class="built_in">new</span>(AmericanFactory)</span><br><span class="line"></span><br><span class="line"><span class="comment">//2-生产美国苹果</span></span><br><span class="line"><span class="keyword">var</span> aApple AbstractApple</span><br><span class="line">aApple = aFac.CreateApple()</span><br><span class="line">aApple.ShowApple()</span><br><span class="line"></span><br><span class="line"><span class="comment">//3-生产美国香蕉</span></span><br><span class="line"><span class="keyword">var</span> aBanana AbstractBanana</span><br><span class="line">aBanana = aFac.CreateBanana()</span><br><span class="line">aBanana.ShowBanana()</span><br><span class="line"></span><br><span class="line"><span class="comment">//4-生产美国梨</span></span><br><span class="line"><span class="keyword">var</span> aPear AbstractPear</span><br><span class="line">aPear = aFac.CreatePear()</span><br><span class="line">aPear.ShowPear()</span><br><span class="line"></span><br><span class="line"><span class="comment">//需求2: 需要中国的苹果、香蕉</span></span><br><span class="line"><span class="comment">//1-创建一个中国工厂</span></span><br><span class="line">cFac := <span class="built_in">new</span>(ChinaFactory)</span><br><span class="line"></span><br><span class="line"><span class="comment">//2-生产中国苹果</span></span><br><span class="line">cApple := cFac.CreateApple()</span><br><span class="line">cApple.ShowApple()</span><br><span class="line"></span><br><span class="line"><span class="comment">//3-生产中国香蕉</span></span><br><span class="line">cBanana := cFac.CreateBanana()</span><br><span class="line">cBanana.ShowBanana()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="优缺点-2"><a href="#优缺点-2" class="headerlink" title="优缺点"></a>优缺点</h4><p>优点：</p><ul><li>拥有工厂方法模式的优点</li><li>当一个产品族中的多个对象被设计成一起工作时，它能够保证客户端始终只使用同一个产品族中的对象</li><li>增加新的产品族很方便，无须修改已有系统，符合“开闭原则”</li></ul><p>缺点：</p><ul><li>增加新的产品等级结构麻烦，需要对原有系统进行较大的修改，甚至需要修改抽象层代码，这显然会带来较大的不便，违背了“开闭原则”</li></ul><h4 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h4><ul><li>系统中有多于一个的产品族。而每次只使用其中某一产品族。可以通过配置文件等方式来使得用户可以动态改变产品族，也可以很方便地增加新的产品族</li><li>产品等级结构稳定。设计完成之后，不会向系统中增加新的产品等级结构或者删除已有的产品等级结构</li></ul><p>类似的实现有：</p><blockquote><p>设计一个电脑主板架构，电脑包括（显卡，内存，CPU）3个固定的插口，显卡具有显示功能（display，功能实现只要打印出意义即可），内存具有存储功能（storage），cpu具有计算功能（calculate）。<br>    现有Intel厂商，nvidia厂商，Kingston厂商，均会生产以上三种硬件。<br>    要求组装两台电脑，<br>                1台（Intel的CPU，Intel的显卡，Intel的内存）<br>                1台（Intel的CPU， nvidia的显卡，Kingston的内存）<br>    用抽象工厂模式实现。</p></blockquote><h3 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h3><p>保证一个类永远只能有一个对象，且该对象的功能依然能被其他模块使用。</p><p>分为恶汉式、懒汉式</p><p>恶汉式</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">三个要点：</span></span><br><span class="line"><span class="comment">一是某个类只能有一个实例；</span></span><br><span class="line"><span class="comment">二是它必须自行创建这个实例；</span></span><br><span class="line"><span class="comment">三是它必须自行向整个系统提供这个实例。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">保证一个类永远只能有一个对象</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//1、保证这个类非公有化，外界不能通过这个类直接创建一个对象</span></span><br><span class="line"><span class="comment">//   那么这个类就应该变得非公有访问 类名称首字母要小写</span></span><br><span class="line"><span class="keyword">type</span> singelton <span class="keyword">struct</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2、但是还要有一个指针可以指向这个唯一对象，但是这个指针永远不能改变方向</span></span><br><span class="line"><span class="comment">//   Golang中没有常指针概念，所以只能通过将这个指针私有化不让外部模块访问</span></span><br><span class="line"><span class="keyword">var</span> instance *singelton = <span class="built_in">new</span>(singelton)</span><br><span class="line"></span><br><span class="line"><span class="comment">//3、如果全部为私有化，那么外部模块将永远无法访问到这个类和对象，</span></span><br><span class="line"><span class="comment">//   所以需要对外提供一个方法来获取这个唯一实例对象</span></span><br><span class="line"><span class="comment">//   注意：这个方法是否可以定义为singelton的一个成员方法呢？</span></span><br><span class="line"><span class="comment">//       答案是不能，因为如果为成员方法就必须要先访问对象、再访问函数</span></span><br><span class="line"><span class="comment">//        但是类和对象目前都已经私有化，外界无法访问，所以这个方法一定是一个全局普通函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetInstance</span><span class="params">()</span></span> *singelton &#123;</span><br><span class="line"><span class="keyword">return</span> instance</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *singelton)</span></span> SomeThing() &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;单例对象的某方法&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 以本包下的main访问举例，实际上别的包也可以调用</span></span><br><span class="line">s := GetInstance()</span><br><span class="line">s.SomeThing()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>sync.once</code>实现懒汉式的代码</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;sync&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> once sync.Once</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> singelton <span class="keyword">struct</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> instance *singelton</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetInstance</span><span class="params">()</span></span> *singelton &#123;</span><br><span class="line"></span><br><span class="line">once.Do(<span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">instance = <span class="built_in">new</span>(singelton)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> instance</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *singelton)</span></span> SomeThing() &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;单例对象的某方法&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">s := GetInstance()</span><br><span class="line">s.SomeThing()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="优缺点-3"><a href="#优缺点-3" class="headerlink" title="优缺点"></a>优缺点</h4><p>优点：</p><ul><li>单例模式提供了对唯一实例的受控访问</li><li>节约系统资源（在系统内存中只存在一个对象）</li></ul><p>缺点：</p><ul><li>扩展略难（单例模式中没有抽象层）</li><li>单例类的职责过重</li></ul><h4 id="适用场景-2"><a href="#适用场景-2" class="headerlink" title="适用场景"></a>适用场景</h4><ul><li>系统只需要一个实例对象，如系统要求提供一个唯一的序列号生成器或资源管理器，或者需要考虑资源消耗太大而只允许创建一个对象</li><li>客户调用类的单个实例只允许使用一个公共访问点，除了该公共访问点，不能通过其他途径访问该实例</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;整理自刘丹冰老师的&lt;a class=&quot;link&quot;   href=&quot;https://www.yuque.com/aceld/lfhu8y&quot; &gt;</summary>
      
    
    
    
    
    <category term="go" scheme="https://tbghg.github.io/tags/go/"/>
    
    <category term="设计模式" scheme="https://tbghg.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>背包做题笔记</title>
    <link href="https://tbghg.github.io/2023-01-13/523525298d6a/"/>
    <id>https://tbghg.github.io/2023-01-13/523525298d6a/</id>
    <published>2023-01-13T13:43:13.000Z</published>
    <updated>2023-01-13T13:43:13.000Z</updated>
    
    <content type="html"><![CDATA[<p>你的背包~🎵</p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这个是刷代码随想录的做题笔记，分析部分大多是我自己的理解，代码我用go写的，现在回头再看一遍还是觉得代码随想录总结的很棒，强推一波！</p><h2 id="背包概括"><a href="#背包概括" class="headerlink" title="背包概括"></a>背包概括</h2><p><img                       lazyload                     alt="image"                     data-src="https://s2.loli.net/2023/01/13/3YInUimcOks7N5w.png"                      alt="416.分割等和子集1"                ></p><p>面试的话，其实掌握 01背包 完全背包，就够用了，leetcode上连多重背包的题目都没有</p><p>完全背包又是也是01背包稍作变化而来，即：完全背包的物品数量是无限的。01背包是基础，需要重点掌握。</p><h2 id="01背包"><a href="#01背包" class="headerlink" title="01背包"></a>01背包</h2><h3 id="01背包初介绍"><a href="#01背包初介绍" class="headerlink" title="01背包初介绍"></a>01背包初介绍</h3><p>有n件物品和一个最多能背重量为w的背包。第i件物品的重量是weight[i]，得到的价值是value[i] 。<strong>每件物品只能用一次</strong>，求解将哪些物品装入背包里物品价值总和最大。</p><p>先从暴力的角度来看，通过回溯实现暴力，每一件物品其实只有两个状态，取或者不取，所以可以使用回溯法搜索出所有的情况，那么时间复杂度就是o(2^n)，这里的n表示物品数量。</p><p>所以暴力的解法是指数级别的时间复杂度。进而才需要动态规划的解法来进行优化</p><h3 id="入门例题"><a href="#入门例题" class="headerlink" title="入门例题"></a>入门例题</h3><p>背包最大重量为4，物品为：</p><table><thead><tr><th></th><th>重量</th><th>价值</th></tr></thead><tbody><tr><td>物品0</td><td>1</td><td>15</td></tr><tr><td>物品1</td><td>3</td><td>20</td></tr><tr><td>物品2</td><td>4</td><td>30</td></tr></tbody></table><p>问背包能背的物品最大价值是多少？</p><h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><p><strong>动规五部曲</strong></p><ol><li>确定dp数组以及下标的含义</li></ol><p>对于背包问题，有一种写法， 是使用二维数组，即<strong>dp[i][j] 表示从下标为[0-i]的物品里任意取，放进容量为j的背包，价值总和最大是多少</strong></p><table><thead><tr><th></th><th>0</th><th>1</th><th>2</th><th>3</th><th>4</th></tr></thead><tbody><tr><td>物品0</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>物品1</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>物品2</td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table><ol start="2"><li>确定递推公式</li></ol><p>再回顾一下dp[i][j]的含义：从下标为[0-i]的物品里任意取，放进容量为j的背包，价值总和最大是多少</p><p>那么可以有两个方向推出来dp[i][j]：</p><ul><li><strong>不放物品i</strong>：由dp[i - 1][j]推出，即背包容量为j，里面不放物品i的最大价值，此时dp[i][j]就是dp[i - 1][j]。(其实就是当物品i的重量大于背包j的重量时，物品i无法放进背包中，所以被背包内的价值依然和前面相同)</li><li><strong>放物品i</strong>：由dp[i - 1][j - weight[i]]推出，dp[i - 1][j - weight[i]] 为背包容量为j - weight[i]的时候不放物品i的最大价值，那么dp[i - 1][j - weight[i]] + value[i] （物品i的价值），就是背包放物品i得到的最大价值</li></ul><p>所以递归公式： <code>dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i])</code></p><ol start="3"><li>dp数组如何初始化</li></ol><p>首先从dp[i][j]的定义出发，如果背包容量j为0的话，即dp[i][0]，无论是选取哪些物品，背包价值总和一定为0。</p><table><thead><tr><th></th><th>0</th><th>1</th><th>2</th><th>3</th><th>4</th></tr></thead><tbody><tr><td>物品0</td><td>0</td><td></td><td></td><td></td><td></td></tr><tr><td>物品1</td><td>0</td><td></td><td></td><td></td><td></td></tr><tr><td>物品2</td><td>0</td><td></td><td></td><td></td><td></td></tr></tbody></table><p>状态转移方程 <code>dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i])</code> 可以看出i 是由 i-1 推导出来，那么i为0的时候就一定要初始化</p><p>dp[0][j]，即：i为0，存放编号0的物品的时候，各个容量的背包所能存放的最大价值</p><table><thead><tr><th></th><th>0</th><th>1</th><th>2</th><th>3</th><th>4</th></tr></thead><tbody><tr><td>物品0</td><td>0</td><td>15</td><td>15</td><td>15</td><td>15</td></tr><tr><td>物品1</td><td>0</td><td></td><td></td><td></td><td></td></tr><tr><td>物品2</td><td>0</td><td></td><td></td><td></td><td></td></tr></tbody></table><p>首先j&#x3D;0(容量为0)这里是可以初始值不用管的，并且根据遍历顺序来说也是不用管，这个后面会看到</p><p>初始化的代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">weight := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line">value := []<span class="type">int</span>&#123;<span class="number">15</span>, <span class="number">20</span>, <span class="number">30</span>&#125;</span><br><span class="line">bigWeight := <span class="number">4</span></span><br><span class="line">dp := <span class="built_in">make</span>([][]<span class="type">int</span>, <span class="built_in">len</span>(weight))</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(weight); i++ &#123;</span><br><span class="line"><span class="comment">// 因为容量包含0，所以要+1</span></span><br><span class="line">dp[i] = <span class="built_in">make</span>([]<span class="type">int</span>, bigWeight+<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 这里直接从weight[0]起步，前面的肯定是0</span></span><br><span class="line"><span class="keyword">for</span> j := weight[<span class="number">0</span>]; j &lt;= bigWeight; j++ &#123;</span><br><span class="line">dp[<span class="number">0</span>][j] = value[<span class="number">0</span>]</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(dp)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// output:[[0 15 15 15 15] [0 0 0 0 0] [0 0 0 0 0]]</span></span><br></pre></td></tr></table></figure><ol start="4"><li>确定遍历顺序</li></ol><p>01背包遍历顺序两种都行，<strong>但是先遍历物品更好理解</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 遍历物品</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">1</span>; i &lt; <span class="built_in">len</span>(weight); i++ &#123;</span><br><span class="line">    <span class="comment">// 遍历容量</span></span><br><span class="line">    <span class="keyword">for</span> j := <span class="number">0</span>; j &lt;= bagWeight; j++ &#123;</span><br><span class="line">        <span class="keyword">if</span> j &lt; weight[i] &#123;</span><br><span class="line">            dp[i][j] = dp[i<span class="number">-1</span>][j]</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            dp[i][j] = max(dp[i<span class="number">-1</span>][j], dp[i<span class="number">-1</span>][j-weight[i]]+value[i])</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(dp)</span><br><span class="line"><span class="comment">//output:[[0 15 15 15 15] [0 15 15 20 35] [0 15 15 20 35]]</span></span><br></pre></td></tr></table></figure><h4 id="滚动数组空间优化"><a href="#滚动数组空间优化" class="headerlink" title="滚动数组空间优化"></a>滚动数组空间优化</h4><p>dp[i][j] 表示从下标为[0-i]的物品里任意取，放进容量为j的背包，价值总和最大是多少</p><p>一维数组：dp[j]表示：容量为j的背包，所背的物品价值可以最大为dp[j]</p><p><strong>动规五部曲</strong></p><ol><li>确定dp数组的定义</li></ol><p>在一维dp数组中，dp[j]表示：容量为j的背包，所背的物品价值可以最大为dp[j]</p><ol start="2"><li>dp数组的递推公式</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[j] = max(dp[j], dp[j - weight[i]] + value[i])</span><br></pre></td></tr></table></figure><ol start="3"><li>dp数组初始化</li></ol><p>dp[0]&#x3D;0，其他情况下可以通过dp[0]直接横着推过来</p><ol start="4"><li><strong>遍历顺序</strong></li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">weight := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line">value := []<span class="type">int</span>&#123;<span class="number">15</span>, <span class="number">20</span>, <span class="number">30</span>&#125;</span><br><span class="line">bagWeight := <span class="number">4</span></span><br><span class="line"><span class="comment">// 因为容量包含0，所以要+1</span></span><br><span class="line">dp := <span class="built_in">make</span>([]<span class="type">int</span>, bagWeight+<span class="number">1</span>)</span><br><span class="line"><span class="comment">// 遍历物品</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(weight); i++ &#123;</span><br><span class="line"><span class="comment">// 遍历容量</span></span><br><span class="line"><span class="keyword">for</span> j := bagWeight; j &gt;= weight[i]; j-- &#123;</span><br><span class="line">dp[j] = max(dp[j], dp[j-weight[i]]+value[i])</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(dp)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//output:[0 15 15 20 35]</span></span><br></pre></td></tr></table></figure><p>这块是重点，注意：<strong>必须先遍历物品再遍历背包</strong>；<strong>必须倒序遍历</strong></p><p>先遍历物品再遍历背包：因为一维dp的写法，背包容量一定是要倒序遍历，如果遍历背包容量放在上一层，那么每个dp[j]就只会放入一个物品，即：背包里只放入了一个物品（举个例子自己走一遍就差不多理解了）</p><p>倒顺遍历：无法知道物品装了没装，容易装多次，倒着来的话本容量下前面的肯定没装该物品，因为还没遍历到</p><h3 id="分割等和子集"><a href="#分割等和子集" class="headerlink" title="分割等和子集"></a>分割等和子集</h3><p><a class="link"   href="https://leetcode.cn/problems/partition-equal-subset-sum/" >题目链接<i class="fas fa-external-link-alt"></i></a></p><p>给你一个 <strong>只包含正整数</strong> 的 <strong>非空</strong> 数组 <code>nums</code> 。请你判断是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1,5,11,5]</span><br><span class="line">输出：true</span><br><span class="line">解释：数组可以分割成 [1, 5, 5] 和 [11] 。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1,2,3,5]</span><br><span class="line">输出：false</span><br><span class="line">解释：数组不能分割成两个元素和相等的子集。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 200</code></li><li><code>1 &lt;= nums[i] &lt;= 100</code></li></ul><h4 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h4><p><code>[1,5,11,5]</code>为例，和为22，相当于一个11的背包看看最多可以装多少个，如果小于11输出false，等于11输出true，一道简单的01背包问题</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">canPartition</span><span class="params">(nums []<span class="type">int</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line"><span class="keyword">var</span> sum <span class="type">int</span></span><br><span class="line"><span class="keyword">for</span> _, v := <span class="keyword">range</span> nums &#123;</span><br><span class="line">sum += v</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> sum%<span class="number">2</span> != <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line">sum /= <span class="number">2</span></span><br><span class="line">dp := <span class="built_in">make</span>([]<span class="type">int</span>, sum+<span class="number">1</span>)</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(nums); i++ &#123;</span><br><span class="line"><span class="keyword">for</span> j := sum; j &gt;= nums[i]; j-- &#123;</span><br><span class="line">dp[j] = max(dp[j], dp[j-nums[i]]+nums[i])</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> dp[sum] == sum</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">max</span><span class="params">(a, b <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line"><span class="keyword">if</span> a &gt; b &#123;</span><br><span class="line"><span class="keyword">return</span> a</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="最后一块石头的重量-II"><a href="#最后一块石头的重量-II" class="headerlink" title="最后一块石头的重量 II"></a>最后一块石头的重量 II</h3><p><a class="link"   href="https://leetcode.cn/problems/last-stone-weight-ii/" >题目链接<i class="fas fa-external-link-alt"></i></a></p><p>有一堆石头，用整数数组 <code>stones</code> 表示。其中 <code>stones[i]</code> 表示第 <code>i</code> 块石头的重量。</p><p>每一回合，从中选出<strong>任意两块石头</strong>，然后将它们一起粉碎。假设石头的重量分别为 <code>x</code> 和 <code>y</code>，且 <code>x &lt;= y</code>。那么粉碎的可能结果如下：</p><ul><li>如果 <code>x == y</code>，那么两块石头都会被完全粉碎；</li><li>如果 <code>x != y</code>，那么重量为 <code>x</code> 的石头将会完全粉碎，而重量为 <code>y</code> 的石头新重量为 <code>y-x</code>。</li></ul><p>最后，<strong>最多只会剩下一块</strong> 石头。返回此石头 <strong>最小的可能重量</strong> 。如果没有石头剩下，就返回 <code>0</code></p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：stones = [2,7,4,1,8,1]</span><br><span class="line">输出：1</span><br><span class="line">解释：</span><br><span class="line">组合 2 和 4，得到 2，所以数组转化为 [2,7,1,8,1]，</span><br><span class="line">组合 7 和 8，得到 1，所以数组转化为 [2,1,1,1]，</span><br><span class="line">组合 2 和 1，得到 1，所以数组转化为 [1,1,1]，</span><br><span class="line">组合 1 和 1，得到 0，所以数组转化为 [1]，这就是最优值。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：stones = [31,26,33,21,40]</span><br><span class="line">输出：5</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= stones.length &lt;= 30</code></li><li><code>1 &lt;= stones[i] &lt;= 100</code></li></ul><h4 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h4><p>乍一看一脸懵逼，仔细想想的话反正一个是加数一个是减数，分成两拨来碰，和上面那道题好像一样：一组数，分两拨，两拨之间差值如何最小，输出即可，那也就相当于一组数，sum&#x2F;2为容量，看看最大是多少，最后输出sum&#x2F;2-该数</p><p>但是需要考虑sum%2为1的情况，以sum&#x3D;9为例，肯定有一波小于等于4，一波小于等于5，不管是哪一波，一个向中间聚拢，另一个也是，所以背包容量取哪个都没影响。我们可以直接向下取整，因为sum&#x2F;2就是，并且容量小的话for层数也少。</p><p>因为背包容量算出来的是小于等于sum&#x2F;2的，并且还有可能向下取整，所以最后结果为<code>sum-dp[bagWeight] - dp[bagWeight]</code></p><h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">lastStoneWeightII</span><span class="params">(stones []<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line"><span class="keyword">var</span> sum <span class="type">int</span></span><br><span class="line"><span class="keyword">for</span> _, stone := <span class="keyword">range</span> stones &#123;</span><br><span class="line">sum += stone</span><br><span class="line">&#125;</span><br><span class="line">bagWeight := sum / <span class="number">2</span></span><br><span class="line">dp := <span class="built_in">make</span>([]<span class="type">int</span>, bagWeight+<span class="number">1</span>)</span><br><span class="line"><span class="comment">// 遍历物品</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(stones); i++ &#123;</span><br><span class="line"><span class="comment">// 遍历容量</span></span><br><span class="line"><span class="keyword">for</span> j := bagWeight; j &gt;= stones[i]; j-- &#123;</span><br><span class="line">dp[j] = max(dp[j], dp[j-stones[i]]+stones[i])</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> sum - dp[bagWeight]*<span class="number">2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="目标和"><a href="#目标和" class="headerlink" title="目标和"></a>目标和</h3><p>给你一个整数数组 <code>nums</code> 和一个整数 <code>target</code> 。</p><p>向数组中的每个整数前添加 <code>&#39;+&#39;</code> 或 <code>&#39;-&#39;</code> ，然后串联起所有整数，可以构造一个 <strong>表达式</strong> ：</p><ul><li>例如，<code>nums = [2, 1]</code> ，可以在 <code>2</code> 之前添加 <code>&#39;+&#39;</code> ，在 <code>1</code> 之前添加 <code>&#39;-&#39;</code> ，然后串联起来得到表达式 <code>&quot;+2-1&quot;</code></li></ul><p>返回可以通过上述方法构造的、运算结果等于 <code>target</code> 的不同 <strong>表达式</strong> 的数目。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1,1,1,1,1], target = 3</span><br><span class="line">输出：5</span><br><span class="line">解释：一共有 5 种方法让最终目标和为 3 。</span><br><span class="line">-1 + 1 + 1 + 1 + 1 = 3</span><br><span class="line">+1 - 1 + 1 + 1 + 1 = 3</span><br><span class="line">+1 + 1 - 1 + 1 + 1 = 3</span><br><span class="line">+1 + 1 + 1 - 1 + 1 = 3</span><br><span class="line">+1 + 1 + 1 + 1 - 1 = 3</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1], target = 1</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 20</code></li><li><code>0 &lt;= nums[i] &lt;= 1000</code></li><li><code>0 &lt;= sum(nums[i]) &lt;= 1000</code></li><li><code>-1000 &lt;= target &lt;= 1000</code></li></ul><h4 id="分析-3"><a href="#分析-3" class="headerlink" title="分析"></a>分析</h4><p>这道题比较难想，但是有过这一次之后以后同类型的会好很多。</p><p>加号的分为一波，减号的分为一波，假设加法的总和为x，那么减法对应的总和就是sum - x。所以我们要求的是 x - (sum - x) &#x3D; target，x &#x3D; (target + sum) &#x2F; 2</p><p><strong>此时问题就转化为，装满容量为x的背包，有几种方法</strong></p><p>bagSize就是(target + sum) &#x2F; 2 ，如果这个数不能整除，那就不可能凑不来方法，<code>return 0</code>即可</p><p>这次和之前遇到的背包问题不一样了，之前都是求容量为j的背包，最多能装多少。本题则是装满有几种方法。其实这就是一个<strong>组合问题</strong>了</p><ol><li>确定dp数组以及下标的含义</li></ol><p>dp[j] 表示：填满j（包括j）这么大容积的包，有dp[j]种方法</p><ol start="2"><li>确定递推公式</li></ol><p>dp[j]，j 为5</p><ul><li>已经有一个1（nums[i]） 的话，有 dp[4]种方法 凑成 容量为5的背包。</li><li>已经有一个2（nums[i]） 的话，有 dp[3]种方法 凑成 容量为5的背包。</li><li>已经有一个3（nums[i]） 的话，有 dp[2]中方法 凑成 容量为5的背包</li><li>已经有一个4（nums[i]） 的话，有 dp[1]中方法 凑成 容量为5的背包</li><li>已经有一个5 （nums[i]）的话，有 dp[0]中方法 凑成 容量为5的背包</li></ul><p>那么凑整dp[5]有多少方法呢，也就是把 所有的 dp[j - nums[i]] 累加起来。</p><p>所以求<strong>组合类问题</strong>的公式，都是类似这种：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[j] += dp[j - nums[i]]</span><br></pre></td></tr></table></figure><p><strong>这个公式在后面在讲解背包解决排列组合问题的时候还会用到！</strong></p><ol start="3"><li>dp数组如何初始化</li></ol><p>从0开始推，容量为0装满的方式有1种，这个是初始值，其他通过这个推过来。</p><p>从递推公式可以看出，在初始化的时候dp[0] 一定要初始化为1，因为dp[0]是在公式中一切递推结果的起源，如果dp[0]是0的话，递推结果将都是0。</p><ol start="4"><li>确定遍历顺序</li></ol><p>一维dp数组，先物品再容量</p><h4 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findTargetSumWays</span><span class="params">(nums []<span class="type">int</span>, target <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">sum := target</span><br><span class="line"><span class="keyword">for</span> _, num := <span class="keyword">range</span> nums &#123;</span><br><span class="line">sum += num</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> sum%<span class="number">2</span> == <span class="number">1</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line">bagWeight := sum / <span class="number">2</span></span><br><span class="line"><span class="comment">// 这里需要判断bagWeight是否小于0</span></span><br><span class="line">    <span class="comment">// 例如 [100],-200 的输入</span></span><br><span class="line">    <span class="keyword">if</span> bagWeight &lt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// dp[j] 表示：填满j这么大容积的包，有dp[j]种方法</span></span><br><span class="line">dp := <span class="built_in">make</span>([]<span class="type">int</span>, bagWeight+<span class="number">1</span>)</span><br><span class="line">dp[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(nums); i++ &#123;</span><br><span class="line"><span class="keyword">for</span> j := bagWeight; j &gt;= nums[i]; j-- &#123;</span><br><span class="line">dp[j] += dp[j-nums[i]]</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(dp)</span><br><span class="line"><span class="keyword">return</span> dp[bagWeight]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="一和零"><a href="#一和零" class="headerlink" title="一和零"></a>一和零</h3><p>给你一个二进制字符串数组 <code>strs</code> 和两个整数 <code>m</code> 和 <code>n</code> 。</p><p>请你找出并返回 <code>strs</code> 的最大子集的长度，该子集中 <strong>最多</strong> 有 <code>m</code> 个 <code>0</code> 和 <code>n</code> 个 <code>1</code> 。</p><p>如果 <code>x</code> 的所有元素也是 <code>y</code> 的元素，集合 <code>x</code> 是集合 <code>y</code> 的 <strong>子集</strong> 。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：strs = [&quot;10&quot;, &quot;0001&quot;, &quot;111001&quot;, &quot;1&quot;, &quot;0&quot;], m = 5, n = 3</span><br><span class="line">输出：4</span><br><span class="line">解释：最多有 5 个 0 和 3 个 1 的最大子集是 &#123;&quot;10&quot;,&quot;0001&quot;,&quot;1&quot;,&quot;0&quot;&#125; ，因此答案是 4 。</span><br><span class="line">其他满足题意但较小的子集包括 &#123;&quot;0001&quot;,&quot;1&quot;&#125; 和 &#123;&quot;10&quot;,&quot;1&quot;,&quot;0&quot;&#125; 。&#123;&quot;111001&quot;&#125; 不满足题意，因为它含 4 个 1 ，大于 n 的值 3 。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：strs = [&quot;10&quot;, &quot;0&quot;, &quot;1&quot;], m = 1, n = 1</span><br><span class="line">输出：2</span><br><span class="line">解释：最大的子集是 &#123;&quot;0&quot;, &quot;1&quot;&#125; ，所以答案是 2 。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= strs.length &lt;= 600</code></li><li><code>1 &lt;= strs[i].length &lt;= 100</code></li><li><code>strs[i]</code> 仅由 <code>&#39;0&#39;</code> 和 <code>&#39;1&#39;</code> 组成</li><li><code>1 &lt;= m, n &lt;= 100</code></li></ul><h4 id="分析-4"><a href="#分析-4" class="headerlink" title="分析"></a>分析</h4><p>这个题其实不难看出来是01背包问题但是有两个维度限制（经常见这类型的题），就像有的大招既扣蓝也扣血，<u>这俩都算是背包的容量</u>，所以我们for循环遍历需要三层了：物品、容量0、容量1（<u>我们需要把dp[m][n]中，m、n取值的各种情况都填满！</u>）</p><p>创建dp数组的时候再多创建一个维度即可，例如我们用滚动数组，一维数组即可解决，这里要变成二维</p><ol><li>确定dp数组及下标的含义</li></ol><p>dp[i][j]：最多有i个0和j个1的strs的最大子集的大小为dp[i][j]</p><ol start="2"><li>确定递推公式</li></ol><p>dp[i][j] 可以由前一个strs里的字符串推导出来，strs里的字符串有zeroNum个0，oneNum个1。</p><p>dp[i][j] 就可以是 dp[i - zeroNum][j - oneNum] + 1。</p><p>然后我们在遍历的过程中，取dp[i][j]的最大值。</p><p>所以递推公式：dp[i][j] &#x3D; max(dp[i][j], dp[i - zeroNum][j - oneNum] + 1);</p><p>此时大家可以回想一下01背包的递推公式：dp[j] &#x3D; max(dp[j], dp[j - weight[i]] + value[i]);</p><p>对比一下就会发现，字符串的zeroNum和oneNum相当于物品的重量（weight[i]），字符串本身的个数相当于物品的价值（value[i]）</p><ol start="3"><li>dp数组如何初始化</li></ol><p>根据含义dp[0][0]直接为0就行，滚动数组的话也不会覆盖掉什么的</p><ol start="4"><li>确定遍历顺序</li></ol><p>先遍历物品再遍历背包，从后往前遍历</p><h4 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h4><p>自我感觉注释写的挺清晰的</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findMaxForm</span><span class="params">(strs []<span class="type">string</span>, m <span class="type">int</span>, n <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line"><span class="comment">// 滚动数组，所以 创建dp数组时无需考虑物品的容量</span></span><br><span class="line"><span class="comment">// 因为是两个容量限制，所以是dp[m+1][n+1] (加一是因为含有0)</span></span><br><span class="line">dp := <span class="built_in">make</span>([][]<span class="type">int</span>, m+<span class="number">1</span>)</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt;= m; i++ &#123;</span><br><span class="line">dp[i] = <span class="built_in">make</span>([]<span class="type">int</span>, n+<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 遍历物品</span></span><br><span class="line"><span class="keyword">for</span> _, str := <span class="keyword">range</span> strs &#123;</span><br><span class="line">zeroNum,oneNum := <span class="number">0</span>,<span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> _, ch := <span class="keyword">range</span> str &#123;</span><br><span class="line"><span class="keyword">if</span> ch == <span class="string">&#x27;0&#x27;</span> &#123;</span><br><span class="line">zeroNum++</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">oneNum++</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 遍历容量</span></span><br><span class="line"><span class="keyword">for</span> i := m; i &gt;= zeroNum; i-- &#123; <span class="comment">// 遍历0的容量</span></span><br><span class="line"><span class="keyword">for</span> j := n ; j &gt;= oneNum; j-- &#123; <span class="comment">// 遍历1的容量</span></span><br><span class="line">dp[i][j] = max(dp[i][j],dp[i-zeroNum][j-oneNum]+<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> dp[m][n]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="01背包总结"><a href="#01背包总结" class="headerlink" title="01背包总结"></a>01背包总结</h3><p>刚刚刷过的题目总结一下：</p><ul><li><a class="link"   href="https://programmercarl.com/%E8%83%8C%E5%8C%85%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%8001%E8%83%8C%E5%8C%85-2.html" >纯 0 - 1 背包<i class="fas fa-external-link-alt"></i></a> 求 给定背包容量，尽可能装，最大价值是多少</li><li><a class="link"   href="https://programmercarl.com/0416.%E5%88%86%E5%89%B2%E7%AD%89%E5%92%8C%E5%AD%90%E9%9B%86.html" >416. 分割等和子集<i class="fas fa-external-link-alt"></i></a> 求 给定背包容量，能不能装满这个背包</li><li><a class="link"   href="https://programmercarl.com/1049.%E6%9C%80%E5%90%8E%E4%B8%80%E5%9D%97%E7%9F%B3%E5%A4%B4%E7%9A%84%E9%87%8D%E9%87%8FII.html" >1049. 最后一块石头的重量 II<i class="fas fa-external-link-alt"></i></a> 求 给定背包容量，尽可能装，最多能装多少</li><li><a class="link"   href="https://programmercarl.com/0494.%E7%9B%AE%E6%A0%87%E5%92%8C.html" >494. 目标和<i class="fas fa-external-link-alt"></i></a> 求 给定背包容量，装满背包，有多少种方法</li><li><a class="link"   href="https://leetcode.cn/problems/ones-and-zeroes/description/" >474. 一和零<i class="fas fa-external-link-alt"></i></a> 求 给定背包容量，尽可能装，最多有多少个物品</li></ul><p>所以在代码随想录中所列举的题目，都是 0-1背包不同维度上的应用</p><p>【不得不说卡哥找的这些题都太典型了，每道题是一种类型，有些佩服】</p><h2 id="完全背包"><a href="#完全背包" class="headerlink" title="完全背包"></a>完全背包</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p><u>完全背包和01背包问题唯一不同的地方就是，每种物品有无限件</u></p><p>以例题为切入，背包最大重量为4，物品如下：</p><table><thead><tr><th>重量</th><th>价值</th><th></th></tr></thead><tbody><tr><td>物品0</td><td>1</td><td>15</td></tr><tr><td>物品1</td><td>3</td><td>20</td></tr><tr><td>物品2</td><td>4</td><td>30</td></tr></tbody></table><p><u>每件商品都有无限个</u>，问背包能背的物品最大价值是多少？</p><p>回顾一下01背包的核心代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 遍历物品</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(weight); i++ &#123;</span><br><span class="line"><span class="comment">// 遍历容量</span></span><br><span class="line"><span class="keyword">for</span> j := bagWeight; j &gt;= weight[i]; j-- &#123;</span><br><span class="line">dp[j] = max(dp[j], dp[j-weight[i]]+value[i])</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中容量倒序遍历，为了保证每个物品仅被添加一次，而完全背包的物品是可以添加多次的，所以要从小到大去遍历，即：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 遍历物品</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(weight); i++ &#123;</span><br><span class="line"><span class="comment">// 遍历容量</span></span><br><span class="line"><span class="keyword">for</span> j := weight[i]; j &lt;= bagWeight; j-- &#123;</span><br><span class="line">dp[j] = max(dp[j], dp[j-weight[i]]+value[i])</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>01背包中必须先遍历物品，再遍历容量，但完全背包中两种遍历方式都可以，因为dp[j]是根据 下标j之前所对应的dp[j]计算出来的，只要保证下标j之前的dp[j]都是经过计算的就可以了，而完全背包从前往后遍历，所以前面的数都是全的，咋遍历都没问题。</p><p><strong>背包遍历顺序</strong></p><ul><li>01背包：先物品后容量，容量倒序遍历</li><li>完全背包：容量正序遍历，两种遍历方式都可以</li></ul><p>但是！具体问题要具体分析，这里说的仅仅是纯背包问题的遍历顺序</p><p>顺便把例题做了吧，代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   weight := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line">   value := []<span class="type">int</span>&#123;<span class="number">15</span>, <span class="number">20</span>, <span class="number">30</span>&#125;</span><br><span class="line">   bagWeight := <span class="number">4</span></span><br><span class="line">   <span class="comment">// 因为容量包含0，所以要+1</span></span><br><span class="line">   dp := <span class="built_in">make</span>([]<span class="type">int</span>, bagWeight+<span class="number">1</span>)</span><br><span class="line">   <span class="comment">// 遍历物品</span></span><br><span class="line">   <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(weight); i++ &#123;</span><br><span class="line">      <span class="comment">// 遍历容量</span></span><br><span class="line">      <span class="keyword">for</span> j := weight[i]; j &lt;= bagWeight; j++ &#123;</span><br><span class="line">         dp[j] = max(dp[j], dp[j-weight[i]]+value[i])</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   fmt.Println(dp)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="零钱兑换-II"><a href="#零钱兑换-II" class="headerlink" title="零钱兑换 II"></a>零钱兑换 II</h3><p><a class="link"   href="https://leetcode.cn/problems/coin-change-ii/description/" >题目链接<i class="fas fa-external-link-alt"></i></a></p><p>给你一个整数数组 <code>coins</code> 表示不同面额的硬币，另给一个整数 <code>amount</code> 表示总金额。</p><p>请你计算并返回可以凑成总金额的硬币组合数。如果任何硬币组合都无法凑出总金额，返回 <code>0</code> </p><p>假设每一种面额的硬币有无限个。 题目数据保证结果符合 32 位带符号整数。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：amount = 5, coins = [1, 2, 5]</span><br><span class="line">输出：4</span><br><span class="line">解释：有四种方式可以凑成总金额：</span><br><span class="line">5=5</span><br><span class="line">5=2+2+1</span><br><span class="line">5=2+1+1+1</span><br><span class="line">5=1+1+1+1+1</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：amount = 3, coins = [2]</span><br><span class="line">输出：0</span><br><span class="line">解释：只用面额 2 的硬币不能凑成总金额 3 。</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：amount = 10, coins = [10] </span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= coins.length &lt;= 300</code></li><li><code>1 &lt;= coins[i] &lt;= 5000</code></li><li><code>coins</code> 中的所有值 <strong>互不相同</strong></li><li><code>0 &lt;= amount &lt;= 5000</code></li></ul><h4 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h4><p>和01背包中的那个题一样，组合问题：<code>dp[j] += dp[j - nums[i]]</code>，没啥好解释的</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">change</span><span class="params">(amount <span class="type">int</span>, coins []<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">dp := <span class="built_in">make</span>([]<span class="type">int</span>, amount+<span class="number">1</span>) <span class="comment">//总金额为i时，有dp[i]种兑换方法</span></span><br><span class="line">dp[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(coins); i++ &#123;</span><br><span class="line"><span class="keyword">for</span> j := coins[i]; j &lt;= amount; j++ &#123;</span><br><span class="line">dp[j] += dp[j-coins[i]]</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> dp[amount]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="遍历顺序分析"><a href="#遍历顺序分析" class="headerlink" title="遍历顺序分析"></a>遍历顺序分析</h4><p>但是注意，这里遍历顺序必须时先物品后容量！</p><p>因为纯完全背包求得装满背包的最大价值是多少，和凑成总和的元素有没有顺序没关系，即：有顺序也行，没有顺序也行！而本题要求凑成总和的组合数，元素之间明确要求没有顺序。所以纯完全背包是能凑成总和就行，不用管怎么凑的。本题是求凑出来的方案个数，且每个方案个数是为组合数。</p><p>外层for循环遍历物品（钱币），内层for遍历背包（金钱总额）的情况，得到的方法数量只有{1, 5}这种情况。而不会出现{5, 1}的情况。</p><p>如果把两个for交换顺序，背包容量的每一个值，都是经过 1 和 5 的计算，包含了{1, 5} 和 {5, 1}两种情况。<strong>此时dp[j]里算出来的就是排列数！</strong></p><p><strong>总结</strong></p><ul><li><strong>如果求组合数就是外层for循环遍历物品，内层for遍历背包</strong></li><li><strong>如果求排列数就是外层for遍历背包，内层for循环遍历物品</strong></li></ul><h3 id="组合总和-Ⅳ"><a href="#组合总和-Ⅳ" class="headerlink" title="组合总和 Ⅳ"></a>组合总和 Ⅳ</h3><p><a class="link"   href="https://leetcode.cn/problems/combination-sum-iv/description/" >题目链接<i class="fas fa-external-link-alt"></i></a></p><p>给你一个由 <strong>不同</strong> 整数组成的数组 <code>nums</code> ，和一个目标整数 <code>target</code> 。请你从 <code>nums</code> 中找出并返回总和为 <code>target</code> 的元素组合的个数。</p><p><strong>进阶：</strong>如果给定的数组中含有负数会发生什么？问题会产生何种变化？如果允许负数出现，需要向题目中添加哪些限制条件？</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1,2,3], target = 4</span><br><span class="line">输出：7</span><br><span class="line">解释：</span><br><span class="line">所有可能的组合为：</span><br><span class="line">(1, 1, 1, 1)</span><br><span class="line">(1, 1, 2)</span><br><span class="line">(1, 2, 1)</span><br><span class="line">(1, 3)</span><br><span class="line">(2, 1, 1)</span><br><span class="line">(2, 2)</span><br><span class="line">(3, 1)</span><br><span class="line">请注意，顺序不同的序列被视作不同的组合。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [9], target = 3</span><br><span class="line">输出：0</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 200</code></li><li><code>1 &lt;= nums[i] &lt;= 1000</code></li><li><code>nums</code> 中的所有元素 <strong>互不相同</strong></li><li><code>1 &lt;= target &lt;= 1000</code></li></ul><h4 id="分析-5"><a href="#分析-5" class="headerlink" title="分析"></a>分析</h4><p>标题写的时组合，实际上时排序，没啥好说的，for循环调换一下，换的时候注意需要把<code>j-nums[i]&lt;0</code>的部刨掉</p><ul><li>如果求组合数就是外层for循环遍历物品，内层for遍历背包</li><li>如果求排列数就是外层for遍历背包，内层for循环遍历物品</li></ul><p>进阶：如果给定的数组中含有负数，则会导致出现无限长度的排列。例如1、-1那就没完了，所以需要单独处理一下</p><h4 id="代码-5"><a href="#代码-5" class="headerlink" title="代码"></a>代码</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">combinationSum4</span><span class="params">(nums []<span class="type">int</span>, target <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">   dp := <span class="built_in">make</span>([]<span class="type">int</span>, target+<span class="number">1</span>)</span><br><span class="line">   dp[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">   <span class="keyword">for</span> j := <span class="number">0</span>; j &lt;= target; j++ &#123;</span><br><span class="line">      <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(nums); i++ &#123;</span><br><span class="line">         <span class="keyword">if</span> j-nums[i] &gt;= <span class="number">0</span> &#123; <span class="comment">// 这个判断得单独处理</span></span><br><span class="line">            dp[j] += dp[j-nums[i]]</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> dp[target]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="爬楼梯进阶版"><a href="#爬楼梯进阶版" class="headerlink" title="爬楼梯进阶版"></a>爬楼梯进阶版</h3><p>假设你正在爬楼梯。需要 <code>n</code> 阶你才能到达楼顶，你每次可以上1至m个台阶，n、m均为输入。你有多少种不同的方法可以爬到楼顶呢？</p><h4 id="分析-6"><a href="#分析-6" class="headerlink" title="分析"></a>分析</h4><ul><li>每一阶可以重复使用，例如跳了1阶，还可以继续跳1阶——完全背包</li><li>跳到楼顶有几种方法——排序问题</li></ul><p>从而确定遍历顺序：</p><ul><li>完全背包：容量正序遍历</li><li>排序问题：先容量再物品</li></ul><p><code>dp[i]</code>：爬到有i个台阶的楼顶，有dp[i]种方法。递推公式：<code>dp[i] += dp[i - j]</code>。初始化：<code>dp[0]=0</code></p><h4 id="代码-6"><a href="#代码-6" class="headerlink" title="代码"></a>代码</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">climbStairs</span><span class="params">(n <span class="type">int</span>,m <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">   dp := <span class="built_in">make</span>([]<span class="type">int</span>,n+<span class="number">1</span>)</span><br><span class="line">   dp[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">   <span class="keyword">for</span> j := <span class="number">0</span>; j &lt;= n; j++ &#123;</span><br><span class="line">      <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; m; i++ &#123;</span><br><span class="line">         dp[j] += dp[j-i]</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> dp[n]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="零钱兑换"><a href="#零钱兑换" class="headerlink" title="零钱兑换"></a>零钱兑换</h3><p>给你一个整数数组 <code>coins</code> ，表示不同面额的硬币；以及一个整数 <code>amount</code> ，表示总金额。</p><p>计算并返回可以凑成总金额所需的 <strong>最少的硬币个数</strong> 。如果没有任何一种硬币组合能组成总金额，返回 <code>-1</code> 。</p><p>你可以认为每种硬币的数量是无限的。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：coins = [1, 2, 5], amount = 11</span><br><span class="line">输出：3 </span><br><span class="line">解释：11 = 5 + 5 + 1</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：coins = [2], amount = 3</span><br><span class="line">输出：-1</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：coins = [1], amount = 0</span><br><span class="line">输出：0</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= coins.length &lt;= 12</code></li><li><code>1 &lt;= coins[i] &lt;= 2^31 - 1</code></li><li><code>0 &lt;= amount &lt;= 10^4</code></li></ul><h4 id="分析-7"><a href="#分析-7" class="headerlink" title="分析"></a>分析</h4><ul><li>确定dp数组：凑足总额为j所需钱币的最少个数为dp[j]</li><li>确定递推公式：<code>dp[j] = min(dp[j - coins[i]] + 1, dp[j])</code></li><li>dp数组如何初始化[值得注意]：非0的元素都是应该是最大值，dp[0]&#x3D;0</li><li>遍历顺序：求钱币最小个数，那么钱币有顺序和没有顺序都可以，都不影响钱币的最小个数</li></ul><h4 id="代码-7"><a href="#代码-7" class="headerlink" title="代码"></a>代码</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">coinChange</span><span class="params">(coins []<span class="type">int</span>, amount <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">dp := <span class="built_in">make</span>([]<span class="type">int</span>, amount+<span class="number">1</span>) <span class="comment">// 总金额为i时，最少硬币数为dp[i]</span></span><br><span class="line"><span class="comment">// dp[j] = min(dp[j],dp[j-coins[i]]+1)</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= amount; i++ &#123;</span><br><span class="line">dp[i] = math.MaxInt32</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt;= <span class="built_in">len</span>(coins); i++ &#123;</span><br><span class="line"><span class="keyword">for</span> j := coins[i]; j &lt;= amount; j++ &#123;</span><br><span class="line">dp[j] = min(dp[j], dp[j-coins[i]]+<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> dp[amount]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="完全平方数"><a href="#完全平方数" class="headerlink" title="完全平方数"></a>完全平方数</h3><p>给你一个整数 <code>n</code> ，返回 和为 <code>n</code> 的完全平方数的最少数量</p><p><strong>完全平方数</strong> 是一个整数，其值等于另一个整数的平方；换句话说，其值等于一个整数自乘的积。例如，<code>1</code>、<code>4</code>、<code>9</code> 和 <code>16</code> 都是完全平方数，而 <code>3</code> 和 <code>11</code> 不是。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 12</span><br><span class="line">输出：3 </span><br><span class="line">解释：12 = 4 + 4 + 4</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 13</span><br><span class="line">输出：2</span><br><span class="line">解释：13 = 4 + 9</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= n &lt;= 10^4</code></li></ul><h4 id="分析-8"><a href="#分析-8" class="headerlink" title="分析"></a>分析</h4><p>题目翻译：完全平方数就是物品（可以无限件使用），凑个正整数n就是背包，问凑满这个背包最少有多少物品</p><ul><li>完全背包</li><li>遍历顺序没要求</li></ul><h4 id="代码-8"><a href="#代码-8" class="headerlink" title="代码"></a>代码</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">numSquares</span><span class="params">(n <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">dp := <span class="built_in">make</span>([]<span class="type">int</span>, n+<span class="number">1</span>) <span class="comment">// j需要的最少平方数个数</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= n; i++ &#123;</span><br><span class="line">dp[i] = math.MaxInt32</span><br><span class="line">&#125;</span><br><span class="line">m := <span class="type">int</span>(math.Pow(<span class="type">float64</span>(n), <span class="number">0.5</span>))</span><br><span class="line"><span class="comment">// 遍历物品</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt;= m; i++ &#123;</span><br><span class="line"><span class="comment">// 遍历容量</span></span><br><span class="line"><span class="keyword">for</span> j := i * i; j &lt;= n; j++ &#123;</span><br><span class="line">dp[j] = min(dp[j], dp[j-i*i]+<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> dp[n]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="多重背包"><a href="#多重背包" class="headerlink" title="多重背包"></a>多重背包</h2><p>有N种物品和一个容量为V 的背包。第i种物品最多有Mi件可用，每件耗费的空间是Ci ，价值是Wi 。求解将哪些物品装入背包可使这些物品的耗费的空间 总和不超过背包容量，且价值总和最大。</p><p>多重背包和01背包是非常像的，每件物品最多有Mi件可用，把Mi件摊开，其实就是一个01背包问题了。</p><p>例如：</p><p>背包最大重量为10。</p><p>物品为：</p><table><thead><tr><th></th><th>重量</th><th>价值</th><th>数量</th></tr></thead><tbody><tr><td>物品0</td><td>1</td><td>15</td><td>2</td></tr><tr><td>物品1</td><td>3</td><td>20</td><td>3</td></tr><tr><td>物品2</td><td>4</td><td>30</td><td>2</td></tr></tbody></table><p>问背包能背的物品最大价值是多少？</p><p>和如下情况有区别么？</p><table><thead><tr><th></th><th>重量</th><th>价值</th><th>数量</th></tr></thead><tbody><tr><td>物品0</td><td>1</td><td>15</td><td>1</td></tr><tr><td>物品0</td><td>1</td><td>15</td><td>1</td></tr><tr><td>物品1</td><td>3</td><td>20</td><td>1</td></tr><tr><td>物品1</td><td>3</td><td>20</td><td>1</td></tr><tr><td>物品1</td><td>3</td><td>20</td><td>1</td></tr><tr><td>物品2</td><td>4</td><td>30</td><td>1</td></tr><tr><td>物品2</td><td>4</td><td>30</td><td>1</td></tr></tbody></table><p>毫无区别，这就转成了一个01背包问题了，且每个物品只用一次。</p><p>所以可以直接把它看成01背包来做。当然另一种实现方式，就是把每种商品遍历的个数放在01背包里面在遍历一遍。即01背包里面在加一个for循环遍历一个每种商品的数量。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 多重背包可以化解为 01 背包</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">multiplePack</span><span class="params">(weight, value, nums []<span class="type">int</span>, bagWeight <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(nums); i++ &#123;</span><br><span class="line"><span class="keyword">for</span> nums[i] &gt; <span class="number">1</span> &#123;</span><br><span class="line">weight = <span class="built_in">append</span>(weight, weight[i])</span><br><span class="line">value = <span class="built_in">append</span>(value, value[i])</span><br><span class="line">nums[i]--</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">res := <span class="built_in">make</span>([]<span class="type">int</span>, bagWeight+<span class="number">1</span>)</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(weight); i++ &#123;</span><br><span class="line"><span class="keyword">for</span> j := bagWeight; j &gt;= weight[i]; j-- &#123;</span><br><span class="line">res[j] = getMax(res[j], res[j-weight[i]]+value[i])</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> res[bagWeight]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="背包总结"><a href="#背包总结" class="headerlink" title="背包总结"></a>背包总结</h2><p>01背包：</p><ul><li>物品只能用一次</li><li>二维数组时，遍历顺序均可</li><li>一维数组只能先物品后容量，容量倒序遍历</li></ul><p>完全背包：</p><ul><li>物品可用无限次</li><li>容量正序遍历（保证无限次）</li><li>一维数组遍历顺序均可，常见特例如下：<ul><li><u>组合数</u>：先遍历物品，再遍历容量(背包)</li><li><u>排序数</u>：先遍历容量(背包)，再遍历物品</li></ul></li></ul><p>多重背包：转换成01背包来做</p><p>组合、排序问题递推通常公式为：<code>dp[i] += dp[i - j]</code>，初始化<code>dp[0]=0</code></p><p>OK，你已经掌握01背包、完全背包、多重背包了，快去solo面试官吧！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;你的背包~🎵&lt;/p&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;这个是刷代码随想录的做题笔记，分析部分大多是我自己的理解，代码我用go写的，现在回头再看一遍还是觉得代码随想录</summary>
      
    
    
    
    
    <category term="算法" scheme="https://tbghg.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>MySQL RR隔离级别</title>
    <link href="https://tbghg.github.io/2023-01-07/f7735ae40302/"/>
    <id>https://tbghg.github.io/2023-01-07/f7735ae40302/</id>
    <published>2023-01-07T03:30:13.000Z</published>
    <updated>2023-01-07T03:30:13.000Z</updated>
    
    <content type="html"><![CDATA[<p>以前搞不明白RR不能解决幻读，但是又说RR可以用间隙锁、临界锁、MVCC解决幻读，于是详细捋了一下。简单来说是RR可以通过间隙锁、临界锁、MVCC 解决部分幻读，但不能解决全部的，想要完全解决需要串行化。</p><h2 id="幻读与不可重复读区别"><a href="#幻读与不可重复读区别" class="headerlink" title="幻读与不可重复读区别"></a>幻读与不可重复读区别</h2><p>“幻读”是指读的过程中，某些元组被增加、删除，这样进行一些集合操作，比如算总数，平均值等等，就会每次算出不一样的数。</p><p>不可重复读：一个事务先后读取同一条记录，但两次读取的数据不同</p><h2 id="RR与RC的区别"><a href="#RR与RC的区别" class="headerlink" title="RR与RC的区别"></a>RR与RC的区别</h2><p>SQL 标准定义了四个隔离级别：</p><h3 id="隔离级别"><a href="#隔离级别" class="headerlink" title="隔离级别"></a>隔离级别</h3><ul><li><strong>READ-UNCOMMITTED(读取未提交)：</strong> 最低的隔离级别，允许读取尚未提交的数据变更，<strong>可能会导致脏读、幻读或不可重复读</strong>。</li><li><strong>READ-COMMITTED(读取已提交)：</strong> 允许读取并发事务已经提交的数据，<strong>可以阻止脏读，但是幻读或不可重复读仍有可能发生</strong>。</li><li><strong>REPEATABLE-READ(可重复读)：</strong> 对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，<strong>可以阻止脏读和不可重复读，但幻读仍有可能发生</strong>。</li><li><strong>SERIALIZABLE(可串行化)：</strong> 最高的隔离级别，完全服从ACID的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，<strong>该级别可以防止脏读、不可重复读以及幻读</strong>。</li></ul><h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><h4 id="锁方面的区别"><a href="#锁方面的区别" class="headerlink" title="锁方面的区别"></a>锁方面的区别</h4><p>显然 RR 支持 gap lock(next-key lock)，而RC则没有gap lock。因为MySQL的RR需要gap lock来解决幻读问题。而RC隔离级别则是允许存在不可重复读和幻读的。所以RC的并发一般要好于RR</p><h4 id="一致性读"><a href="#一致性读" class="headerlink" title="一致性读"></a>一致性读</h4><p>RC隔离级别时，事务中的每一条select语句会读取到他自己执行时已经提交了的记录，也就是每一条select都有自己的一致性读ReadView</p><p>而RR隔离级别时，事务中的一致性读的ReadView是以第一条select语句的运行时，作为本事务的一致性读snapshot的建立时间点的。只能读取该时间点之前已经提交的数据。</p><p>RC 支持半一致性读，RR不支持</p><p>对比RR隔离级别，update语句会使用当前读，如果一行被锁定了，那么此时会被阻塞，发生锁等待。而不会读取最新的提交版本，然后来判断是否符合where条件。</p><p>半一致性读的优点：减少了update语句时行锁的冲突；对于不满足update更新条件的记录，可以提前放锁，减少并发冲突的概率。</p><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p>以前随手做的笔记，忘记记录参考文章了，抱歉</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;以前搞不明白RR不能解决幻读，但是又说RR可以用间隙锁、临界锁、MVCC解决幻读，于是详细捋了一下。简单来说是RR可以通过间隙锁、临界锁、MVCC 解决部分幻读，但不能解决全部的，想要完全解决需要串行化。&lt;/p&gt;
&lt;h2 id=&quot;幻读与不可重复读区别&quot;&gt;&lt;a href=&quot;#</summary>
      
    
    
    
    <category term="uncategorized" scheme="https://tbghg.github.io/categories/uncategorized/"/>
    
    
    <category term="MySQL" scheme="https://tbghg.github.io/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>MySQL不同版本介绍</title>
    <link href="https://tbghg.github.io/2023-01-06/4eb524e9ed76/"/>
    <id>https://tbghg.github.io/2023-01-06/4eb524e9ed76/</id>
    <published>2023-01-06T09:45:30.000Z</published>
    <updated>2023-01-06T09:45:30.000Z</updated>
    
    <content type="html"><![CDATA[<p>经常听到什么MySQL5.5-5.7、8.0，但是中间的就没咋听说过，今天来探究下这个版本到底是啥情况。</p><h2 id="版号说明"><a href="#版号说明" class="headerlink" title="版号说明"></a>版号说明</h2><p>以5.5.60这个版本的MySQL为例，说明版本号的每个数字含义(mysql-5.5.60.tar.gz)</p><ol><li>第一个数字(5)主版本号：文件格式改动时，将作为新的版本发布</li><li>第二个数字(5)发行版本号：新增特性或者改动不兼容时，发行版本号需要更改</li><li>第三个数字(60)发行序列号：主要是小的改动，如bug的修复、函数添加或更改、配置参数的更改等</li></ol><h2 id="MySQL产品线"><a href="#MySQL产品线" class="headerlink" title="MySQL产品线"></a>MySQL产品线</h2><p><strong>3.X至5.1.X</strong></p><p>这是早期MySQL的版本。常见早期的版本有：4.1.7、5.0.56等。</p><p><strong>5.4.X到5.7.X</strong></p><p>这是为了整合MySQL AB公司社区和第三方公司开发的新存储引擎。吸收新的实现算法，更好的支持SMP架构。为提升性能做了大量代码重构。</p><p>MySQL 在2017年发布了新的版本8.0，但是在此之前的上一个版本是5.7</p><p>早在2008年，Sun收购MySQL AB以前，公司内部已经在进行着版本号6的开发工作了（5.0在2005年发布）。然而，版本6的MySQL制定的目标和计划过于激进，步子迈得有点儿大，随着收购的顺利完成，项目也被砍掉了。 至于版本号7，则是用在了MySQL Cluster上。由于新版的MySQL带来了许多的重大更新，开发者们决定是时候把版本号往前滚动一下了，于是便有了8。</p><p>同时因为7发布时间较晚，发布时已经有其他手段解决MySQL集群技术问题，所以并没有很好的推广使用。</p><h2 id="大版本间的区别"><a href="#大版本间的区别" class="headerlink" title="大版本间的区别"></a>大版本间的区别</h2><h3 id="5-5"><a href="#5-5" class="headerlink" title="5.5"></a>5.5</h3><ol><li><code>innodb</code> 就是从 <strong>5.5</strong> 这个版本开始成为 <strong>默认的存储引擎</strong></li><li>引入了真 <code>UTF8</code> ——&gt; <code>utf8mb4</code></li><li><code>5.5</code>的时候引入了<code>MDL(meta data lock)</code>元数据锁</li></ol><p><code>MySQL</code>在<code>5.5.3</code>之后增加了这个<code>utf8mb4</code>的编码，<code>mb4</code>就是<code>most bytes 4</code>的意思，专门用来兼容四字节的<code>unicode</code>。好在<code>utf8mb4</code>是<code>utf8</code>的超集，除了将编码改为<code>utf8mb4</code>外不需要做其他转换。当然，一般情况下使用<code>utf8</code>也就够了。</p><h3 id="5-6"><a href="#5-6" class="headerlink" title="5.6"></a>5.6</h3><p>官方文档：<a class="link"   href="https://dev.mysql.com/doc/refman/5.6/en/mysql-nutshell.html" >What Is New in MySQL 5.6<i class="fas fa-external-link-alt"></i></a></p><p>也可以参考<a class="link"   href="https://zhuanlan.zhihu.com/p/406633443" >MySQL大版本间的区别<i class="fas fa-external-link-alt"></i></a>，不再赘述了</p><p>挑几个说一下：</p><ul><li><code>Innodb</code> 将 <code>flush</code> 刷盘操作从主线程移动到其他线程</li><li><code>Innodb</code>可以创建 <strong>全文索引</strong></li><li>可以用 <code>EXPLAIN</code> 来查看 <code>DELETE</code>，<code>INSERT</code>，<code>REPLACE</code>，<code>UPDATE</code>等 <code>DML</code> 操作的执行计划。在这之前，它只支持 <code>SELECT</code> 操作</li></ul><h3 id="5-7"><a href="#5-7" class="headerlink" title="5.7"></a>5.7</h3><p>同样只挑几个说一下</p><ul><li>从<code>MySQL 5.7.8</code>开始，<code>MySQL</code>支持原生<code>JSON</code>类型</li><li>之前：对于触发器事件(INSERT、UPDATE、DELETE)和操作时间(BEFORE、AFTER)的组合，一个表最多只能有一个触发器，即在某个触发时间点只能有一个触发事件<br>现在：允许在某个时间点，有多个触发事件</li><li>由于文件系统 <code>The Fusion-io Non-Volatile Memory (NVM)</code> 在 <code>Linux</code> 上提供了原子操作，这导致 <code>innodb</code> 的 <code>doublewrite</code> 变得冗余，所以在该文件系统上，会自动关闭 <code>doublewrite</code></li><li>支持多线程来刷新缓冲池中的<strong>脏页面</strong></li></ul><h3 id="8-0"><a href="#8-0" class="headerlink" title="8.0"></a>8.0</h3><p><code>MySQL 8.0</code>是有中文文档的：<a class="link"   href="https://docs.gitcode.net/mysql/guide/general-information/mysql-nutshell.html" >MySQL 8.0 中的新功能<i class="fas fa-external-link-alt"></i></a></p><p>挑几个重点的：</p><ul><li>索引支持降序排序</li><li>支持正则表达式</li><li>可以为这些类型增加默认值 <code>BLOB</code>、<code>TEXT</code>、<code>GEOMETRY</code> 、 <code>JSON</code></li><li>从 <code>MySQL 8.0.20</code> 开始，<code>doublewrite</code> 缓冲区存储在 <code>doublewrite</code> 文件中</li><li>不再支持 <u>查询缓存</u></li></ul><h4 id="MySQL8-0为啥删除查询缓存？"><a href="#MySQL8-0为啥删除查询缓存？" class="headerlink" title="MySQL8.0为啥删除查询缓存？"></a>MySQL8.0为啥删除查询缓存？</h4><p>缓存的意义在于快速查询提升系统性能，可以灵活控制缓存的一致性</p><p><code>MySQL</code>缓存的限制</p><ol><li><code>MySQL</code>基本没有手段灵活的管理缓存失效和生效，尤其对于频繁更新的表</li><li><code>SQL</code>必须完全一致才会导致<code>cache</code>命中</li><li>为了节省内存空间，太大的<code>result set</code>不会被<code>cache </code>(小于 <code>query\_cache\_limit</code>)</li><li><code>MySQL</code>缓存在分库分表环境下是不起作用的</li><li>执行<code>SQL</code>里有触发器、自定义函数时，<code>MySQL</code>缓存也是不起作用的</li><li>在表的结构或数据发生改变时，基于该表相关<code>cache</code>立即全部失效</li></ol><p>替代方案：应用层组织缓存，最简单的是使用<code>redis</code>，<code>ehcached</code>等</p><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul><li><a class="link"   href="https://blog.csdn.net/hyh19962008/article/details/105165899" >MySQL版本号6和7去哪了<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://www.cnblogs.com/mehome/p/9428175.html" >MySQL版本详解<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://zhuanlan.zhihu.com/p/406633443" >MySQL大版本间的区别<i class="fas fa-external-link-alt"></i></a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;经常听到什么MySQL5.5-5.7、8.0，但是中间的就没咋听说过，今天来探究下这个版本到底是啥情况。&lt;/p&gt;
&lt;h2 id=&quot;版号说明&quot;&gt;&lt;a href=&quot;#版号说明&quot; class=&quot;headerlink&quot; title=&quot;版号说明&quot;&gt;&lt;/a&gt;版号说明&lt;/h2&gt;&lt;p&gt;以5</summary>
      
    
    
    
    <category term="uncategorized" scheme="https://tbghg.github.io/categories/uncategorized/"/>
    
    
    <category term="MySQL" scheme="https://tbghg.github.io/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>Go 切片踩坑整合</title>
    <link href="https://tbghg.github.io/2022-12-14/e90408a6529f/"/>
    <id>https://tbghg.github.io/2022-12-14/e90408a6529f/</id>
    <published>2022-12-14T17:45:30.000Z</published>
    <updated>2022-12-14T17:45:30.000Z</updated>
    
    <content type="html"><![CDATA[<p>又踩个坑，正好把之前那个整理到一块</p><p>2022&#x2F;12&#x2F;15</p><p>刷这道题的时候<a class="link"   href="https://leetcode.cn/problems/path-sum-ii/solutions/" >113. 路径总和 II<i class="fas fa-external-link-alt"></i></a>，大体来说就是先定义了一个二维切片，dfs闭包遍历，切片path代表当前的路径，如果路径符合，`result &#x3D; append(result,path)`，但是后来发现因为path的值会改变，导致result的值会跟着改变，毕竟result的底层数组装的是[]int结构体。</p><p>有什么解决办法呢？</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 原来的</span></span><br><span class="line">result = <span class="built_in">append</span>(result, <span class="built_in">append</span>(path))</span><br><span class="line"><span class="comment">// 正确的（好家伙，一直没想到）</span></span><br><span class="line">result = <span class="built_in">append</span>(result, <span class="built_in">append</span>([]<span class="type">int</span>(<span class="literal">nil</span>), path...))</span><br></pre></td></tr></table></figure><p>2022&#x2F;07&#x2F;09</p><p>今日刷力扣，写一个二叉树的前序遍历代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> BiTree</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> TreeNode <span class="keyword">struct</span> &#123;</span><br><span class="line">    Val   <span class="type">int</span></span><br><span class="line">    Left  *TreeNode</span><br><span class="line">    Right *TreeNode</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">preorderTraversal</span><span class="params">(root *TreeNode)</span></span> []<span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> result []<span class="type">int</span></span><br><span class="line">    traversal(root, result)</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">traversal</span><span class="params">(node *TreeNode, result []<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> node == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    result = <span class="built_in">append</span>(result, node.Val)</span><br><span class="line">    traversal(node.Left, result)</span><br><span class="line">    traversal(node.Right, result)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>go的传递方式只有值传递一种，但切片是引用类型，在调用函数时将实际参数的地址传递到函数中，那么在函数中对参数所进行的修改，将影响到实际参数。</p><p>但是本题力扣上运行时输出结果却为<code>[]</code>（正确输出：<code>1 2 3</code>），便引起了笔者的思考</p><p>首先打印result前后的地址</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">preorderTraversal</span><span class="params">(root *TreeNode)</span></span> []<span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> result []<span class="type">int</span></span><br><span class="line">    fmt.Printf(<span class="string">&quot;初始地址：%p\n&quot;</span>, result)</span><br><span class="line">    traversal(root, result)</span><br><span class="line">    fmt.Printf(<span class="string">&quot;返回的地址：%p\n&quot;</span>, result)</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">traversal</span><span class="params">(node *TreeNode, result []<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;传入函数的地址为：%p\n&quot;</span>, result)</span><br><span class="line">    <span class="keyword">if</span> node == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    result = <span class="built_in">append</span>(result, node.Val)</span><br><span class="line">    fmt.Println(result)</span><br><span class="line">    fmt.Printf(<span class="string">&quot;append后的地址为：%p\n&quot;</span>, result)</span><br><span class="line">    traversal(node.Left, result)</span><br><span class="line">    traversal(node.Right, result)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">初始地址：<span class="number">0x0</span></span><br><span class="line">传入函数的地址为：<span class="number">0x0</span></span><br><span class="line">[<span class="number">1</span>]</span><br><span class="line"><span class="built_in">append</span>后的地址为：<span class="number">0xc0000140a0</span></span><br><span class="line">传入函数的地址为：<span class="number">0xc0000140a0</span></span><br><span class="line">传入函数的地址为：<span class="number">0xc0000140a0</span></span><br><span class="line">[<span class="number">1</span> <span class="number">2</span>]</span><br><span class="line"><span class="built_in">append</span>后的地址为：<span class="number">0xc0000140b0</span></span><br><span class="line">传入函数的地址为：<span class="number">0xc0000140b0</span></span><br><span class="line">[<span class="number">1</span> <span class="number">2</span> <span class="number">3</span>]</span><br><span class="line"><span class="built_in">append</span>后的地址为：<span class="number">0xc000074020</span></span><br><span class="line">传入函数的地址为：<span class="number">0xc000074020</span></span><br><span class="line">传入函数的地址为：<span class="number">0xc000074020</span></span><br><span class="line">传入函数的地址为：<span class="number">0xc0000140b0</span></span><br><span class="line">返回的地址：<span class="number">0x0</span></span><br></pre></td></tr></table></figure><p>从第二行可以看出传递的确实是指针，在递归的时候result的值确实再改变，而值得我们注意的是append前后地址的变化。</p><p>当切片需要扩容时会创建新的数组，这会导致和原有切片的分离，也就是说现在改变的切片已经不再是原来的地址了，但是append时我们将它重新赋给了result，所以traversal函数内的result始终指向正确的地址，而preorderTraversal中的result仍时原来的地址，所以最终的结果为<code>[]</code>，关于切片的底层实现详见<a class="link"   href="https://www.topgoer.com/go%E5%9F%BA%E7%A1%80/Slice%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0.html" >链接<i class="fas fa-external-link-alt"></i></a>。</p><p>解决方法：</p><p>第一种是traversal中返回result</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">preorderTraversal</span><span class="params">(root *TreeNode)</span></span> []<span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> result []<span class="type">int</span></span><br><span class="line">    result = traversal(root, result)</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">traversal</span><span class="params">(node *TreeNode,result []<span class="type">int</span>)</span></span> []<span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> node == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    &#125;</span><br><span class="line">    result = <span class="built_in">append</span>(result, node.Val)</span><br><span class="line">    result = traversal(node.Left, result)</span><br><span class="line">    result = traversal(node.Right, result)</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第二种为力扣给出的题解</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">preorderTraversal</span><span class="params">(root *TreeNode)</span></span> (vals []<span class="type">int</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> preorder <span class="function"><span class="keyword">func</span><span class="params">(*TreeNode)</span></span></span><br><span class="line">    preorder = <span class="function"><span class="keyword">func</span><span class="params">(node *TreeNode)</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> node == <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        vals = <span class="built_in">append</span>(vals, node.Val)</span><br><span class="line">        preorder(node.Left)</span><br><span class="line">        preorder(node.Right)</span><br><span class="line">    &#125;</span><br><span class="line">    preorder(root)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;又踩个坑，正好把之前那个整理到一块&lt;/p&gt;
&lt;p&gt;2022&amp;#x2F;12&amp;#x2F;15&lt;/p&gt;
&lt;p&gt;刷这道题的时候&lt;a class=&quot;link&quot;   href=&quot;https://leetcode.cn/problems/path-sum-ii/solutions/&quot; </summary>
      
    
    
    
    <category term="uncategorized" scheme="https://tbghg.github.io/categories/uncategorized/"/>
    
    
    <category term="go" scheme="https://tbghg.github.io/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>力扣全局变量</title>
    <link href="https://tbghg.github.io/2022-12-14/9161b2cfd0a9/"/>
    <id>https://tbghg.github.io/2022-12-14/9161b2cfd0a9/</id>
    <published>2022-12-14T17:34:33.000Z</published>
    <updated>2022-12-14T17:34:33.000Z</updated>
    
    <content type="html"><![CDATA[<p>力扣这里的全局变量只会初始化一次，之后只是单纯的调用这个函数，所以如果想用全局变量一定要在目标函数那里重新初始化一下，要不会出现一些莫名其妙的错误。</p><p>另外不太推荐力扣这里使用全局变量，毕竟我们要完成的是一个小功能，如果在这种小功能上加上一堆全局变量写大了会比较难受。当想用的时候可以考虑一下闭包，很大概率能解决我们的问题。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;力扣这里的全局变量只会初始化一次，之后只是单纯的调用这个函数，所以如果想用全局变量一定要在目标函数那里重新初始化一下，要不会出现一些莫名其妙的错误。&lt;/p&gt;
&lt;p&gt;另外不太推荐力扣这里使用全局变量，毕竟我们要完成的是一个小功能，如果在这种小功能上加上一堆全局变量写大了会比较</summary>
      
    
    
    
    <category term="uncategorized" scheme="https://tbghg.github.io/categories/uncategorized/"/>
    
    
    <category term="算法" scheme="https://tbghg.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>常用排序算法总结</title>
    <link href="https://tbghg.github.io/2022-11-26/2a6a2821281a/"/>
    <id>https://tbghg.github.io/2022-11-26/2a6a2821281a/</id>
    <published>2022-11-26T13:45:32.000Z</published>
    <updated>2022-11-26T13:45:32.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近复习了下排序算法，常用的都用<code>go</code>敲了一遍。练习排序可以在牛客的<a class="link"   href="https://www.nowcoder.com/questionTerminal/508f66c6c93d4191ab25151066cb50ef" >这道试题<i class="fas fa-external-link-alt"></i></a>中进行测试。</p><p><a class="link"   href="https://www.runoob.com/w3cnote/ten-sorting-algorithm.html" >菜鸟教程<i class="fas fa-external-link-alt"></i></a>关于排序这块介绍的挺详细的，还配有动图，比较推荐。另外B站上<a class="link"   href="https://space.bilibili.com/406692798/" >马士兵老师<i class="fas fa-external-link-alt"></i></a>在计数排序、基数排序这块进行了拓展，感觉说的也很棒</p><h2 id="简要总结"><a href="#简要总结" class="headerlink" title="简要总结"></a>简要总结</h2><p><img                       lazyload                     alt="image"                     data-src="https://s1.ax1x.com/2022/11/26/zN3Pnf.png"                      alt="img"                ></p><p>排序算法总结</p><ul><li>快速排序和归并排序都使用了分治和递归</li><li>从时间性能上看，快速排序是所有排序算法中实际性能最好的，然而快速排序在最坏情况下（数据基本有序）的时间性能不如堆排序和归并排序，并且空间复杂度高，所以更适合数据不大的情况</li><li>堆排序在任何情况下，其时间复杂度为 Ο(nlogn)。这相对于快速排序而言是堆排序的最大优点。堆排序在元素较少时由于消耗较多时间在初始建堆上，因此不值得提倡，然而当元素较多时还是很有效的排序算法</li><li>与快速排序和堆排序相比，归并排序的优点是它是一种稳定的排序方法，最坏情况下时间性能好</li><li>从方法稳定性上来看，大多数时间复杂度为Ο(n^2)的排序均是稳定的排序方法，除简单选择排序之外。而多数时间性能较好的排序方法，例如快速排序、堆排序、希尔排序都是不稳定的</li><li>基于比较的排序的时间复杂度下限是O(nlogn)，即这已经是最高的效率了</li></ul><p>基数排序和计数排序是非比较的排序的排序，都是桶思想，可以达到线性时间O(n)复杂度的排序，但是使用范围不太广。其中计数排序如果直接计数然后按照数量输出相应次数是不具有稳定性的，但是可以通过累加数组（前缀和）的形式先加一遍，然后逆序遍历原数组输出，即可保证稳定性。</p><p>计数排序场景示例：300W考生排名</p><h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><p>依次比较相邻的两个元素，按照升序或者降序的规则进行交换</p><p>稳定、平均时间O(n^2)、最好时间O(n)、最差时间O(n^2)、空间复杂度O(1)</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 冒泡排序</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">bubbleSort</span><span class="params">(length <span class="type">int</span>, source []<span class="type">int</span>)</span></span> []<span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; length; i++ &#123;</span><br><span class="line">        isSort := <span class="literal">true</span> <span class="comment">// 判断是否已经有序</span></span><br><span class="line">        <span class="keyword">for</span> j := <span class="number">0</span>; j &lt; length-i<span class="number">-1</span>; j++ &#123;</span><br><span class="line">            <span class="keyword">if</span> source[j] &gt; source[j+<span class="number">1</span>] &#123;</span><br><span class="line">                source[j], source[j+<span class="number">1</span>] = source[j+<span class="number">1</span>], source[j]</span><br><span class="line">                isSort = <span class="literal">false</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果切片已经有序直接退出</span></span><br><span class="line">        <span class="keyword">if</span> isSort &#123;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> source</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><p>平均时间O(n^2)、最好时间O(n^2)、最坏时间O(n^2)、不稳定、空间复杂度O(1)</p><p>从待排序的数据元素中选出最小（或最大）的一个元素，存放在待排序序列起始位置，直到全部待排序的数据元素的个数为零</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 选择排序</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">selectSort</span><span class="params">(length <span class="type">int</span>, source []<span class="type">int</span>)</span></span> []<span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; length<span class="number">-1</span>; i++ &#123;</span><br><span class="line">        minIdx, maxMin := i, source[i]</span><br><span class="line">        <span class="keyword">for</span> j := i + <span class="number">1</span>; j &lt; length; j++ &#123;</span><br><span class="line">            <span class="keyword">if</span> source[j] &lt; maxMin &#123;</span><br><span class="line">                minIdx = j</span><br><span class="line">                maxMin = source[j]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> minIdx != i &#123;</span><br><span class="line">            source[minIdx], source[i] = source[i], source[minIdx]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> source</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><p>将一个数据插入到已经排好序的有序数据中，从而得到一个新的、个数加一的有序数据</p><p>平均时间O(n^2)、最好时间O(n)、最差时间O(n^2)、稳定、空间复杂度O(1)</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 插入排序</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">insertSort</span><span class="params">(length <span class="type">int</span>, source []<span class="type">int</span>)</span></span> []<span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt; length; i++ &#123;</span><br><span class="line">        insertVal := source[i]</span><br><span class="line">        insertIdx := i</span><br><span class="line">        <span class="keyword">for</span> insertIdx &gt; <span class="number">0</span> &amp;&amp; source[insertIdx<span class="number">-1</span>] &gt; insertVal &#123;</span><br><span class="line">            source[insertIdx] = source[insertIdx<span class="number">-1</span>]</span><br><span class="line">            insertIdx--</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> insertIdx != i &#123;</span><br><span class="line">            source[insertIdx] = insertVal</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> source</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h2><h3 id="简要概括"><a href="#简要概括" class="headerlink" title="简要概括"></a>简要概括</h3><p>按照下标一定增量进行分组，每组再按照直接插入算法排序，随着组的减少，每组的元素也越来越少，当组数减少至为1时，整个文件分成1组，算法便终止。</p><p>希尔排序写的时候最好先把直接插入排序想一遍，要不循环那里容易晕</p><p>平均时间O(n^1.3~n^2)、最好时间O(n)、最坏时间O(n^2)、不稳定、空间复杂度O(1)</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 希尔排序</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">shellSort</span><span class="params">(length <span class="type">int</span>, source []<span class="type">int</span>)</span></span> []<span class="type">int</span> &#123;</span><br><span class="line">   <span class="comment">// 步长每次缩小一半，当步长为0时退出</span></span><br><span class="line">   <span class="keyword">for</span> gap := length / <span class="number">2</span>; gap &gt; <span class="number">0</span>; gap /= <span class="number">2</span> &#123;</span><br><span class="line">      <span class="comment">// 遍历每个小分组</span></span><br><span class="line">      <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; gap; i++ &#123;</span><br><span class="line">         <span class="comment">// 小分组内部插入排序，可以把i现象成之前的0，j的增长变为gap</span></span><br><span class="line">         <span class="keyword">for</span> j := i + gap; j &lt; length; j += gap &#123;</span><br><span class="line">            insertIdx := j</span><br><span class="line">            insertVal := source[j]</span><br><span class="line">            <span class="keyword">for</span> insertIdx &gt; i &amp;&amp; source[insertIdx-gap] &gt; insertVal &#123;</span><br><span class="line">               source[insertIdx] = source[insertIdx-gap]</span><br><span class="line">               insertIdx -= gap</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> insertIdx != j &#123;</span><br><span class="line">               source[insertIdx] = insertVal</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> source</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><h3 id="简要概括-1"><a href="#简要概括-1" class="headerlink" title="简要概括"></a>简要概括</h3><p>通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。大致意思就是在一个数组中取中间元素比它小的方左边比它大的则放右边两边元素再按照快排要求，最终变成有序序列。</p><p>平均时间O(nlogn)、最好时间O(nlogn)、最坏时间O(n^2)、不稳定、空间复杂度O(nlogn)</p><p>注意：当序列为为正序或逆序排列时为最坏时间，此时时间复杂度O(n^2)</p><h3 id="快排实现思路"><a href="#快排实现思路" class="headerlink" title="快排实现思路"></a>快排实现思路</h3><p>快速排序通过递归实现，一般是俩函数：</p><ol><li>quickSort递归函数:<ol><li>快排的入口并调用递归</li><li>终止条件: l &gt;&#x3D; r</li><li>参数: 切片 l r</li><li>返回值: 无</li></ol></li><li>partition定位pivot函数<ol><li>交换</li><li>返回pivot最后的位置</li></ol></li></ol><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">quickSort</span><span class="params">(source []<span class="type">int</span>, l <span class="type">int</span>, r <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">   <span class="comment">// 递归终止条件</span></span><br><span class="line">   <span class="keyword">if</span> l &gt;= r &#123;</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">   &#125;</span><br><span class="line">   q := partition(source, l, r)</span><br><span class="line">   quickSort(source, l, q<span class="number">-1</span>)</span><br><span class="line">   quickSort(source, q+<span class="number">1</span>, r)</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line"><span class="comment">// 快排定位pivot的函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">partition</span><span class="params">(nums []<span class="type">int</span>, l <span class="type">int</span>, r <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">   end, pivot := r, nums[r] <span class="comment">// 这块需要把r存下来，交换pivot用</span></span><br><span class="line">   <span class="keyword">for</span> l &lt; r &#123;</span><br><span class="line">      <span class="comment">// l先走 遇到大的就停下</span></span><br><span class="line">      <span class="keyword">for</span> l &lt; r &amp;&amp; nums[l] &lt;= pivot &#123;</span><br><span class="line">         l++</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 如果l==r导致的进入这步会直接跳出去等于啥也没干</span></span><br><span class="line">      <span class="comment">// 否则去找右侧小于pivot的值并与l交换</span></span><br><span class="line">      <span class="keyword">for</span> l &lt; r &amp;&amp; nums[r] &gt;= pivot &#123;</span><br><span class="line">         r--</span><br><span class="line">      &#125;</span><br><span class="line">      nums[l], nums[r] = nums[r], nums[l]</span><br><span class="line">      <span class="comment">// 此处不要写l++ r++ 有可能时l&gt;=r出去的 会导致下面报错</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 将pivot与最后的位置进行交换</span></span><br><span class="line">   nums[l], nums[end] = pivot, nums[l]</span><br><span class="line">   <span class="keyword">return</span> l</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><h3 id="简要概括-2"><a href="#简要概括-2" class="headerlink" title="简要概括"></a>简要概括</h3><p>堆排序这个<a class="link"   href="https://www.bilibili.com/video/BV1fp4y1D7cj/" >视频<i class="fas fa-external-link-alt"></i></a>讲的不错，但是这个人讲的计数排序有较大问题</p><p>堆排序（Heapsort）是指利用堆这种数据结构所设计的一种排序算法。堆积是一个近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。堆排序可以说是一种利用堆的概念来排序的选择排序。分为两种方法：</p><ol><li>大顶堆：每个节点的值都大于或等于其子节点的值，在堆排序算法中用于升序排列</li><li>小顶堆：每个节点的值都小于或等于其子节点的值，在堆排序算法中用于降序排列</li></ol><p>平均时间O(nlogn)、最好时间O(nlogn)、最差时间O(nlogn)、不稳定、空间复杂度O(1)</p><h3 id="重点"><a href="#重点" class="headerlink" title="重点"></a>重点</h3><p>堆排序中最中要的式子：</p><ul><li>下标为 i 的节点的父节点下标：( i - 1) &#x2F; 2</li><li>下标为 i 的节点的左孩子下标：i * 2 + 1</li><li>下标为 i 的节点的右孩子下标：i * 2 + 2</li></ul><h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 堆排序</span></span><br><span class="line"><span class="comment">// 维持大顶堆的性质(大顶堆最后输出的是从小到大的)</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">keepHeap</span><span class="params">(source []<span class="type">int</span>, n <span class="type">int</span>, change <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">   lSon := change*<span class="number">2</span> + <span class="number">1</span></span><br><span class="line">   rSon := change*<span class="number">2</span> + <span class="number">2</span></span><br><span class="line">   maxIdx := change</span><br><span class="line">   <span class="keyword">if</span> lSon &lt; n &amp;&amp; source[lSon] &gt; source[maxIdx] &#123;</span><br><span class="line">      maxIdx = lSon</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> rSon &lt; n &amp;&amp; source[rSon] &gt; source[maxIdx] &#123;</span><br><span class="line">      maxIdx = rSon</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> maxIdx != change &#123;</span><br><span class="line">      source[maxIdx], source[change] = source[change], source[maxIdx]</span><br><span class="line">      keepHeap(source, n, maxIdx)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line"><span class="comment">// 堆排序入口</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">heapSort</span><span class="params">(source []<span class="type">int</span>, length <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">   <span class="comment">// 建堆</span></span><br><span class="line">   <span class="comment">// 父节点: F = (i-1)/2</span></span><br><span class="line">   <span class="keyword">for</span> i := length/<span class="number">2</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i-- &#123;</span><br><span class="line">      keepHeap(source, length, i)</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 排序</span></span><br><span class="line">   <span class="keyword">for</span> i := length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i-- &#123;</span><br><span class="line">      source[<span class="number">0</span>], source[i] = source[i], source[<span class="number">0</span>]</span><br><span class="line">      keepHeap(source, i, <span class="number">0</span>)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><h3 id="简要概括-3"><a href="#简要概括-3" class="headerlink" title="简要概括"></a>简要概括</h3><p>建立在归并操作上的一种有效的排序算法。该算法是采用分治法的一个非常典型的应用</p><p>将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为二路归并。</p><p>平均时间O(nlogn)、最好时间O(nlogn)、最坏时间O(nlogn)、稳定、空间复杂度O(n)</p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><p>go这块因为操作的切片底层数组时一样的，所以没必要用left、right标记头尾，直接切割就行，反正会复用底层数组，不会浪费空间</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 归并排序入口</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mergeSort</span><span class="params">(arr []<span class="type">int</span>)</span></span> []<span class="type">int</span> &#123;</span><br><span class="line">   length := <span class="built_in">len</span>(arr)</span><br><span class="line">   <span class="comment">// 递归退出条件: 只有一个元素了</span></span><br><span class="line">   <span class="keyword">if</span> length &lt; <span class="number">2</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> arr</span><br><span class="line">   &#125;</span><br><span class="line">   middle := length / <span class="number">2</span></span><br><span class="line">   left := arr[<span class="number">0</span>:middle] <span class="comment">// 左开右闭</span></span><br><span class="line">   right := arr[middle:]</span><br><span class="line">   <span class="comment">// 直接递归 对结果进行合并</span></span><br><span class="line">   <span class="keyword">return</span> merge(mergeSort(left), mergeSort(right))</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">merge</span><span class="params">(left []<span class="type">int</span>, right []<span class="type">int</span>)</span></span> []<span class="type">int</span> &#123;</span><br><span class="line">   <span class="keyword">var</span> result []<span class="type">int</span> <span class="comment">// 储存结果的辅助切片</span></span><br><span class="line">   <span class="keyword">for</span> <span class="built_in">len</span>(left) != <span class="number">0</span> &amp;&amp; <span class="built_in">len</span>(right) != <span class="number">0</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> left[<span class="number">0</span>] &lt;= right[<span class="number">0</span>] &#123;</span><br><span class="line">         result = <span class="built_in">append</span>(result, left[<span class="number">0</span>])</span><br><span class="line">         left = left[<span class="number">1</span>:]</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         result = <span class="built_in">append</span>(result, right[<span class="number">0</span>])</span><br><span class="line">         right = right[<span class="number">1</span>:]</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 合并剩余左半区域</span></span><br><span class="line">   <span class="keyword">for</span> <span class="built_in">len</span>(left) != <span class="number">0</span> &#123;</span><br><span class="line">      result = <span class="built_in">append</span>(result, left[<span class="number">0</span>])</span><br><span class="line">      left = left[<span class="number">1</span>:]</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 合并剩余右半区域</span></span><br><span class="line">   <span class="keyword">for</span> <span class="built_in">len</span>(right) != <span class="number">0</span> &#123;</span><br><span class="line">      result = <span class="built_in">append</span>(result, right[<span class="number">0</span>])</span><br><span class="line">      right = right[<span class="number">1</span>:]</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul><li><a class="link"   href="https://blog.csdn.net/qq_42183409/article/details/100125115" >常见的八种排序方式<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="http://www.runoob.com/w3cnote/ten-sorting-algorithm.html" >菜鸟教程十大经典排序算法<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://www.nowcoder.com/questionTerminal/508f66c6c93d4191ab25151066cb50ef" >牛客[编程题]排序<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://space.bilibili.com/406692798/" >马士兵老师的B站视频<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://www.bilibili.com/video/BV1fp4y1D7cj/" >排序算法：堆排序【图解+代码】<i class="fas fa-external-link-alt"></i></a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;最近复习了下排序算法，常用的都用&lt;code&gt;go&lt;/code&gt;敲了一遍。练习排序可以在牛客的&lt;a class=&quot;link&quot;   href=&quot;</summary>
      
    
    
    
    <category term="uncategorized" scheme="https://tbghg.github.io/categories/uncategorized/"/>
    
    
    <category term="go" scheme="https://tbghg.github.io/tags/go/"/>
    
    <category term="算法" scheme="https://tbghg.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Golang channel深入挖掘</title>
    <link href="https://tbghg.github.io/2022-11-08/cd6365b47a49/"/>
    <id>https://tbghg.github.io/2022-11-08/cd6365b47a49/</id>
    <published>2022-11-08T04:38:18.000Z</published>
    <updated>2022-11-08T04:38:18.000Z</updated>
    
    <content type="html"><![CDATA[<p>《<a class="link"   href="https://golang.design/go-questions" >Go 程序员面试笔试宝典<i class="fas fa-external-link-alt"></i></a>》学习整理</p><h2 id="什么是CSP"><a href="#什么是CSP" class="headerlink" title="什么是CSP"></a>什么是CSP</h2><p>虽然可以使用共享内存进行数据交换，但是共享内存在不同的goroutine中容易发生竞态问题。为了保证数据交换的正确性，必须使用互斥量对内存进行加锁，这种做法势必造成性能问题。</p><p>golang主张<strong>通过通信来实现内存共享</strong>而非通过共享内存来实现通信。这就是 Go 的并发哲学，它依赖 CSP 模型（Communicating Sequential Processes），基于 channel 实现。</p><p>CSP 全称是 “Communicating Sequential Processes”(通信顺序进程)，是 Tony Hoare 在 1978 年发表在 ACM 的一篇论文。论文里指出一门编程语言应该重视 input 和 output 的原语，尤其是并发编程的代码。</p><p>Go 是第一个将 CSP 的这些思想引入，并且发扬光大的语言。仅管内存同步访问控制在某些情况下大有用处，Go 里也有相应的 sync 包支持，但是这在大型程序很容易出错。</p><p>大多数的编程语言的并发编程模型是基于线程和内存同步访问控制，Go 的并发编程的模型则用 goroutine 和 channel 来替代。Goroutine 和线程类似，channel 和 mutex (用于内存同步访问控制)类似。</p><p>Channel 则天生就可以和其他 channel 组合。我们可以把收集各种子系统结果的 channel 输入到同一个 channel。Channel 还可以和 select, cancel, timeout 结合起来。而 mutex 就没有这些功能。</p><p>Go 的并发原则非常优秀，目标就是简单：尽量使用 channel；把 goroutine 当作免费的资源，随便用。</p><h2 id="channel底层数据结构"><a href="#channel底层数据结构" class="headerlink" title="channel底层数据结构"></a>channel底层数据结构</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// go 1.9.2</span></span><br><span class="line"><span class="keyword">type</span> hchan <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// chan 里元素数量</span></span><br><span class="line">    qcount   <span class="type">uint</span></span><br><span class="line">    <span class="comment">// chan 底层循环数组的长度</span></span><br><span class="line">    dataqsiz <span class="type">uint</span></span><br><span class="line">    <span class="comment">// 指向底层循环数组的指针</span></span><br><span class="line">    <span class="comment">// 只针对有缓冲的 channel</span></span><br><span class="line">    buf      unsafe.Pointer</span><br><span class="line">    <span class="comment">// chan 中元素大小</span></span><br><span class="line">    elemsize <span class="type">uint16</span></span><br><span class="line">    <span class="comment">// chan 是否被关闭的标志</span></span><br><span class="line">    closed   <span class="type">uint32</span></span><br><span class="line">    <span class="comment">// chan 中元素类型</span></span><br><span class="line">    elemtype *_type <span class="comment">// element type</span></span><br><span class="line">    <span class="comment">// 已发送元素在循环数组中的索引</span></span><br><span class="line">    sendx    <span class="type">uint</span>   <span class="comment">// send index</span></span><br><span class="line">    <span class="comment">// 已接收元素在循环数组中的索引</span></span><br><span class="line">    recvx    <span class="type">uint</span>   <span class="comment">// receive index</span></span><br><span class="line">    <span class="comment">// 等待接收的 goroutine 队列</span></span><br><span class="line">    recvq    waitq  <span class="comment">// list of recv waiters</span></span><br><span class="line">    <span class="comment">// 等待发送的 goroutine 队列</span></span><br><span class="line">    sendq    waitq  <span class="comment">// list of send waiters</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 保护 hchan 中所有字段</span></span><br><span class="line">    lock mutex</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>buf</code> 指向底层循环数组，只有缓冲型的 channel 才有。</li><li><code>sendx</code>，<code>recvx</code> 均指向底层循环数组，表示当前可以发送和接收的元素位置索引值（相对于底层数组）。</li><li><code>sendq</code>，<code>recvq</code> 分别表示被阻塞的 goroutine，这些 goroutine 由于尝试读取 channel 或向 channel 发送数据而被阻塞。</li><li><code>waitq</code> 是 <code>sudog</code> 的一个双向链表，而 <code>sudog</code> 实际上是对 goroutine 的一个封装：</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> waitq <span class="keyword">struct</span> &#123;</span><br><span class="line">    first *sudog</span><br><span class="line">    last  *sudog</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>lock</code> 用来保证每个读 channel 或写 channel 的操作都是原子的。</li></ul><h2 id="创建channel"><a href="#创建channel" class="headerlink" title="创建channel"></a>创建channel</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// var 变量 chan 元素类型</span></span><br><span class="line"><span class="keyword">var</span> ch1 <span class="keyword">chan</span> <span class="type">int</span>   <span class="comment">// 声明一个传递整型的通道</span></span><br><span class="line"><span class="keyword">var</span> ch2 <span class="keyword">chan</span> <span class="type">bool</span>  <span class="comment">// 声明一个传递布尔型的通道</span></span><br><span class="line"><span class="keyword">var</span> ch3 <span class="keyword">chan</span> []<span class="type">int</span> <span class="comment">// 声明一个传递int切片的通道</span></span><br></pre></td></tr></table></figure><p>通道是引用类型，通道类型的空值是nil，声明的通道后需要使用make函数初始化之后才能使用。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// make(chan 元素类型, [缓冲大小])</span></span><br><span class="line"><span class="comment">// 无缓冲通道</span></span><br><span class="line">ch4 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line">ch5 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">bool</span>)</span><br><span class="line">ch6 := <span class="built_in">make</span>(<span class="keyword">chan</span> []<span class="type">int</span>)</span><br><span class="line"><span class="comment">// 有缓冲通道</span></span><br><span class="line">ch7 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>,<span class="number">7</span>)</span><br></pre></td></tr></table></figure><p>最终创建 chan 的函数是 <code>makechan</code>：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">makechan</span><span class="params">(t *chantype, size <span class="type">int64</span>)</span></span> *hchan</span><br></pre></td></tr></table></figure><p>从函数原型来看，创建的 chan 是一个指针。所以我们能在函数间直接传递 channel，而不用传递 channel 的指针。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> hchanSize = unsafe.Sizeof(hchan&#123;&#125;) + <span class="type">uintptr</span>(-<span class="type">int</span>(unsafe.Sizeof(hchan&#123;&#125;))&amp;(maxAlign<span class="number">-1</span>))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">makechan</span><span class="params">(t *chantype, size <span class="type">int64</span>)</span></span> *hchan &#123;</span><br><span class="line">    elem := t.elem</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 省略了检查 channel size，align 的代码</span></span><br><span class="line">    <span class="comment">// ……</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> c *hchan</span><br><span class="line">    <span class="comment">// 如果元素类型不含指针 或者 size 大小为 0（无缓冲类型）</span></span><br><span class="line">    <span class="comment">// 只进行一次内存分配</span></span><br><span class="line">    <span class="keyword">if</span> elem.kind&amp;kindNoPointers != <span class="number">0</span>  size == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// 如果 hchan 结构体中不含指针，GC 就不会扫描 chan 中的元素</span></span><br><span class="line">        <span class="comment">// 只分配 &quot;hchan 结构体大小 + 元素大小*个数&quot; 的内存</span></span><br><span class="line">        c = (*hchan)(mallocgc(hchanSize+<span class="type">uintptr</span>(size)*elem.size, <span class="literal">nil</span>, <span class="literal">true</span>))</span><br><span class="line">        <span class="comment">// 如果是缓冲型 channel 且元素大小不等于 0（大小等于 0的元素类型：struct&#123;&#125;）</span></span><br><span class="line">        <span class="keyword">if</span> size &gt; <span class="number">0</span> &amp;&amp; elem.size != <span class="number">0</span> &#123;</span><br><span class="line">            c.buf = add(unsafe.Pointer(c), hchanSize)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// race detector uses this location for synchronization</span></span><br><span class="line">            <span class="comment">// Also prevents us from pointing beyond the allocation (see issue 9401).</span></span><br><span class="line">            <span class="comment">// 1. 非缓冲型的，buf 没用，直接指向 chan 起始地址处</span></span><br><span class="line">            <span class="comment">// 2. 缓冲型的，能进入到这里，说明元素无指针且元素类型为 struct&#123;&#125;，也无影响</span></span><br><span class="line">            <span class="comment">// 因为只会用到接收和发送游标，不会真正拷贝东西到 c.buf 处（这会覆盖 chan的内容）</span></span><br><span class="line">            c.buf = unsafe.Pointer(c)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 进行两次内存分配操作</span></span><br><span class="line">        c = <span class="built_in">new</span>(hchan)</span><br><span class="line">        c.buf = newarray(elem, <span class="type">int</span>(size))</span><br><span class="line">    &#125;</span><br><span class="line">    c.elemsize = <span class="type">uint16</span>(elem.size)</span><br><span class="line">    c.elemtype = elem</span><br><span class="line">    <span class="comment">// 循环数组长度</span></span><br><span class="line">    c.dataqsiz = <span class="type">uint</span>(size)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回 hchan 指针</span></span><br><span class="line">    <span class="keyword">return</span> c</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="channel操作"><a href="#channel操作" class="headerlink" title="channel操作"></a>channel操作</h2><h3 id="简单使用"><a href="#简单使用" class="headerlink" title="简单使用"></a>简单使用</h3><p>通道有发送（send）、接收(receive）和关闭（close）三种操作。</p><p>发送和接收都使用&lt;-符号。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// PS: 下面就是个写法示例，不是用来跑的</span></span><br><span class="line"><span class="comment">// 创建</span></span><br><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line"><span class="comment">// 发送</span></span><br><span class="line">ch &lt;- <span class="number">10</span> <span class="comment">// 把10发送到ch中</span></span><br><span class="line"><span class="comment">// 接收</span></span><br><span class="line">x := &lt;- ch <span class="comment">// 从ch中接收值并赋值给变量x</span></span><br><span class="line">&lt;-ch       <span class="comment">// 从ch中接收值，忽略结果</span></span><br><span class="line"><span class="comment">// 关闭</span></span><br><span class="line"><span class="built_in">close</span>(ch)</span><br></pre></td></tr></table></figure><p>常见操作情况总结：</p><table><thead><tr><th>channel</th><th>nil</th><th>空</th><th>满</th><th>closed</th></tr></thead><tbody><tr><td>接收</td><td>阻塞</td><td>阻塞</td><td>正常接收</td><td>有值就接着正常读取，没有值返回零值和false</td></tr><tr><td>发送</td><td>阻塞</td><td>正常发送</td><td>阻塞</td><td>panic</td></tr><tr><td>关闭</td><td>panic</td><td>关闭成功</td><td>关闭成功</td><td>panic</td></tr></tbody></table><h3 id="无缓冲通道"><a href="#无缓冲通道" class="headerlink" title="无缓冲通道"></a>无缓冲通道</h3><p>无缓冲通道上的发送操作会阻塞，直到另一个goroutine在该通道上执行接收操作，这时值才能发送成功，两个goroutine将继续执行。<br>相反，如果接收操作先执行，接收方的goroutine将阻塞，直到另一个goroutine在该通道上发送一个值。</p><p>使用无缓冲通道进行通信将导致发送和接收的goroutine同步化。因此，无缓冲通道也被称为同步通道。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">            c &lt;- i</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">close</span>(c)</span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> data, ok := &lt;-c; ok &#123;</span><br><span class="line">            fmt.Println(data)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(<span class="string">&quot;main结束&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="有缓冲通道"><a href="#有缓冲通道" class="headerlink" title="有缓冲通道"></a>有缓冲通道</h3><p>使用make函数初始化通道的时候为其指定通道的容量</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">1</span>) <span class="comment">// 创建一个容量为1的有缓冲区通道</span></span><br><span class="line">    ch &lt;- <span class="number">10</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;发送成功&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只要通道的容量大于零，那么该通道就是有缓冲的通道，通道的容量表示通道中能存放元素的数量，当然如果容量等于零仍然会阻塞。</p><p>可以使用内置的len函数获取通道内元素的数量，使用cap函数获取通道的容量，不过一般不会这样去做。</p><h3 id="单向通道"><a href="#单向通道" class="headerlink" title="单向通道"></a>单向通道</h3><p>限制通道在函数中只能发送或只能接收</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// chan&lt;- int是一个只能发送的通道，可以发送但是不能接收</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">counter</span><span class="params">(out <span class="keyword">chan</span>&lt;- <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">100</span>; i++ &#123;</span><br><span class="line">        out &lt;- i</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">close</span>(out</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">squarer</span><span class="params">(out <span class="keyword">chan</span>&lt;- <span class="type">int</span>, in &lt;-<span class="keyword">chan</span> <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> in &#123;</span><br><span class="line">        out &lt;- i * i</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">close</span>(out)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// &lt;-chan int是一个只能接收的通道，可以接收但是不能发送</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printer</span><span class="params">(in &lt;-<span class="keyword">chan</span> <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> in &#123;</span><br><span class="line">        fmt.Println(i)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    ch1 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line">    ch2 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line">    <span class="keyword">go</span> counter(ch1)</span><br><span class="line">    <span class="keyword">go</span> squarer(ch2, ch1)</span><br><span class="line">    printer(ch2)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="优雅地关闭channel"><a href="#优雅地关闭channel" class="headerlink" title="优雅地关闭channel"></a>优雅地关闭channel</h2><ol><li>对一个关闭的通道再发送值就会导致panic。</li><li>对一个关闭的通道进行接收会一直获取值直到通道为空。</li><li>对一个关闭的并且没有值的通道执行接收操作会得到对应类型的零值。</li><li>关闭一个已经关闭的通道会导致panic。</li></ol><p>有一条广泛流传的关闭 channel 的原则：</p><blockquote><p><strong>don’t close a channel from the receiver side and don’t close a channel if the channel has multiple concurrent senders.</strong><br><em>（很经典也很重要）</em></p></blockquote><p>不要从一个 receiver 侧关闭 channel，也不要在有多个 sender 时关闭 channel。</p><p>比较好理解，向 channel 发送元素的就是 sender，因此 sender 可以决定何时不发送数据，并且关闭 channel。但是如果有多个 sender，某个 sender 同样没法确定其他 sender 的情况，这时也不能贸然关闭 channel。</p><p>但是上面所说的并不是最本质的，最本质的原则就只有一条：</p><blockquote><p>don’t close (or send values to) closed channels.</p></blockquote><p>有两个不那么优雅地关闭 channel 的方法：</p><ol><li>使用 defer-recover 机制，放心大胆地关闭 channel 或者向 channel 发送数据。即使发生了 panic，有 defer-recover 在兜底。</li><li>使用 sync.Once 来保证只关闭一次。</li></ol><p>根据 sender 和 receiver 的个数，分下面几种情况：</p><ol><li>一个 sender，一个 receiver</li><li>一个 sender， M 个 receiver</li><li>N 个 sender，一个 reciver</li><li>N 个 sender， M 个 receiver</li></ol><p>对于 1，2，只有一个 sender 的情况就不用说了，直接从 sender 端关闭就好了，没有问题。重点关注第 3，4 种情况。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    rand.Seed(time.Now().UnixNano())</span><br><span class="line">    <span class="keyword">const</span> Max = <span class="number">100000</span>  <span class="comment">// 生成的随机数的最大值</span></span><br><span class="line">    <span class="keyword">const</span> NumSenders = <span class="number">1000</span> <span class="comment">// 开启的sender数</span></span><br><span class="line"></span><br><span class="line">    dataCh := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">100</span>)</span><br><span class="line">    stopCh := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)   <span class="comment">// 作为信号channel</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// senders</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; NumSenders; i++ &#123;</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            <span class="keyword">for</span> &#123;</span><br><span class="line">                <span class="keyword">select</span> &#123;</span><br><span class="line">                <span class="keyword">case</span> &lt;- stopCh:</span><br><span class="line">                    <span class="comment">// 正常情况下会阻塞，所以不会执行</span></span><br><span class="line">                    <span class="comment">// 关闭情况下会读取0值，执行return</span></span><br><span class="line">                    <span class="keyword">return</span></span><br><span class="line">                <span class="keyword">case</span> dataCh &lt;- rand.Intn(Max):</span><br><span class="line">                    <span class="comment">// 发送数据</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// the receiver</span></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">for</span> value := <span class="keyword">range</span> dataCh &#123;</span><br><span class="line">            <span class="comment">// 收到了Max-1就不再接收数据了</span></span><br><span class="line">            <span class="keyword">if</span> value == Max<span class="number">-1</span> &#123;</span><br><span class="line">                fmt.Println(<span class="string">&quot;send stop signal to senders.&quot;</span>)</span><br><span class="line">                <span class="built_in">close</span>(stopCh)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            &#125;</span><br><span class="line">            fmt.Println(value)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> &lt;- time.After(time.Hour):</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码并没有明确关闭 dataCh，在 Go 语言中，对于一个 channel，如果最终没有任何 goroutine 引用它，不管 channel 有没有被关闭，最终都会被 gc 回收。所以，在这种情形下，所谓的优雅地关闭 channel 就是不关闭channel，让 gc 代劳。</p><p>第四种情况，这里有 M 个 receiver，如果直接还是采取第 3 种解决方案，由 receiver 直接关闭 stopCh 的话，就会重复关闭一个 channel，导致 panic。因此需要增加一个中间人，M 个 receiver 都向它发送关闭 dataCh 的“请求”，中间人收到第一个请求后，就会直接下达关闭 dataCh 的指令（通过关闭 stopCh，这时就不会发生重复关闭的情况，因为 stopCh 的发送方只有中间人一个）。另外，这里的 N 个 sender 也可以向中间人发送关闭 dataCh 的请求（这里发送请求后关闭的同样是stopCh，多个sender的情况下是不会由sender主动关闭dataCh的）</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    rand.Seed(time.Now().UnixNano())</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> Max = <span class="number">100000</span>  <span class="comment">// 生成的随机数的最大值</span></span><br><span class="line">    <span class="keyword">const</span> NumReceivers = <span class="number">10</span> <span class="comment">// 开启的receiver数</span></span><br><span class="line">    <span class="keyword">const</span> NumSenders = <span class="number">1000</span> <span class="comment">// 开启的sender数</span></span><br><span class="line"></span><br><span class="line">    dataCh := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">100</span>)</span><br><span class="line">    stopCh := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 必须是一个缓冲通道，toStop 就是中间人的角色</span></span><br><span class="line">    <span class="comment">// 接收 senders 和 receivers 发送过来的关闭 dataCh 请求。</span></span><br><span class="line">    toStop := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">string</span>, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> stoppedBy <span class="type">string</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 中间人，收到toStop后执行一次close(stopCh)就退出</span></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        stoppedBy = &lt;-toStop</span><br><span class="line">        <span class="built_in">close</span>(stopCh)</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// senders</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; NumSenders; i++ &#123;</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(id <span class="type">string</span>)</span></span> &#123;</span><br><span class="line">            <span class="keyword">for</span> &#123;</span><br><span class="line">                value := rand.Intn(Max)</span><br><span class="line">                <span class="keyword">if</span> value == <span class="number">0</span> &#123;</span><br><span class="line">                    <span class="keyword">select</span> &#123;</span><br><span class="line">                    <span class="keyword">case</span> toStop &lt;- <span class="string">&quot;sender#&quot;</span> + id:</span><br><span class="line">                    <span class="keyword">default</span>:</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">return</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">select</span> &#123;</span><br><span class="line">                <span class="keyword">case</span> &lt;- stopCh:</span><br><span class="line">                    <span class="keyword">return</span></span><br><span class="line">                <span class="keyword">case</span> dataCh &lt;- value:</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;(strconv.Itoa(i))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// receivers</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; NumReceivers; i++ &#123;</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(id <span class="type">string</span>)</span></span> &#123;</span><br><span class="line">            <span class="keyword">for</span> &#123;</span><br><span class="line">                <span class="keyword">select</span> &#123;</span><br><span class="line">                <span class="keyword">case</span> &lt;- stopCh:</span><br><span class="line">                    <span class="keyword">return</span></span><br><span class="line">                <span class="keyword">case</span> value := &lt;-dataCh:</span><br><span class="line">                    <span class="keyword">if</span> value == Max<span class="number">-1</span> &#123;</span><br><span class="line">                        <span class="keyword">select</span> &#123;</span><br><span class="line">                        <span class="keyword">case</span> toStop &lt;- <span class="string">&quot;receiver#&quot;</span> + id:</span><br><span class="line">                        <span class="keyword">default</span>:</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">return</span></span><br><span class="line">                    &#125;</span><br><span class="line">                    fmt.Println(value)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;(strconv.Itoa(i))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> &lt;- time.After(time.Hour):</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里将 toStop 声明成了一个 缓冲型的 channel。假设 toStop 声明的是一个非缓冲型的 channel，那么第一个发送的关闭 dataCh 请求可能会丢失。因为无论是 sender 还是 receiver 都是通过 select 语句来发送请求，如果中间人所在的 goroutine 没有准备好，那 select 语句就不会选中，直接走 default 选项，什么也不做。这样，第一个关闭 dataCh 的请求就会丢失。</p><p>如果，我们把 toStop 的容量声明成 Num(senders) + Num(receivers)，那发送 dataCh 请求的部分可以改成更简洁的形式：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// toStop部分</span></span><br><span class="line">toStop := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">string</span>, NumReceivers + NumSenders)</span><br><span class="line"><span class="comment">// sender部分</span></span><br><span class="line">value := rand.Intn(Max)</span><br><span class="line"><span class="keyword">if</span> value == <span class="number">0</span> &#123;</span><br><span class="line">    toStop &lt;- <span class="string">&quot;sender#&quot;</span> + id</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// receiver部分</span></span><br><span class="line"><span class="keyword">if</span> value == Max<span class="number">-1</span> &#123;</span><br><span class="line">    toStop &lt;- <span class="string">&quot;receiver#&quot;</span> + id</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>直接向 toStop 发送请求，因为 toStop 容量足够大，所以不用担心阻塞，自然也就不用 select 语句再加一个 default case 来避免阻塞。</p><h2 id="Channel引发的泄漏"><a href="#Channel引发的泄漏" class="headerlink" title="Channel引发的泄漏"></a>Channel引发的泄漏</h2><p>Channel 可能会引发 goroutine 泄漏。</p><p>泄漏的原因是 goroutine 操作 channel 后，处于发送或接收阻塞状态，而 channel 处于满或空的状态，一直得不到改变。<br>同时，垃圾回收器也不会回收此类资源，进而导致 gouroutine 会一直处于等待队列中。</p><p>另外，程序运行过程中，对于一个 channel，如果没有任何 goroutine 引用了，gc 会对其进行回收操作，不会引起内存泄漏。</p><h3 id="情境一：select-case-误用导致的内存泄露"><a href="#情境一：select-case-误用导致的内存泄露" class="headerlink" title="情境一：select-case 误用导致的内存泄露"></a>情境一：<code>select-case</code> 误用导致的内存泄露</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// out:</span></span><br><span class="line">    <span class="comment">// NumGoroutine: 2</span></span><br><span class="line">    <span class="comment">// 超时</span></span><br><span class="line">    <span class="comment">// NumGoroutine: 3</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestLeakOfMemory</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">   fmt.Println(<span class="string">&quot;NumGoroutine:&quot;</span>, runtime.NumGoroutine())</span><br><span class="line">   chanLeakOfMemory()</span><br><span class="line">   time.Sleep(time.Second * <span class="number">3</span>)</span><br><span class="line">   fmt.Println(<span class="string">&quot;NumGoroutine:&quot;</span>, runtime.NumGoroutine())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">chanLeakOfMemory</span><span class="params">()</span></span> &#123;</span><br><span class="line">   errCh := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">error</span>) <span class="comment">// (1)</span></span><br><span class="line">   <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; <span class="comment">// (5)</span></span><br><span class="line">      time.Sleep(<span class="number">2</span> * time.Second)</span><br><span class="line">      errCh &lt;- errors.New(<span class="string">&quot;chan error&quot;</span>) <span class="comment">// (2)</span></span><br><span class="line">      fmt.Println(<span class="string">&quot;finish sending&quot;</span>)</span><br><span class="line">   &#125;()</span><br><span class="line"></span><br><span class="line">   <span class="keyword">var</span> err <span class="type">error</span></span><br><span class="line">   <span class="keyword">select</span> &#123;</span><br><span class="line">   <span class="keyword">case</span> &lt;-time.After(time.Second): <span class="comment">// (3) 大家也经常在这里使用 &lt;-ctx.Done()</span></span><br><span class="line">      fmt.Println(<span class="string">&quot;超时&quot;</span>)</span><br><span class="line">   <span class="keyword">case</span> err = &lt;-errCh: <span class="comment">// (4)</span></span><br><span class="line">      <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">         fmt.Println(err)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         fmt.Println(<span class="literal">nil</span>)</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据输出结果（开始有两个 goroutine，结束时有三个 goroutine），我们可以知道，直到测试函数结束前，仍有一个 goroutine 没有退出。原因是由于 (1) 处创建的 errCh 是不含缓存队列的 channel，由于没有发送方往 errCh 发送数据，所以 (4) 处代码一直阻塞。直到 (3) 处超时后，打印“超时”，函数退出，(4) 处代码都未接收成功。而 (2) 处的所在的 goroutine 在“超时”被打印后，才开始发送。由于外部的 goroutine 已经退出了，errCh 没有接收者，导致 (2) 处一直阻塞。因此 (2) 处代码所在的协程一直未退出，造成了内存泄漏。如果代码中有许多类似的代码，或在 for 循环中使用了上述形式的代码，随着时间的增长会造成多个未退出的 gorouting，最终导致程序 OOM。</p><p>解决办法：为 channel 增加一个缓存队列，即把 (1) 处代码改为 <code>errCh := make(chan error, 1)</code></p><h3 id="情景二：for-range-误用导致的内存泄露"><a href="#情景二：for-range-误用导致的内存泄露" class="headerlink" title="情景二：for-range 误用导致的内存泄露"></a>情景二：<code>for-range</code> 误用导致的内存泄露</h3><p>上述示例中只有一个发送者，且只发送一次，所以增加一个缓存队列即可。但在其他情况下，可能不止有一个发送者（或者不只发送一次），所以这个方案要求，缓存队列的容量需要和发送次数一致。一旦缓存队列容量被用完后，再有发送者发送就会阻塞发送者 goroutine。如果恰好此时接收者退出了，那么仍然至少会有一个 goroutine 无法退出，从而造成内存泄漏。就比如下面的代码。不知道经过上面的讲解，读者是否能够发现其中的问题。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestLeakOfMemory2</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">   fmt.Println(<span class="string">&quot;NumGoroutine:&quot;</span>, runtime.NumGoroutine())</span><br><span class="line">   chanLeakOfMemory2()</span><br><span class="line">   time.Sleep(time.Second * <span class="number">3</span>) <span class="comment">// 等待 goroutine 执行，防止过早输出结果</span></span><br><span class="line">   fmt.Println(<span class="string">&quot;NumGoroutine:&quot;</span>, runtime.NumGoroutine())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">chanLeakOfMemory2</span><span class="params">()</span></span> &#123;</span><br><span class="line">   ich := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">100</span>) <span class="comment">// (3)</span></span><br><span class="line">   <span class="comment">// sender</span></span><br><span class="line">   <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">      <span class="keyword">defer</span> <span class="built_in">close</span>(ich)</span><br><span class="line">      <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++ &#123;</span><br><span class="line">         ich &lt;- i</span><br><span class="line">         time.Sleep(time.Millisecond) <span class="comment">// 控制一下，别发太快</span></span><br><span class="line">      &#125;</span><br><span class="line">   &#125;()</span><br><span class="line">   <span class="comment">// receiver</span></span><br><span class="line">   <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">      ctx, cancel := context.WithTimeout(context.Background(), time.Second)</span><br><span class="line">      <span class="keyword">defer</span> cancel()</span><br><span class="line">      <span class="keyword">for</span> i := <span class="keyword">range</span> ich &#123; <span class="comment">// (2)</span></span><br><span class="line">         <span class="keyword">if</span> ctx.Err() != <span class="literal">nil</span> &#123; <span class="comment">// (1)</span></span><br><span class="line">            fmt.Println(ctx.Err())</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">         &#125;</span><br><span class="line">         fmt.Println(i)</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Output:</span></span><br><span class="line">    <span class="comment">// NumGoroutine: 2</span></span><br><span class="line">    <span class="comment">// 0</span></span><br><span class="line">    <span class="comment">// 1</span></span><br><span class="line">    <span class="comment">// ...(省略)...</span></span><br><span class="line">    <span class="comment">// 789</span></span><br><span class="line">    <span class="comment">// context deadline exceeded</span></span><br><span class="line">    <span class="comment">// NumGoroutine: 3</span></span><br></pre></td></tr></table></figure><p>我们聪明地使用了 channel 的缓存队列。我们以为我们循环发送，发完之后就会把 channel 关闭。而且我们使用 for range 获取 channel 的值，会一直获取，直到 channel 关闭。但在代码 (1) 处，接收者的 goroutine 中，我们加了一个判断语句。这会让代码 (2) 处的 channel 还没被接收完就退出了接收者 goroutine。尽管代码 (3) 处有缓存，但是因为发送 channel 在 for 循环中，缓存队列很快就会被占满，阻塞在第 101 的位置。所以这种情况我们要使用一个额外的 stop channel 来终结发送者所在的 goroutine。方式如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestLeakOfMemory2</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">   fmt.Println(<span class="string">&quot;NumGoroutine:&quot;</span>, runtime.NumGoroutine())</span><br><span class="line">   chanLeakOfMemory2()</span><br><span class="line">   time.Sleep(time.Second * <span class="number">3</span>) <span class="comment">// 等待 goroutine 执行，防止过早输出结果</span></span><br><span class="line">   fmt.Println(<span class="string">&quot;NumGoroutine:&quot;</span>, runtime.NumGoroutine())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">chanLeakOfMemory2</span><span class="params">()</span></span> &#123;</span><br><span class="line">   ich := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">100</span>)</span><br><span class="line">   stopCh := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">   <span class="comment">// sender</span></span><br><span class="line">   <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">      <span class="keyword">defer</span> <span class="built_in">close</span>(ich)</span><br><span class="line">      <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++ &#123;</span><br><span class="line">         <span class="keyword">select</span> &#123;</span><br><span class="line">         <span class="keyword">case</span> &lt;-stopCh:</span><br><span class="line">             <span class="keyword">return</span></span><br><span class="line">         <span class="keyword">case</span> ich &lt;- i:</span><br><span class="line">         &#125;</span><br><span class="line">         time.Sleep(time.Millisecond) <span class="comment">// 控制一下，别发太快</span></span><br><span class="line">      &#125;</span><br><span class="line">   &#125;()</span><br><span class="line">   <span class="comment">// receiver</span></span><br><span class="line">   <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">      ctx, cancel := context.WithTimeout(context.Background(), time.Second)</span><br><span class="line">      <span class="keyword">defer</span> cancel()</span><br><span class="line">      <span class="keyword">for</span> i := <span class="keyword">range</span> ich &#123;</span><br><span class="line">         <span class="keyword">if</span> ctx.Err() != <span class="literal">nil</span> &#123;</span><br><span class="line">            fmt.Println(ctx.Err())</span><br><span class="line">            <span class="built_in">close</span>(stopCh)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">         &#125;</span><br><span class="line">         fmt.Println(i)</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Output:</span></span><br><span class="line"><span class="comment">// NumGoroutine: 2</span></span><br><span class="line"><span class="comment">// 0</span></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// ...(省略)...</span></span><br><span class="line"><span class="comment">// 789</span></span><br><span class="line"><span class="comment">// context deadline exceeded</span></span><br><span class="line"><span class="comment">// NumGoroutine: 2</span></span><br></pre></td></tr></table></figure><p>总之，通常情况下，我们只会遇到这两种 go channel 造成内存泄漏的情况（一个发送者导致的内存泄漏和多个发送者导致的内存泄漏）</p><p>不论发送者发送一次还是多次，如果接收者所在 goroutine 能够在接收完 channel 中的数据之后结束，那么就不会造成内存泄漏；或者说接收者能够在发送者停止发送后再结束，就不会造成内存泄露。</p><p>如果接收者需要在 channel 关闭之前提前退出，为防止内存泄漏，在发送者与接收者发送次数是一对一时，应设置 channel 缓冲队列为 1；在发送者与接收者的发送次数是多对多时，应使用专门的 stop channel 通知发送者关闭相应 channel</p><p>其实归根到底是一方不再对channel操作时没有向另一方发送信号，导致另一方阻塞，也就是说关闭channel的方式不对（并不特指close，包括不再操作由gc处理的情况），所以优雅关闭channel还是很重要的</p><h2 id="Channel应用"><a href="#Channel应用" class="headerlink" title="Channel应用"></a>Channel应用</h2><ol><li>停止信号（见优雅关闭channel）</li><li>定时任务（与timer结合）</li><li>实现超时控制</li><li>定期执行某个任务</li><li>解耦生产方和消费方</li><li>控制并发数</li></ol><p><strong>定时任务</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> &lt;-time.After(<span class="number">100</span> * time.Millisecond):</span><br><span class="line">    <span class="keyword">case</span> &lt;-s.stopc:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>等待 100 ms 后，如果 s.stopc 还没有读出数据或者被关闭，就直接结束。这是来自 etcd 源码里的一个例子，这样的写法随处可见。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">worker</span><span class="params">()</span></span> &#123;</span><br><span class="line">    ticker := time.Tick(<span class="number">1</span> * time.Second)</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">select</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> &lt;- ticker:</span><br><span class="line">            <span class="comment">// 执行定时任务</span></span><br><span class="line">            fmt.Println(<span class="string">&quot;执行 1s 定时任务&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每隔 1 秒种，执行一次定时任务。</p><p><strong>解耦生产方和消费方</strong></p><p>服务启动时，启动 n 个 worker，作为工作协程池，这些协程工作在一个 <code>for &#123;&#125;</code> 无限循环里，从某个 channel 消费工作任务并执行：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    taskCh := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">100</span>)</span><br><span class="line">    <span class="keyword">go</span> worker(taskCh)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 塞任务</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">        taskCh &lt;- i</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待 1 小时 </span></span><br><span class="line">    <span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> &lt;-time.After(time.Hour):</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">worker</span><span class="params">(taskCh &lt;-<span class="keyword">chan</span> <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">const</span> N = <span class="number">5</span></span><br><span class="line">    <span class="comment">// 启动 5 个工作协程</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; N; i++ &#123;</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(id <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">            <span class="keyword">for</span> &#123;</span><br><span class="line">                task := &lt;- taskCh</span><br><span class="line">                fmt.Printf(<span class="string">&quot;finish task: %d by worker %d\n&quot;</span>, task, id)</span><br><span class="line">                time.Sleep(time.Second)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;(i)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>5 个工作协程在不断地从工作队列里取任务，生产方只管往 channel 发送任务即可，解耦生产方和消费方。</p><p><strong>控制并发数</strong></p><p>有时需要定时执行几百个任务，例如每天定时按城市来执行一些离线计算的任务。但是并发数又不能太高，因为任务执行过程依赖第三方的一些资源，对请求的速率有限制。这时就可以通过 channel 来控制并发数。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> limit = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// …………</span></span><br><span class="line">    <span class="keyword">for</span> _, w := <span class="keyword">range</span> work &#123;</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            limit &lt;- <span class="number">1</span></span><br><span class="line">            w()</span><br><span class="line">            &lt;-limit</span><br><span class="line">        &#125;()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// …………</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul><li><a class="link"   href="https://juejin.cn/post/7033711399041761311" >详解 Go channel 内存泄漏问题<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://golang.design/go-questions" >Go 程序员面试笔试宝典<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://www.topgoer.com/" >go语言中文文档<i class="fas fa-external-link-alt"></i></a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;《&lt;a class=&quot;link&quot;   href=&quot;https://golang.design/go-questions&quot; &gt;Go 程序员面试笔试宝典&lt;i class=&quot;fas fa-external-link-alt&quot;&gt;&lt;/i&gt;&lt;/a&gt;》学习整理&lt;/p&gt;
&lt;h2 id=&quot;什</summary>
      
    
    
    
    <category term="uncategorized" scheme="https://tbghg.github.io/categories/uncategorized/"/>
    
    
    <category term="go" scheme="https://tbghg.github.io/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>剑指Offer II 刷题笔记（1）</title>
    <link href="https://tbghg.github.io/2022-11-06/179f9421b46d/"/>
    <id>https://tbghg.github.io/2022-11-06/179f9421b46d/</id>
    <published>2022-11-06T00:49:34.000Z</published>
    <updated>2022-11-06T00:49:34.000Z</updated>
    
    <content type="html"><![CDATA[<p>目前是二刷阶段，记录一下刷题的思路，记录下重点，方便以后复习，目前还没写多少，持续补充</p><h2 id="整数"><a href="#整数" class="headerlink" title="整数"></a>整数</h2><p>整数这里主要是位运算，常见知识点：</p><ol><li>对于一个数<code>num</code>，<code>num &gt;&gt; i &amp; 1</code>表示取第<code>i</code>位上的二进制值</li><li>设置<code>ans</code>二进制的第i位一般或运算：<code>ans = 1 &lt;&lt; i</code></li><li>异或两次后会自己抵消掉，相当于没干</li></ol><h3 id="004-只出现一次的数字"><a href="#004-只出现一次的数字" class="headerlink" title="004 只出现一次的数字"></a>004 只出现一次的数字</h3><p>一个整数数组 <code>nums</code> ，除某个元素仅出现 <strong>一次</strong> 外，其余每个元素都恰出现 <strong>三次</strong> 。请你找出并返回那个只出现了一次的元素。</p><ul><li><code>1 &lt;= nums.length &lt;= 3 * 104</code></li><li><code>-2^31 &lt;= nums[i] &lt;= 2^31 - 1</code></li></ul><h4 id="方法一：map遍历"><a href="#方法一：map遍历" class="headerlink" title="方法一：map遍历"></a>方法一：map遍历</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">func</span> <span class="title">singleNumber</span><span class="params">(nums []<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    freq := <span class="keyword">map</span>[<span class="type">int</span>]<span class="type">int</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> _, v := <span class="keyword">range</span> nums &#123;</span><br><span class="line">        freq[v]++</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> num, occ := <span class="keyword">range</span> freq &#123;</span><br><span class="line">        <span class="keyword">if</span> occ == <span class="number">1</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> num</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> <span class="comment">// 不会发生，数据保证有一个元素仅出现一次</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>时间复杂度：O(n)，其中 n 是数组的长度</li><li>空间复杂度：O(n)</li></ul><h4 id="方法二：依次确定二进制位"><a href="#方法二：依次确定二进制位" class="headerlink" title="方法二：依次确定二进制位"></a>方法二：依次确定二进制位</h4><p>最先想到的肯定是和3做一些变换，如果看每一个二进制的话，加起来然后与3取余，最后汇总就行了<br>go的话不像python，是不是有符号自己能定义，这点注意一下就行了</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">singleNumber</span><span class="params">(nums []<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    ans := <span class="type">int32</span>(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">32</span>; i++ &#123;</span><br><span class="line">        total := <span class="type">int32</span>(<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">for</span> _, num := <span class="keyword">range</span> nums &#123;</span><br><span class="line">            total += <span class="type">int32</span>(num) &gt;&gt; i &amp; <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> total%<span class="number">3</span> &gt; <span class="number">0</span> &#123;</span><br><span class="line">            ans = <span class="number">1</span> &lt;&lt; i</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">int</span>(ans)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="005-单词长度的最大乘积"><a href="#005-单词长度的最大乘积" class="headerlink" title="005 单词长度的最大乘积"></a>005 单词长度的最大乘积</h3><p>给定一个字符串数组 <code>words</code>，请计算当两个字符串 <code>words[i]</code> 和 <code>words[j]</code> 不包含相同字符时，它们长度的乘积的最大值。假设字符串中只包含英语的小写字母。如果没有不包含相同字符的一对字符串，返回 0。</p><p>很怪的题目，不过可以发现只包含小写字母，但是map又不太行，那就考虑位运算，把他们对应的整数做个<code>&amp;</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">maxProduct</span><span class="params">(words []<span class="type">string</span>)</span></span> (ans <span class="type">int</span>) &#123;</span><br><span class="line">    masks := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="built_in">len</span>(words))</span><br><span class="line">    <span class="keyword">for</span> i, word := <span class="keyword">range</span> words &#123;</span><br><span class="line">        <span class="keyword">for</span> _, ch := <span class="keyword">range</span> word &#123;</span><br><span class="line">            masks[i] = <span class="number">1</span> &lt;&lt; (ch - <span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> i, x := <span class="keyword">range</span> masks &#123;</span><br><span class="line">        <span class="keyword">for</span> j, y := <span class="keyword">range</span> masks[i:] &#123;</span><br><span class="line">            <span class="keyword">if</span> x&amp;y == <span class="number">0</span> &amp;&amp; <span class="built_in">len</span>(words[i])*<span class="built_in">len</span>(words[j]) &gt; ans &#123;</span><br><span class="line">                ans = <span class="built_in">len</span>(words[i]) * <span class="built_in">len</span>(words[j])</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="006-排序数组中两个数字之和"><a href="#006-排序数组中两个数字之和" class="headerlink" title="006 排序数组中两个数字之和"></a>006 排序数组中两个数字之和</h3><p>给定一个已按照 <strong>升序排列</strong> 的整数数组 <code>numbers</code> ，请你从数组中找出两个数满足相加之和等于目标数 <code>target</code><br>整数数组的形式返回答案，数组里放对应下标，增大的顺序<br>假设数组中存在且只存在一对符合条件的数字，同时一个数字不能使用两次</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：numbers = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">10</span>], target = <span class="number">8</span></span><br><span class="line">输出：[<span class="number">1</span>,<span class="number">3</span>]</span><br><span class="line">解释：<span class="number">2</span> 与 <span class="number">6</span> 之和等于目标数 <span class="number">8</span> 。因此 index1 = <span class="number">1</span>, index2 = <span class="number">3</span> </span><br></pre></td></tr></table></figure><h4 id="方法一：map"><a href="#方法一：map" class="headerlink" title="方法一：map"></a>方法一：map</h4><p>只有一对符合要求，遇事不决，map解决，但空间O(n)，并且数组已经排序而没用好这个性质</p><h4 id="方法二：双指针"><a href="#方法二：双指针" class="headerlink" title="方法二：双指针"></a>方法二：双指针</h4><p>头(<code>low</code>)尾(<code> `heigh</code>)一块出发，二者的和记为<code>sum</code>，如果比<code>target</code>小，<code>low++</code>，大的话<code>heigh--</code>，相等直接输出。for循环条件是<code>low&lt;heigh</code><br>比较难考虑的是会不会错过去，可以这样想，反正<code>low</code>和<code>heigh</code>肯定会有第一个先到答案的位置，这个时候另一个必须根据<code>sum</code>和<code>target</code>的比较做配合，最后肯定能到相应的地方。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">twoSum</span><span class="params">(numbers []<span class="type">int</span>, target <span class="type">int</span>)</span></span> []<span class="type">int</span> &#123;</span><br><span class="line">    low, high := <span class="number">0</span>, <span class="built_in">len</span>(numbers) - <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> low &lt; high &#123;</span><br><span class="line">        sum := numbers[low] + numbers[high]</span><br><span class="line">        <span class="keyword">if</span> sum == target &#123;</span><br><span class="line">            <span class="keyword">return</span> []<span class="type">int</span>&#123;low, high&#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> sum &lt; target &#123;</span><br><span class="line">            low++</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            high--</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> []<span class="type">int</span>&#123;<span class="number">-1</span>, <span class="number">-1</span>&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="方法三：二分查找"><a href="#方法三：二分查找" class="headerlink" title="方法三：二分查找"></a>方法三：二分查找</h4><p>时间复杂度：O(nlog⁡n)，其中 n 是数组的长度。需要遍历数组一次确定第一个数，时间复杂度是 O(n)，寻找第二个数使用二分查找，时间复杂度是 O(log⁡n)<br>空间复杂度：O(1)</p><p>复杂度这块不如双指针，主要还是练习一下二分，目前不细说二分</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">twoSum</span><span class="params">(numbers []<span class="type">int</span>, target <span class="type">int</span>)</span></span> []<span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(numbers); i++ &#123;</span><br><span class="line">        low, high := i + <span class="number">1</span>, <span class="built_in">len</span>(numbers) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> low &lt;= high &#123;</span><br><span class="line">            mid := (high - low) / <span class="number">2</span> + low</span><br><span class="line">            <span class="keyword">if</span> numbers[mid] == target - numbers[i] &#123;</span><br><span class="line">                <span class="keyword">return</span> []<span class="type">int</span>&#123;i, mid&#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> numbers[mid] &gt; target - numbers[i] &#123;</span><br><span class="line">                high = mid - <span class="number">1</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                low = mid + <span class="number">1</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> []<span class="type">int</span>&#123;<span class="number">-1</span>, <span class="number">-1</span>&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>这块就要寄出我曾经总结的东西了：<a class="link"   href="https://tbghg.top/index.php/2022/07/09/%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93-%E6%95%B0%E7%BB%84/" >算法总结——数组<i class="fas fa-external-link-alt"></i></a>，当初打算给大一写的，但似乎没啥人看，不过个人感觉很全面，主要参考的代码随想录</p><p>数组主要知识点：</p><ol><li>二分查找（莫得办法，多练）</li><li>前缀和（一维二维）：计算给定区间的和</li><li>差分（一维二维）：某一特定范围内的所有值都加上或减去一个常数</li><li>双指针</li><li>滑动窗口</li><li>螺旋矩阵（就是跟着逻辑来）</li></ol><p>建议先看我的算法总结(・∀・)ノ</p><h3 id="007-数组中和为-0-的三个数"><a href="#007-数组中和为-0-的三个数" class="headerlink" title="007 数组中和为 0 的三个数"></a>007 数组中和为 0 的三个数</h3><p>【典型的双指针】</p><p>给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c &#x3D; 0 ？请你找出所有满足条件且不重复的三元组。</p><p><strong>注意：</strong> 答案中不可以包含重复的三元组。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">示例：</span><br><span class="line">给定数组 nums = [-1, 0, 1, 2, -1, -4]，</span><br><span class="line">满足要求的三元组集合为： [ [-1, 0, 1], [-1, -1, 2] ]</span><br></pre></td></tr></table></figure><p><strong>思路</strong>：先排序，固定一个，另外俩双指针。</p><p><strong>注意点</strong>：</p><ol><li>但是固定的那个需要考虑去重，去重为了防止把之后的撅了，可以去和前一个比较</li><li>因为双指针遍历时碰到的答案不止一个，所以碰到正解后装入ans，left++（right–也行，反正就是离开舒适区），但是因为要去重，所以<code>for l &lt; r &amp;&amp; nums[l] == n2</code>内进行<code>l++</code>（n2指之前的nums[l]）</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">threeSum</span><span class="params">(nums []<span class="type">int</span>)</span></span> (ans [][]<span class="type">int</span>) &#123;</span><br><span class="line">    sort.Ints(nums)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span> ; i &lt; <span class="built_in">len</span>(nums)<span class="number">-2</span> ; i++ &#123;</span><br><span class="line">        <span class="keyword">if</span> nums[i] &gt; <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i<span class="number">-1</span>] &#123;</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line">        l,r := i+<span class="number">1</span>,<span class="built_in">len</span>(nums)<span class="number">-1</span></span><br><span class="line">        n1 := nums[i]</span><br><span class="line">        <span class="keyword">for</span> l&lt;r &#123;</span><br><span class="line">            n2,n3 := nums[l],nums[r]</span><br><span class="line">            sum := n1+n2+n3</span><br><span class="line">            <span class="keyword">if</span> sum == <span class="number">0</span> &#123;</span><br><span class="line">                ans = <span class="built_in">append</span>(ans,[]<span class="type">int</span>&#123;n1,n2,n3&#125;)</span><br><span class="line">                <span class="keyword">for</span> l &lt; r &amp;&amp; nums[l] == n2 &#123;</span><br><span class="line">                    l++</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> sum &gt; <span class="number">0</span> &#123;</span><br><span class="line">                r--</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                l++</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="008-和大于等于-target-的最短子数组"><a href="#008-和大于等于-target-的最短子数组" class="headerlink" title="008 和大于等于 target 的最短子数组"></a>008 和大于等于 target 的最短子数组</h3><p>给定一个含有 <code>n</code> 个正整数的数组和一个正整数 <code>target</code> <strong>。</strong></p><p>找出该数组中满足其和 <code>≥ target</code> 的长度最小的 <strong>连续子数组</strong> <code>[numsl, numsl+1, ..., numsr-1, numsr]</code> ，并返回其长度<strong>。</strong>如果不存在符合条件的子数组，返回 <code>0</code> 。</p><h2 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h2><p><a class="link"   href="https://tbghg.top/index.php/2022/07/09/%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93-%E6%95%B0%E7%BB%84/" >算法总结——数组<i class="fas fa-external-link-alt"></i></a>，当初总结的，二分查找模块挺细的</p><p><code>left&lt;right</code>时，一般<code>left=mid+1</code>，<code>right=mid</code>，而不是<code>left=mid</code>，<code>right=mid-1</code>，要不容易出现死循环</p><h3 id="068-查找插入位置"><a href="#068-查找插入位置" class="headerlink" title="068 查找插入位置"></a>068 查找插入位置</h3><p>给定一个排序的整数数组 <code>nums</code> 和一个整数目标值<code>target</code> ，请在数组中找到 <code>target</code>，并返回其下标。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。</p><p>请必须使用时间复杂度为 <code>O(log n)</code> 的算法。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">searchInsert</span><span class="params">(nums []<span class="type">int</span>, target <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    left, right := <span class="number">0</span>, <span class="built_in">len</span>(nums)<span class="number">-1</span></span><br><span class="line">    mid := (left + right) / <span class="number">2</span></span><br><span class="line">    <span class="keyword">for</span> left &lt;= right &#123;</span><br><span class="line">        <span class="keyword">if</span> nums[mid] == target &#123;</span><br><span class="line">            <span class="keyword">return</span> mid</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> nums[mid] &lt; target &#123;</span><br><span class="line">            left++</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            right--</span><br><span class="line">        &#125;</span><br><span class="line">        mid = (left + right) / <span class="number">2</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> left</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="069-山峰数组的顶部"><a href="#069-山峰数组的顶部" class="headerlink" title="069 山峰数组的顶部"></a>069 山峰数组的顶部</h3><p>符合下列属性的数组 <code>arr</code> 称为 <strong>山峰数组</strong>（<strong>山脉数组）</strong> ：</p><ul><li><code>arr.length &gt;= 3</code></li><li>存在i(<code>0 &lt; i &lt; arr.length - 1</code>)</li><li><code>arr[0] &lt; arr[1] &lt; ... arr[i-1] &lt; arr[i]</code></li><li><code>arr[i] &gt; arr[i+1] &gt; ... &gt; arr[arr.length - 1]</code></li></ul><p>给定由整数组成的山峰数组 <code>arr</code> ，返回任何满足 <code>arr[0] &lt; arr[1] &lt; ... arr[i - 1] &lt; arr[i] &gt; arr[i + 1] &gt; ... &gt; arr[arr.length - 1]</code> 的下标 <code>i</code> ，即山峰顶部。</p><ul><li><code>3 &lt;= arr.length &lt;= 104</code></li><li><code>0 &lt;= arr[i] &lt;= 106</code></li><li>题目数据保证 <code>arr</code> 是一个山脉数组</li></ul><p>虽然形式变了，但是我们可以变换比较方式，还是用二分查找，left&lt;&#x3D;right时最后return是什么可能不太好理解，最好自己找些数对比对比就出来了，当然最好还是left&lt;right，把区间当成左闭右开，这样直接无脑返回右就行了（但其实左右是相等的）</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">peakIndexInMountainArray</span><span class="params">(arr []<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    left, right := <span class="number">0</span>,<span class="built_in">len</span>(arr)<span class="number">-2</span></span><br><span class="line">    mid := (left+right)&gt;&gt;<span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> left &lt;= right &#123;</span><br><span class="line">        <span class="keyword">if</span> arr[mid] &lt; arr[mid+<span class="number">1</span>] &#123;</span><br><span class="line">            left = mid + <span class="number">1</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            right = mid - <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">        mid = (left+right)&gt;&gt;<span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> left</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>sort.search</code>使用模板<br><code>index := sort.Search(n int,f func(i int) bool) int</code><br>使用二分查找的方法，会从[0, n)中取出一个值index，index为[0, n)中最小的使函数f(index)为True的值，并且f(index+1)也为True<br>如果无法找到该index值，则该方法为返回n</p><p>例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    a := []<span class="type">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;</span><br><span class="line">    d := sort.Search(<span class="built_in">len</span>(a), <span class="function"><span class="keyword">func</span><span class="params">(i <span class="type">int</span>)</span></span> <span class="type">bool</span> &#123; <span class="keyword">return</span> a[i]&gt;=<span class="number">3</span>&#125;)</span><br><span class="line">    fmt.Println(d)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// output 2</span></span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用sort.search的做法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">peakIndexInMountainArray</span><span class="params">(arr []<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> sort.Search(<span class="built_in">len</span>(arr)<span class="number">-1</span>, <span class="function"><span class="keyword">func</span><span class="params">(i <span class="type">int</span>)</span></span> <span class="type">bool</span> &#123; <span class="keyword">return</span> arr[i] &gt; arr[i+<span class="number">1</span>] &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="070-排序数组中只出现一次的数字"><a href="#070-排序数组中只出现一次的数字" class="headerlink" title="070 排序数组中只出现一次的数字"></a>070 排序数组中只出现一次的数字</h3><p>给定一个只包含整数的有序数组 <code>nums</code> ，每个元素都会出现两次，唯有一个数只会出现一次，请找出这个唯一的数字。</p><p>你设计的解决方案必须满足 <code>O(log n)</code> 时间复杂度和 <code>O(1)</code> 空间复杂度。</p><h4 id="方法一：全数组的二分查找"><a href="#方法一：全数组的二分查找" class="headerlink" title="方法一：全数组的二分查找"></a>方法一：全数组的二分查找</h4><p>相对好想一些，这个是保证每次比较时根据索引与对应的位置比较</p><ul><li>如果 mid 是偶数，则比较 nums[mid] 和 nums[mid+1] 是否相等；</li><li>如果 mid 是奇数，则比较 nums[mid−1] 和 nums[mid] 是否相等。</li></ul><p>利用按位异或的性质，可以得到 mid 和相邻的数之间的如下关系，其中 ⊕ 是按位异或运算符：</p><ul><li>当 mid 是偶数时，mid+1&#x3D;mid⊕1；</li><li>当 mid 是奇数时，mid−1&#x3D;mid⊕1。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">singleNonDuplicate</span><span class="params">(nums []<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    low, high := <span class="number">0</span>, <span class="built_in">len</span>(nums)<span class="number">-1</span></span><br><span class="line">    <span class="keyword">for</span> low &lt; high &#123;</span><br><span class="line">        mid := low + (high-low)/<span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> nums[mid] == nums[mid^<span class="number">1</span>] &#123;</span><br><span class="line">            low = mid + <span class="number">1</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            high = mid</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nums[low]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="方法二：偶数下标的二分查找"><a href="#方法二：偶数下标的二分查找" class="headerlink" title="方法二：偶数下标的二分查找"></a>方法二：偶数下标的二分查找</h4><p>保证索引都是偶数，每次比较直接与+1位置比较</p><p>通过<code>mid -= mid &amp; 1</code>保证mid每次变为偶数</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">singleNonDuplicate</span><span class="params">(nums []<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    low, high := <span class="number">0</span>, <span class="built_in">len</span>(nums)<span class="number">-1</span></span><br><span class="line">    <span class="keyword">for</span> low &lt; high &#123;</span><br><span class="line">        mid := low + (high-low)/<span class="number">2</span></span><br><span class="line">        mid -= mid &amp; <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> nums[mid] == nums[mid+<span class="number">1</span>] &#123;</span><br><span class="line">            low = mid + <span class="number">2</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            high = mid</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nums[low]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="071-按权重生成随机数"><a href="#071-按权重生成随机数" class="headerlink" title="071 按权重生成随机数"></a>071 按权重生成随机数</h3><p>给定一个正整数数组 <code>w</code> ，其中 <code>w[i]</code> 代表下标 <code>i</code> 的权重（下标从 <code>0</code> 开始），请写一个函数 <code>pickIndex</code> ，它可以随机地获取下标 <code>i</code>，选取下标 <code>i</code> 的概率与 <code>w[i]</code> 成正比。</p><p>例如，对于 <code>w = [1, 3]</code>，挑选下标 <code>0</code> 的概率为 <code>1 / (1 + 3) = 0.25</code> （即，25%），而选取下标 <code>1</code> 的概率为 <code>3 / (1 + 3) = 0.75</code>（即，75%）。</p><p>也就是说，选取下标 <code>i</code> 的概率为 <code>w[i] / sum(w)</code></p><h4 id="方法：前缀和-二分查找"><a href="#方法：前缀和-二分查找" class="headerlink" title="方法：前缀和 + 二分查找"></a>方法：前缀和 + 二分查找</h4><p>我人傻了，这思路，咋想出来的</p><p>例如[3,1,2,4]，求前缀和[3,4,6,10]，然后随机数落在1-10十个数之间，记这个数为x，再看看大于等于x的第一个位置是哪里，例如x&#x3D;2，落在了1-2-3之间，所以3是选择的数。因为前缀和有序，且要查找第一个比x大的数，所以用二分查找。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Solution <span class="keyword">struct</span> &#123;</span><br><span class="line">    preSum []<span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Constructor</span><span class="params">(w []<span class="type">int</span>)</span></span> Solution &#123;</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">1</span>;i&lt;<span class="built_in">len</span>(w);i++ &#123;</span><br><span class="line">        w[i] += w[i<span class="number">-1</span>]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Solution&#123;w&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自己实现二分查找</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Solution)</span></span> PickIndex() <span class="type">int</span> &#123;</span><br><span class="line">    target := rand.Intn(s.preSum[<span class="built_in">len</span>(s.preSum)<span class="number">-1</span>]) + <span class="number">1</span></span><br><span class="line">    left,right := <span class="number">0</span>,<span class="built_in">len</span>(s.preSum)<span class="number">-1</span></span><br><span class="line">    mid := (left+right)&gt;&gt;<span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> left &lt; right &#123;</span><br><span class="line">        <span class="keyword">if</span> s.preSum[mid] == target &#123;</span><br><span class="line">            <span class="keyword">return</span> mid</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> s.preSum[mid] &lt; target &#123;</span><br><span class="line">            left = mid + <span class="number">1</span> </span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            right = mid</span><br><span class="line">        &#125;</span><br><span class="line">        mid = (left+right)&gt;&gt;<span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> left</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 调用sort.SearchInts进行二分查找</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Solution)</span></span> PickIndex() <span class="type">int</span> &#123;</span><br><span class="line">    target := rand.Intn(s.preSum[<span class="built_in">len</span>(s.preSum)<span class="number">-1</span>]) + <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> sort.SearchInts(s.preSum,target)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="072-求平方根"><a href="#072-求平方根" class="headerlink" title="072 求平方根"></a>072 求平方根</h3><p>给定一个非负整数 <code>x</code> ，计算并返回 <code>x</code> 的平方根，即实现 <code>int sqrt(int x)</code> 函数<br>正数的平方根有两个，只输出其中的正数平方根<br>如果平方根不是整数，输出只保留整数的部分，小数部分将被舍去</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注意：要返回的是平方小于或等于x的第一个数</span></span><br><span class="line"><span class="comment">// 如果找不到合适的：</span></span><br><span class="line"><span class="comment">// left: 乘积大于x    right: 乘积小于x</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mySqrt</span><span class="params">(x <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    left,right := <span class="number">0</span>,x</span><br><span class="line">    mid := (left+right)&gt;&gt;<span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> left &lt;= right &#123;</span><br><span class="line">        value := mid * mid</span><br><span class="line">        <span class="keyword">if</span> value == x &#123;</span><br><span class="line">            <span class="keyword">return</span> mid</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> value &lt; x &#123;</span><br><span class="line">            left = mid + <span class="number">1</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            right = mid - <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">        mid = (left+right)&gt;&gt;<span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> right</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="073-狒狒吃香蕉"><a href="#073-狒狒吃香蕉" class="headerlink" title="073 狒狒吃香蕉"></a>073 狒狒吃香蕉</h3><p>狒狒喜欢吃香蕉。这里有 <code>n</code> 堆香蕉，第 <code>i</code> 堆中有 <code>piles[i]</code> 根香蕉。警卫已经离开了，将在 <code>h</code> 小时后回来。</p><p>狒狒可以决定她吃香蕉的速度 <code>k</code> （单位：根&#x2F;小时）。每个小时，她将会选择一堆香蕉，从中吃掉 <code>k</code> 根。如果这堆香蕉少于 <code>k</code> 根，她将吃掉这堆的所有香蕉，然后这一小时内不会再吃更多的香蕉，下一个小时才会开始吃另一堆的香蕉。</p><p>狒狒喜欢慢慢吃，但仍然想在警卫回来前吃掉所有的香蕉。</p><p>返回她可以在 <code>h</code> 小时内吃掉所有香蕉的最小速度 <code>k</code>（<code>k</code> 为整数）。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;目前是二刷阶段，记录一下刷题的思路，记录下重点，方便以后复习，目前还没写多少，持续补充&lt;/p&gt;
&lt;h2 id=&quot;整数&quot;&gt;&lt;a href=&quot;#整数&quot; class=&quot;headerlink&quot; title=&quot;整数&quot;&gt;&lt;/a&gt;整数&lt;/h2&gt;&lt;p&gt;整数这里主要是位运算，常见知识点：&lt;/</summary>
      
    
    
    
    <category term="uncategorized" scheme="https://tbghg.github.io/categories/uncategorized/"/>
    
    
    <category term="算法" scheme="https://tbghg.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>只出现一次的数字(Leetcode)</title>
    <link href="https://tbghg.github.io/2022-10-14/002cfb2c0c82/"/>
    <id>https://tbghg.github.io/2022-10-14/002cfb2c0c82/</id>
    <published>2022-10-14T04:13:52.000Z</published>
    <updated>2022-10-14T04:13:52.000Z</updated>
    
    <content type="html"><![CDATA[<p>刷这道<a class="link"   href="https://leetcode.cn/problems/single-number-ii/description/" >137. 只出现一次的数字 II<i class="fas fa-external-link-alt"></i></a>的时候，因为最近刚把redis学了，所以第一反应是<code>Bitmap</code>，虽然一开始就跑偏了，但还是学到了一些东西</p><p>首先是golang实现<code>Bitmap</code>，可以参考下面<a class="link"   href="https://blog.csdn.net/diu_brother/article/details/83032121" >这篇文章<i class="fas fa-external-link-alt"></i></a>，写的还是很详细的，也有代码，注意判断该位是否存在时<code>(bitmap.words[word]&amp;(1&lt;&lt;bit)) != 0</code>不要想当然把<code>()!=0</code>改为<code>()==1</code>。当这一位存在时，会一位与运算而只剩下这一位，也就是非0，但并不一定是1。当然也可以选择<code>bitmap</code>右移<code>( (bitmap.words[word]&gt;&gt;bit) &amp; 1 ) != 0</code>这种的话就肯定是1或0了</p><p>另外这个既然是一个系列，就全做了做，<a class="link"   href="https://leetcode.cn/problems/single-number/" >136. 只出现一次的数字<i class="fas fa-external-link-alt"></i></a>，其他的数字出现了两次，这道题相对简单，<code>A^A=0, 0^A=A</code>，那么我们只需要把所有数都进行异或，成对的会自然变为0，剩下的就是答案了</p><p>然后回到出现三次的题目，答案的第二种方法还是很巧妙的，直接与3求余判断出现次数，但对于go来说要注意<code>int</code>一般是64位的（看电脑），如果我们用64位的数字，并且i只遍历到32位会导致符号位没法算上，也就是负数为答案的情况下会出错，可以考虑统一换成32位的，也可以让i遍历到64位。</p><p>至于第三题<a class="link"   href="https://leetcode.cn/problems/single-number-iii/" >只出现一次的数字 III<i class="fas fa-external-link-alt"></i></a>，第一个题解<a class="link"   href="https://leetcode.cn/problems/single-number-iii/solutions/6620/cai-yong-fen-zhi-de-si-xiang-jiang-wen-ti-jiang-we/" >采用分治的思想将问题降维<i class="fas fa-external-link-alt"></i></a>就很巧妙，主要就是把二者分开，转换为136题这种。</p><p>另外记录一下，计算机在进行位运算时是按照补码进行计算的。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;刷这道&lt;a class=&quot;link&quot;   href=&quot;https://leetcode.cn/problems/single-number-ii/description/&quot; &gt;137. 只出现一次的数字 II&lt;i class=&quot;fas fa-external-link-al</summary>
      
    
    
    
    <category term="uncategorized" scheme="https://tbghg.github.io/categories/uncategorized/"/>
    
    
    <category term="leetcode" scheme="https://tbghg.github.io/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>Go 为什么不能defer recover()</title>
    <link href="https://tbghg.github.io/2022-09-06/6f91b7bb6111/"/>
    <id>https://tbghg.github.io/2022-09-06/6f91b7bb6111/</id>
    <published>2022-09-06T07:07:24.000Z</published>
    <updated>2022-09-06T07:07:24.000Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main  </span><br><span class="line">​  </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    test1()  </span><br><span class="line">    <span class="comment">//test2()  </span></span><br><span class="line">&#125;  </span><br><span class="line">​  </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test1</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    <span class="keyword">defer</span> <span class="built_in">recover</span>()  </span><br><span class="line">    <span class="built_in">panic</span>(<span class="string">&quot;panic error!&quot;</span>)  </span><br><span class="line">&#125;  </span><br><span class="line">​  </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test2</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    <span class="keyword">defer</span> fmt.Println(<span class="built_in">recover</span>())  </span><br><span class="line">    <span class="built_in">panic</span>(<span class="string">&quot;panic error!&quot;</span>)  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>依次执行test1和test2，发现这两种形式均无法捕获panic，但就是不太理解，查阅一些资料后还是云里雾里，打算抛砖引玉，先说一下自己的看法</p><h2 id="test1"><a href="#test1" class="headerlink" title="test1()"></a>test1()</h2><p>然后是test1中的<code>recover()</code></p><blockquote><p>参考：</p><p><a href="https://stackoverflow.com/questions/29518109/why-does-defer-recover-not-catch-panics">Why does <code>defer recover()</code> not catch panics?</a></p><p><a class="link"   href="https://cloud.tencent.com/developer/article/1074629#:~:text=Go,%E7%9A%84%E5%86%85%E7%BD%AE%E5%87%BD%E6%95%B0%E4%B8%8D%E6%8B%A5%E6%9C%89%E5%89%8D%E9%9D%A2%E6%8F%90%E5%88%B0%E7%9A%84go%E7%9A%84%E6%A0%87%E5%87%86%E7%B1%BB%E5%9E%8B%EF%BC%8C%E5%9B%A0%E6%AD%A4%E5%86%85%E7%BD%AE%E5%87%BD%E6%95%B0%E4%B8%8D%E8%83%BD%E4%BD%9C%E4%B8%BA%E4%B8%80%E4%B8%AA%E5%87%BD%E6%95%B0%E5%80%BC%E8%B5%8B%E5%80%BC%E7%BB%99%E5%87%BD%E6%95%B0%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%8F%98%E9%87%8F%E3%80%82" >go 内置函数<i class="fas fa-external-link-alt"></i></a></p></blockquote><p>总结：defer后面的表达式必须是函数或方法调用；不能用括号括起来。内置函数的调用与表达式语句会受到限制。而<code>recover()</code>为内置函数</p><h2 id="test2"><a href="#test2" class="headerlink" title="test2()"></a>test2()</h2><p>但是如果按照刚刚的猜测test2那不应该能捕获吗？笔者一开始是这样想的，后来意识到是defer中<code>recover()</code>作为参数，所以先将<code>recover()</code>的值计算出来，由于还没有遇到panic，所以直接<code>nil</code>传过去，最后直接打印出来。</p><p>笔者并不太清楚上面的理解是否正确，求大佬指点</p>]]></content>
    
    
      
      
    <summary type="html">&lt;figure class=&quot;highlight go&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;l</summary>
      
    
    
    
    <category term="uncategorized" scheme="https://tbghg.github.io/categories/uncategorized/"/>
    
    
    <category term="go" scheme="https://tbghg.github.io/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>leetcode 打家劫舍 II 评论探讨</title>
    <link href="https://tbghg.github.io/2022-08-27/09d098de70c9/"/>
    <id>https://tbghg.github.io/2022-08-27/09d098de70c9/</id>
    <published>2022-08-27T02:40:27.000Z</published>
    <updated>2022-08-27T02:40:27.000Z</updated>
    
    <content type="html"><![CDATA[<p>笔者打家劫舍时碰见碰见了个问题，记录一下，leetcode上的</p><p>题目：<a class="link"   href="https://leetcode.cn/problems/house-robber-ii/" >213. 打家劫舍 II<i class="fas fa-external-link-alt"></i></a></p><p>你是一个专业的小偷，计划偷窃沿街的房屋，每间房内都藏有一定的现金。这个地方所有的房屋都 围成一圈 ，这意味着第一个房屋和最后一个房屋是紧挨着的。同时，相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警 。</p><p>给定一个代表每个房屋存放金额的非负整数数组，计算你 在不触动警报装置的情况下 ，今晚能够偷窃到的最高金额。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">2</span>,<span class="number">3</span>,<span class="number">2</span>]</span><br><span class="line">输出：<span class="number">3</span></span><br><span class="line">解释：你不能先偷窃 <span class="number">1</span> 号房屋（金额 = <span class="number">2</span>），然后偷窃 <span class="number">3</span> 号房屋（金额 = <span class="number">2</span>）, 因为他们是相邻的。</span><br><span class="line"></span><br><span class="line">输入：nums = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>]</span><br><span class="line">输出：<span class="number">4</span></span><br><span class="line">解释：你可以先偷窃 <span class="number">1</span> 号房屋（金额 = <span class="number">1</span>），然后偷窃 <span class="number">3</span> 号房屋（金额 = <span class="number">3</span>）。</span><br><span class="line">&amp;nbsp;    偷窃到的最高金额 = <span class="number">1</span> + <span class="number">3</span> = <span class="number">4</span> 。</span><br><span class="line"></span><br><span class="line">输入：nums = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">输出：<span class="number">3</span></span><br></pre></td></tr></table></figure><p>这题官方给出的解法如下：假设数组 nums 的长度为 n。如果不偷窃最后一间房屋，则偷窃房屋的下标范围是 [0, n-2] [0,n−2]；如果不偷窃第一间房屋，则偷窃房屋的下标范围是 [1, n-1] [1,n−1]。在确定偷窃房屋的下标范围之后，即可用第 198 题的方法解决。对于两段下标范围分别计算可以偷窃到的最高总金额，其中的最大值即为在 n 间房屋中可以偷窃到的最高总金额。</p><p>评论区有个发言：感觉有点问题。如果把所有情况分为偷窃第一间房和偷窃最后一间房逻辑上有点说不过去。因为，当偷窃第一间房的时候，官方解答将问题转化为了[0, n-1]求最大收益的问题，这显然并没有保证第一间房被偷，和最开始的假设相矛盾。我觉得问题出在把所有情况分为偷窃第一间房和偷窃最后一间房这里。事实上，有可能存在两个房间都不偷的情况，如[1,10000,1]。更严谨地说，应该把问题分为可以偷第一件房和可以偷最后一件房这两种情况。不可能有这两种情况之外的第三种情况。当可以偷第一间房的时候，我们当然可以理直气壮地把问题转换为[0, n-1]求最大收益的问题。</p><p>一开始觉得很有道理，认为是官方这里出了些问题，后来发现俩好像在各说个的，所以都对。</p><p>首先题目的解肯定是第一间和最后一间至少有一个没偷，而官方给出的确实是这样，分为了不偷最后一间、不偷第一间，那这里得出的最优解肯定就是答案，当然也有人用集合的方式给出了<a class="link"   href="https://leetcode.cn/problems/house-robber-ii/solution/dui-yu-guan-fang-ti-jie-de-bu-chong-zhen-u4uv/" >补充证明<i class="fas fa-external-link-alt"></i></a>。而评论的话似乎把官方误认为分为偷第一间、不偷第一间这种了，所以觉得官方少了第一间和最后一间都不偷。</p><p>好家伙，算法题我咋在这里分析语文了。行了，不说了，接着刷去了</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;笔者打家劫舍时碰见碰见了个问题，记录一下，leetcode上的&lt;/p&gt;
&lt;p&gt;题目：&lt;a class=&quot;link&quot;   href=&quot;https://leetcode.cn/problems/house-robber-ii/&quot; &gt;213. 打家劫舍 II&lt;i class=&quot;f</summary>
      
    
    
    
    <category term="uncategorized" scheme="https://tbghg.github.io/categories/uncategorized/"/>
    
    
    <category term="算法" scheme="https://tbghg.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Golang defer与闭包</title>
    <link href="https://tbghg.github.io/2022-08-15/d0ca8e9fa6d7/"/>
    <id>https://tbghg.github.io/2022-08-15/d0ca8e9fa6d7/</id>
    <published>2022-08-15T11:27:11.000Z</published>
    <updated>2022-08-15T11:27:11.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h2><p>先来看俩程序</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> whatever [<span class="number">5</span>]<span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> whatever &#123;</span><br><span class="line">        <span class="keyword">defer</span> fmt.Println(i)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 结果：4 3 2 1 0</span></span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 闭包状态下</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> whatever [<span class="number">5</span>]<span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> whatever &#123;</span><br><span class="line">        <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; fmt.Println(i) &#125;()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 结果：4 4 4 4 4</span></span><br></pre></td></tr></table></figure><p>这俩个程序区别在于一个直接调用输出，一个闭包输出，但结果却天差地别，下面深入了解下defer与闭包的关系</p><p>（PS：答案写在后记里了 :）</p><h2 id="defer介绍"><a href="#defer介绍" class="headerlink" title="defer介绍"></a>defer介绍</h2><p>defer特性</p><ol><li>关键字 defer 用于注册延迟调用。</li><li>这些调用直到 return 前才被执。因此，可以用来做资源清理。</li><li>多个defer语句，按先进后出的方式执行。</li><li>defer语句中的变量，在defer声明时就决定了。</li></ol><p>defer用途</p><ol><li>关闭文件句柄</li><li>锁资源释放</li><li>数据库连接释放</li></ol><h2 id="defer执行顺序"><a href="#defer执行顺序" class="headerlink" title="defer执行顺序"></a>defer执行顺序</h2><p>定义defer的时，会先将defer后面的<strong>调用的函数的参数入栈</strong>，在return<strong>右侧的参数或函数值计算完成</strong>后<strong>调用defer</strong>，此时defer的<strong>函数参数出栈</strong>执行，defer执行完成后<strong>执行return</strong></p><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><p><a class="link"   href="https://juejin.cn/post/7075261336778702862" >出处<i class="fas fa-external-link-alt"></i></a></p><p>例题一</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">(x, y <span class="type">int</span>)</span></span> (z <span class="type">int</span>) &#123;</span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="built_in">println</span>(z+<span class="number">9</span>) <span class="comment">// 输出: 212</span></span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    z = x + y</span><br><span class="line">    <span class="keyword">return</span> z + <span class="number">200</span> <span class="comment">// 执行顺序: (z = z + 200) -&gt; (call defer) -&gt; (return)</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="built_in">println</span>(add1(<span class="number">1</span>, <span class="number">2</span>)) <span class="comment">// 输出: 203</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 结果：212 203</span></span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add2</span><span class="params">(x, y <span class="type">int</span>)</span></span> (z <span class="type">int</span>) &#123;</span><br><span class="line">    <span class="keyword">defer</span> <span class="built_in">println</span>(z + <span class="number">9</span>) <span class="comment">// 输出: 9</span></span><br><span class="line">    z = x + y</span><br><span class="line">    <span class="keyword">return</span> z + <span class="number">200</span> <span class="comment">// 执行顺序: (z = z + 200) -&gt; (call defer) -&gt; (return)</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="built_in">println</span>(add2(<span class="number">1</span>, <span class="number">2</span>)) <span class="comment">// 输出: 203</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 结果：9 203</span></span><br></pre></td></tr></table></figure><p>例题二</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(a())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">a</span><span class="params">()</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> i <span class="type">int</span></span><br><span class="line">    <span class="keyword">defer</span> add(i) <span class="comment">//延迟调用add()，在程序计数器走到defer时，会把defer右边最外层函数的参数计算完毕，也就是此时的i是多少就是多少</span></span><br><span class="line">    i += <span class="number">100</span></span><br><span class="line">    <span class="keyword">return</span> i</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">(i <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    i += <span class="number">1</span></span><br><span class="line">    fmt.Println(i)</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// 结果：1 100</span></span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(b())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">b</span><span class="params">()</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> i <span class="type">int</span></span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        add(i) <span class="comment">//可以理解为传的是i的指针，&#123;&#125;里面的函数体入栈，i此时不计算，最后是什么就是什么</span></span><br><span class="line">    &#125;()</span><br><span class="line">    i += <span class="number">100</span></span><br><span class="line">    <span class="keyword">return</span> i <span class="comment">//return 之前运行defer，此时的defer里面的i是100，调用add变为101</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">(i <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    i += <span class="number">1</span></span><br><span class="line">    fmt.Println(i)</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>在定义defer的时候，就要将defer后面的函数参数等入栈，等到return之前的时候出栈执行，<strong>a方法中是将i的拷贝直接入栈，b方法中通过一个闭包调用，实际上将i的指针传递给闭包，闭包读取值拷贝给add。</strong></p><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>回到一开始给出的两个程序，首先我们应该清楚for-range循环中i的地址是保持不变的，在非闭包的情况下，将值压入栈中进行保存，所以最后输出顺序为4 3 2 1 0，但在闭包条件下，右侧函数参数为空，i保存的为for中i的地址，由于i的值一直在改变，所以最后调用时打印出来的值均为最后的值4，即：4 4 4 4 4</p><p>参考文章：</p><ul><li><a class="link"   href="https://www.topgoer.com/%E5%87%BD%E6%95%B0/%E5%BB%B6%E8%BF%9F%E8%B0%83%E7%94%A8defer.html" >延迟调用（defer）<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://juejin.cn/post/7075261336778702862" >Golang 中的闭包和defer<i class="fas fa-external-link-alt"></i></a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;引入&quot;&gt;&lt;a href=&quot;#引入&quot; class=&quot;headerlink&quot; title=&quot;引入&quot;&gt;&lt;/a&gt;引入&lt;/h2&gt;&lt;p&gt;先来看俩程序&lt;/p&gt;
&lt;figure class=&quot;highlight go&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;</summary>
      
    
    
    
    <category term="uncategorized" scheme="https://tbghg.github.io/categories/uncategorized/"/>
    
    
    <category term="go" scheme="https://tbghg.github.io/tags/go/"/>
    
    <category term="Golang" scheme="https://tbghg.github.io/tags/Golang/"/>
    
  </entry>
  
  <entry>
    <title>MySQL中datetime与timestamp区别</title>
    <link href="https://tbghg.github.io/2022-07-18/423ccffdab26/"/>
    <id>https://tbghg.github.io/2022-07-18/423ccffdab26/</id>
    <published>2022-07-18T12:58:37.000Z</published>
    <updated>2022-07-18T12:58:37.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、占用空间"><a href="#一、占用空间" class="headerlink" title="一、占用空间"></a>一、占用空间</h2><table><thead><tr><th align="center">类型</th><th align="center">占据字节</th><th align="center">表示形式</th></tr></thead><tbody><tr><td align="center">datetime</td><td align="center">8 字节</td><td align="center">yyyy-mm-dd hh:mm:ss</td></tr><tr><td align="center">timestamp</td><td align="center">4 字节</td><td align="center">yyyy-mm-dd hh:mm:ss</td></tr></tbody></table><h2 id="二、范围"><a href="#二、范围" class="headerlink" title="二、范围"></a>二、范围</h2><table><thead><tr><th align="center">类型</th><th align="center">表示范围</th></tr></thead><tbody><tr><td align="center">datetime</td><td align="center">‘1000-01-01 00:00:00.000000’ to ‘9999-12-31 23:59:59.999999’</td></tr><tr><td align="center">timestamp</td><td align="center">‘1970-01-01 00:00:01.000000’ to ‘2038-01-19 03:14:07.999999’</td></tr></tbody></table><p>timestamp翻译为汉语即”时间戳”，它是当前时间到 Unix元年(1970 年 1 月 1 日 0 时 0 分 0 秒)的秒数。对于某些时间的计算，如果是以 datetime 的形式会比较困难，假如我是 1994-1-20 06:06:06 出生，现在的时间是 2016-10-1 20:04:50 ，那么要计算我活了多少秒钟用 datetime 还需要函数进行转换，但是 timestamp 直接相减就行。</p><h2 id="三、时区"><a href="#三、时区" class="headerlink" title="三、时区"></a>三、时区</h2><p>timestamp 会是把客户端插入的时间从当前时区转化为UTC（世界标准时间）进行存储</p><p>datetime 不会进行时区的检索</p><p>也就是说，对于timestamp来说，如果储存时的时区和检索时的时区不一样，那么拿出来的数据也不一样。对于datetime来说，存什么拿到的就是什么。</p><h2 id="四、默认值"><a href="#四、默认值" class="headerlink" title="四、默认值"></a>四、默认值</h2><p>如果存进去的是NULL，timestamp会自动储存当前时间，而 datetime会储存 NULL。</p><p>在MySQL 5.6之前的版本，CURRENT_TIMESTAMP只能用于timestamp类型，<br>5.6版本之后，CURRENT_TIMESTAMP也能用于datetime类型了</p><p>所以现在想要设置创建记录时默认为当前时间二者都可</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">create_time datetime default CURRENT_TIMESTAMP,</span><br><span class="line">-- 或者</span><br><span class="line">create_time timestamp</span><br><span class="line">-- PS 可以使用ON UPDATE CURRENT_TIMESTAMP进行数据更新</span><br><span class="line">update_time timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT &#x27;更新时间&#x27;</span><br></pre></td></tr></table></figure><h2 id="二者选择"><a href="#二者选择" class="headerlink" title="二者选择"></a>二者选择</h2><p>如果在时间上要超过Linux时间的，或者服务器时区不一样的就建议选择 datetime。</p><p>如果是想要使用自动插入时间或者自动更新时间功能的，可以使用timestamp。</p><p>如果只是想表示年、日期、时间的还可以使用 year、 date、 time，它们分别占据 1、3、3 字节，而datetime就是它们的集合。</p><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul><li><a class="link"   href="https://cloud.tencent.com/developer/article/1541699" >MySQL 中 datetime 和 timestamp 的区别与选择<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://blog.csdn.net/z3278221/article/details/81000876" >DATETIME与TIMESTAMP的一些区别与问题<i class="fas fa-external-link-alt"></i></a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;一、占用空间&quot;&gt;&lt;a href=&quot;#一、占用空间&quot; class=&quot;headerlink&quot; title=&quot;一、占用空间&quot;&gt;&lt;/a&gt;一、占用空间&lt;/h2&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&quot;center&quot;&gt;类型&lt;/th&gt;
&lt;th align</summary>
      
    
    
    
    <category term="uncategorized" scheme="https://tbghg.github.io/categories/uncategorized/"/>
    
    
    <category term="MySQL" scheme="https://tbghg.github.io/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>字节后端青训营抖音项目汇报文档（打工魂小组）</title>
    <link href="https://tbghg.github.io/2022-07-18/e82217a24608/"/>
    <id>https://tbghg.github.io/2022-07-18/e82217a24608/</id>
    <published>2022-07-18T12:46:57.000Z</published>
    <updated>2022-07-18T12:46:57.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>基本信息：本文档主要介绍2022字节跳动后端青训营抖音项目</p><p>时间：2022.05-2022.06</p><p>成员：田冰航、徐洪湘、向政昌</p></blockquote><p>图片有点多，飞书这里不能直接引用，重新下载有点不方便，所以图片有所删减，建议移步：<a class="link"   href="https://yvrcskowz5.feishu.cn/docs/doccnJpAemQe5YEr9TmIxL2JCXb" >极简版抖音项目汇报文档（打工魂小组）<i class="fas fa-external-link-alt"></i></a></p><h1 id="一、项目概要"><a href="#一、项目概要" class="headerlink" title="一、项目概要"></a>一、项目概要</h1><h2 id="1-1-项目仓库和成果展示"><a href="#1-1-项目仓库和成果展示" class="headerlink" title="1.1 项目仓库和成果展示"></a>1.1 项目仓库和成果展示</h2><ol><li>项目仓库地址：<a class="link"   href="https://github.com/TBgHg/ByteDance" >GitHub项目地址<i class="fas fa-external-link-alt"></i></a></li><li>视频演示：<a class="link"   href="https://a68c7718pj.feishu.cn/file/boxcnV0P0XZOkLAcu1t2IAww3cd" >抖音演示视频.mp4<i class="fas fa-external-link-alt"></i></a></li></ol><h2 id="1-2-项目环境配置说明"><a href="#1-2-项目环境配置说明" class="headerlink" title="1.2 项目环境配置说明"></a>1.2 项目环境配置说明</h2><h3 id="1-2-1-项目使用"><a href="#1-2-1-项目使用" class="headerlink" title="1.2.1 项目使用"></a>1.2.1 项目使用</h3><ol><li>已将数据库部署于服务器上，也可根据<a class="link"   href="https://yvrcskowz5.feishu.cn/docs/doccnJpAemQe5YEr9TmIxL2JCXb#%E8%A1%A8%E8%AE%BE%E8%AE%A1" >表设计<i class="fas fa-external-link-alt"></i></a>模块中给出的建表语句在本地创建数据库</li><li>启动<code>Redis</code>（非必须）</li><li>在<code>ByteDance/pkg/common/config.go</code>中填写相应配置项（也可使用当前默认配置）</li><li>安装依赖。在<code>ByteDance</code>目录下运行<code>go mod tidy</code></li><li>运行。运行<code>go build &amp;&amp; ByteDance.exe</code>，端口开放于<code>8000</code></li></ol><h3 id="1-2-2-项目说明"><a href="#1-2-2-项目说明" class="headerlink" title="1.2.2 项目说明"></a>1.2.2 项目说明</h3><ol><li>视频模块中采用阿里云<code>OSS</code>对象存储</li><li>数据库部署在服务器中，但服务器性能较差</li><li>采用<code>ffmpeg</code>获取视频封面，<code>ffmpeg.exe</code>已同步上传项目，但对于<code>windows</code>以外的电脑需要提前安装<code>ffmpeg</code></li><li><code>Redis</code>并不是启动项目所必须的，但缺省时会缺少限制频率的功能</li></ol><h2 id="1-3-成员分工"><a href="#1-3-成员分工" class="headerlink" title="1.3 成员分工"></a>1.3 成员分工</h2><table><thead><tr><th><strong>成员</strong></th><th><strong>分工</strong></th></tr></thead><tbody><tr><td>田冰航</td><td>数据库设计，项目结构设计，用户注册功能，获取视频流功能，上传视频功能，查看已发布视频功能</td></tr><tr><td>向政昌</td><td>Validate数据验证，敏感词过滤，Redis中间件限制频率，评论功能， 点赞功能，相关功能文档撰写</td></tr><tr><td>徐洪湘</td><td>JWT令牌功能实现，数据库设计，项目结构设计，关注功能，相关功能文档攥写</td></tr></tbody></table><h2 id="1-4-技术使用"><a href="#1-4-技术使用" class="headerlink" title="1.4 技术使用"></a>1.4 技术使用</h2><ul><li>Gin</li><li>Gen</li><li>MySQL</li><li>OSS</li><li>Git</li><li>Redis</li><li>JWT</li></ul><h1 id="二、功能实现"><a href="#二、功能实现" class="headerlink" title="二、功能实现"></a>二、功能实现</h1><h2 id="2-1-用户模块"><a href="#2-1-用户模块" class="headerlink" title="2.1 用户模块"></a>2.1 用户模块</h2><ol><li><p>注册操作</p><ul><li><p>使用使用Validate验证器对参数进行验证</p></li><li><p>检测用户名是否已存在</p></li><li><p>校验密码强度，要求用户名必须小于32位字符，密码大于8位小于32位字符，至少包含一位数字，字母和特殊字符</p></li><li><p>对密码加盐后使用<code>md5</code>加密，写入数据库中</p></li><li><p>将用户ID封装后返回</p></li></ul></li><li><p>登录操作</p><ul><li><p>使用使用Validate验证器对参数进行验证</p></li><li><p>对密码进行同样的加密，检测数据库中是否存在该记录且deleted为0</p></li><li><p>更新登录时间</p></li><li><p>将user_id作为payload通过JWT生成Token</p></li><li><p>将Token和user_id进行封装并返回</p></li></ul></li><li><p>获取用户信息</p><ul><li><p>使用JWT中间件对Token进行验证</p><ol><li><p>验证失败：返回失败原因，阻止向下运行</p></li><li><p>验证成功：将user_id存入上下文中</p></li></ol></li><li><p>查询用户信息封装后返回</p></li></ul></li></ol><h2 id="2-2-视频模块"><a href="#2-2-视频模块" class="headerlink" title="2.2 视频模块"></a>2.2 视频模块</h2><ol><li><p>获取视频流</p><ul><li><p>使用JWT中间件对Token进行验证</p><ol><li>验证失败：不进行操作，继续进行</li><li>验证成功：将user_id存入上下文中</li></ol></li><li><p>内联查询最新发布的十个视频及作者信息</p><ol><li><p>上下文中含有user_id：并发查询十个视频是否被该用户点赞，作者是否被该用户关注</p></li><li><p>上下文中不含user_id：默认为视频未点赞，作者未被关注</p></li></ol></li><li><p>封装数据返回信息</p></li></ul></li><li><p>发布视频</p><ul><li><p>使用JWT中间件对Token进行验证</p><ol><li>验证失败：返回失败原因，阻止向下运行</li><li>验证成功：将user_id存入上下文中</li></ol></li><li><p>从参数中获取视频及视频信息，从上下文中获取user_id</p></li><li><p>采用雪花算法生成视频及封面名称作为标识</p></li><li><p>使用<code>ffmpeg</code>截取视频第一帧作为封面</p></li><li><p>将封面、视频上传至阿里云OSS中，截取并上传封面与上传视频二者并发进行</p></li><li><p>将视频名称、封面名称及视频和作者的相关信息存入数据库中</p></li><li><p>封装发布完成情况并返回</p></li></ul></li><li><p>查看已发布视频</p><ul><li><p>使用JWT中间件对Token进行验证</p><ol><li>验证失败：返回失败原因，阻止向下运行</li><li>验证成功：将user_id存入上下文中</li></ol></li><li><p>从上下文中获取user_id</p></li><li><p>内联查询已发布的所有视频及本人信息</p></li><li><p>封装数据返回信息</p></li></ul></li></ol><h2 id="2-3-关注模块"><a href="#2-3-关注模块" class="headerlink" title="2.3 关注模块"></a>2.3 关注模块</h2><ol><li><p>关注操作</p><ul><li><p>使用JWT中间件对Token进行验证</p><ol><li>验证失败：返回失败原因，阻止向下运行</li><li>验证成功：将user_id存入上下文中</li></ol></li><li><p>使用使用Validate验证器对参数进行验证</p></li><li><p>根据所传入信息对数据库进行更新（已经关注过），如果数据库没有改条数据，则创建该数据（没有关注过）</p></li><li><p>根据查询信息进行数据封装后返回</p></li></ul></li><li><p>获取关注列表</p><ul><li><p>使用JWT中间件对Token进行验证</p><ol><li><p>验证失败：返回失败原因，阻止向下运行</p></li><li><p>验证成功：将user_id存入上下文中</p></li></ol></li><li><p>使用使用Validate验证器对参数进行验证</p></li><li><p>根据登录用户id使用联合索引获取关注用户id列表，并发查询关注用户名和关注总数和粉丝总数</p></li><li><p>根据查询信息进行数据封装后返回</p></li></ul></li><li><p>获取粉丝列表</p><ul><li><p>使用JWT中间件对Token进行验证</p><ol><li>验证失败：返回失败原因，阻止向下运行</li><li>验证成功：将user_id存入上下文中</li></ol></li><li><p>使用使用Validate验证器对参数进行验证</p></li><li><p>根据登录用户id使用联合索引获取粉丝用户id列表，并发查询粉丝用户名和关注总数和粉丝总数</p></li><li><p>根据查询信息进行数据封装后返回</p></li></ul></li></ol><h2 id="2-4-评论模块"><a href="#2-4-评论模块" class="headerlink" title="2.4 评论模块"></a>2.4 评论模块</h2><ol><li><p>评论操作</p><ul><li><p>使用JWT中间件对Token进行验证</p><ol><li>验证失败：返回失败原因，阻止向下运行</li><li>验证成功：将user_id存入上下文中</li></ol></li><li><p>使用使用Validate验证器对参数进行验证</p></li><li><p>根据所传入信息，若action_type为1且评论内容存在，数据库中创建该数据，若action_type为2且视频id存在对数据库进行更新（软删除）。</p></li><li><p>根据查询信息进行数据封装后返回</p></li></ul></li><li><p>获取评论列表</p><ul><li><p>使用JWT中间件对Token进行验证</p><ol><li>验证失败：返回失败原因，阻止向下运行</li><li>验证成功：将user_id存入上下文中</li></ol></li><li><p>使用使用Validate验证器对参数进行验证</p></li><li><p>根据视频id使用联合查询获取评论信息列表（包含评论用户信息）</p></li><li><p>根据查询信息进行数据封装后返回</p></li></ul></li></ol><h2 id="2-5-点赞模块"><a href="#2-5-点赞模块" class="headerlink" title="2.5 点赞模块"></a>2.5 点赞模块</h2><ol><li><p>点赞操作</p><ul><li><p>使用JWT中间件对Token进行验证</p><ol><li>验证失败：返回失败原因，阻止向下运行</li><li>验证成功：将user_id存入上下文中</li></ol></li><li><p>使用使用Validate验证器对参数进行验证</p></li><li><p>根据所传入信息对数据库进行更新（已经点赞过，取消点赞），如果数据库没有该条数据，则创建该数据（没有点赞过，进行点赞）</p></li><li><p>根据查询信息进行数据封装后返回</p></li></ul></li><li><p>获取点赞列表</p><ul><li><p>使用JWT中间件对Token进行验证</p><ol><li>验证失败：返回失败原因，阻止向下运行</li><li>验证成功：将user_id存入上下文中</li></ol></li><li><p>使用使用Validate验证器对参数进行验证</p></li><li><p>根据登录用户id使用联合查询获取点赞视频信息列表（包含视频作者部分信息），然后并发查询视频作者关注总数、粉丝总数和是否已关注</p></li><li><p>根据查询信息进行数据封装后返回</p></li></ul></li></ol><h1 id="三、代码质量"><a href="#三、代码质量" class="headerlink" title="三、代码质量"></a>三、代码质量</h1><h2 id="3-1-MVC"><a href="#3-1-MVC" class="headerlink" title="3.1 MVC"></a>3.1 MVC</h2><ol><li>Request<ul><li>创建数据传输对象封装传入数据</li></ul></li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> RegUserData <span class="keyword">struct</span> &#123;</span><br><span class="line">ID    <span class="type">int</span>    <span class="string">`json:&quot;user_id&quot;`</span></span><br><span class="line">Token <span class="type">string</span> <span class="string">`json:&quot;token&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> LoginData <span class="keyword">struct</span> &#123;</span><br><span class="line">ID    <span class="type">int</span>    <span class="string">`json:&quot;user_id&quot;`</span></span><br><span class="line">Token <span class="type">string</span> <span class="string">`json:&quot;token&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> GetUserInfoData <span class="keyword">struct</span> &#123;</span><br><span class="line">ID            <span class="type">int32</span>  <span class="string">`json:&quot;id&quot;`</span></span><br><span class="line">UseName       <span class="type">string</span> <span class="string">`json:&quot;name&quot;`</span></span><br><span class="line">FollowCount   <span class="type">int64</span>  <span class="string">`json:&quot;follow_count&quot;`</span></span><br><span class="line">FollowerCount <span class="type">int64</span>  <span class="string">`json:&quot;follower_count&quot;`</span></span><br><span class="line">IsFollow      <span class="type">bool</span>   <span class="string">`json:&quot;is_follow&quot;`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li><p>Response</p><ul><li><p>sevice层封装返回数据的对象</p></li><li><p>controller层进一步封装数据对象，如添加返回响应信息，响应码等</p></li></ul></li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用户登录返回值</span></span><br><span class="line"><span class="keyword">type</span> loginResponse <span class="keyword">struct</span> &#123;</span><br><span class="line">common.Response</span><br><span class="line">user.LoginData</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用户注册返回值</span></span><br><span class="line"><span class="keyword">type</span> regUserResponse <span class="keyword">struct</span> &#123;</span><br><span class="line">common.Response</span><br><span class="line">user.RegUserData</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取用户信息</span></span><br><span class="line"><span class="keyword">type</span> getUserInfoResponse <span class="keyword">struct</span> &#123;</span><br><span class="line">common.Response</span><br><span class="line">User user.GetUserInfoData <span class="string">`json:&quot;user&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// RegisterLoginRequest 注册 登录请求</span></span><br><span class="line"><span class="keyword">type</span> RegisterLoginRequest <span class="keyword">struct</span> &#123;</span><br><span class="line">Username <span class="type">string</span> <span class="string">`form:&quot;username&quot;  validate:&quot;required&quot;`</span></span><br><span class="line">Password <span class="type">string</span> <span class="string">`form:&quot;password&quot;  validate:&quot;required&quot;`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>controller</li></ol><p>controller层只负责token验证，数据有效性验证，和数据请求的预处理和返回数据的封装，达到进一步解耦，职责明确</p><ol start="4"><li>service</li></ol><p>service层只负责接受来自controller层的数据，所有的业务逻辑都在这里处理，并调用repository层中设计数据库的操作，最后封装来自数据库的数据，返回给controller层</p><ol start="5"><li>repository</li></ol><p>repository层只负责对数据库的操作，比如DDL，DQL等，如果数据库出现问题，则可以直在repository层查找错误，利于后期维护</p><h2 id="3-2-命名规范"><a href="#3-2-命名规范" class="headerlink" title="3.2 命名规范"></a>3.2 命名规范</h2><ol><li>模块命名</li></ol><p>以user模块举例：</p><ul><li>contoller：query_xxx_info.go</li><li>service命名query_xxx_info.go</li><li>repository层则是模块名xxx.go</li></ul><ol start="2"><li><p>函数命名：采用驼峰命名法</p></li><li><p>变量命名：根据英文释义采用驼峰命名法，可直观看出变量作用</p></li></ol><h2 id="3-3-常量与配置管理"><a href="#3-3-常量与配置管理" class="headerlink" title="3.3 常量与配置管理"></a>3.3 常量与配置管理</h2><ol><li>常量管理</li></ol><p>将所有消息规整在一个文件中，便于根据报错信息查找引用及时进行定位</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用户注册</span></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">AlreadyRegisteredStatusMsg = <span class="string">&quot;该用户名已被注册&quot;</span></span><br><span class="line">RegisterSuccessStatusMsg   = <span class="string">&quot;注册成功&quot;</span></span><br><span class="line">MatchFailedStatusMsg       = <span class="string">&quot;账号密码需要小于32字符，密码包含至少一位数字，字母和特殊字符&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用户登录</span></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">WrongUsernameOrPasswordMsg = <span class="string">&quot;用户名或密码错误&quot;</span></span><br><span class="line">LoginSuccessStatusMsg      = <span class="string">&quot;登陆成功&quot;</span></span><br><span class="line">AccountBlocked             = <span class="string">&quot;账号已被冻结&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取用户信息</span></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">UserIDNotExistMsg     = <span class="string">&quot;用户ID不存在&quot;</span></span><br><span class="line">GetUserInfoSuccessMsg = <span class="string">&quot;获取用户信息成功&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等……</span></span><br></pre></td></tr></table></figure><ol start="2"><li>配置管理</li></ol><p>将数据库、OSS和JWT相关配置项进行抽离，便于对项目进行配置</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> MySqlDSN = <span class="string">&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Redis 配置</span></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">   RedisLocalhost = <span class="string">&quot;localhost:6379&quot;</span></span><br><span class="line">   RedisPassword  = <span class="string">&quot;&quot;</span></span><br><span class="line">   RedisDB        = <span class="number">0</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// MD5Salt MD5加密时的盐</span></span><br><span class="line"><span class="keyword">const</span> MD5Salt = <span class="string">&quot;UII34HJ6OIO&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// JWT</span></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">   Issuer              = <span class="string">&quot;xhx&quot;</span> <span class="comment">// 签发人</span></span><br><span class="line">   MySecret            = <span class="string">&quot;F3Jfa5AD&quot;</span></span><br><span class="line">   TokenExpirationTime = <span class="number">14</span> * <span class="number">24</span> * time.Hour * time.Duration(<span class="number">1</span>) <span class="comment">// Token过期时间</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// OSSPreURL OSS前缀</span></span><br><span class="line"><span class="keyword">const</span> OSSPreURL = <span class="string">&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// SensitiveWordsPath 敏感词路径</span></span><br><span class="line"><span class="keyword">const</span> SensitiveWordsPath = <span class="string">&quot;./utils/SensitiveWords.txt&quot;</span></span><br></pre></td></tr></table></figure><h2 id="3-4-日志记录"><a href="#3-4-日志记录" class="headerlink" title="3.4 日志记录"></a>3.4 日志记录</h2><p>使用<code>go.uber.org/zap</code>进行日志管理，文件配置项如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//文件writeSyncer</span></span><br><span class="line">fileWriteSyncer := zapcore.AddSync(&amp;lumberjack.Logger&#123;</span><br><span class="line">   Filename:   <span class="string">&quot;./logs/ByteDance.log&quot;</span>, <span class="comment">//日志文件存放目录</span></span><br><span class="line">   MaxSize:    <span class="number">1</span>,                      <span class="comment">//文件大小限制,单位MB</span></span><br><span class="line">   MaxBackups: <span class="number">5</span>,                      <span class="comment">//最大保留日志文件数量</span></span><br><span class="line">   MaxAge:     <span class="number">30</span>,                     <span class="comment">//日志文件保留天数</span></span><br><span class="line">   Compress:   <span class="literal">false</span>,                  <span class="comment">//是否压缩处理</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>全局配置Log变量，记录四种类型的日志：Info、Warn、Error、Fatal</p><ul><li>Info类型</li></ul><p>MySQL、Redis、OSS初始化成功时输出</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">db, err = gorm.Open(mysql.Open(common.MySqlDSN))</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">   utils.Log.Fatal(<span class="string">&quot;数据库连接错误&quot;</span> + err.Error())</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">   utils.Log.Info(<span class="string">&quot;MySQL连接成功&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>Warn类型</li></ul><p>Redis未连接时输出（未连接Redis会确实限制频率功能，当项目可以正常运行）</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过 *redis.Client.Ping() 来检查是否成功连接到了redis服务器</span></span><br><span class="line">_, err := RedisDb.Ping().Result()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">   utils.Log.Warn(<span class="string">&quot;Redis连接失败&quot;</span>)</span><br><span class="line">   <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">   utils.Log.Info(<span class="string">&quot;Redis连接成功&quot;</span>)</span><br><span class="line">   <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>Error类型：程序正常运行时，不该出现的错误</li></ul><p>数据库查询错误、类型转化错误等</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 文件上传日志记录</span></span><br><span class="line"><span class="keyword">if</span> fileType == <span class="string">&quot;video&quot;</span> &#123;</span><br><span class="line">   fileSuffix = <span class="string">&quot;.mp4&quot;</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> fileType == <span class="string">&quot;picture&quot;</span> &#123;</span><br><span class="line">   fileSuffix = <span class="string">&quot;.jpg&quot;</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">   Log.Error(<span class="string">&quot;无法上传&quot;</span> + fileType + <span class="string">&quot;类型文件&quot;</span>)</span><br><span class="line">   <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>Fatal类型：错误出现后，系统无法正常启动</li></ul><p>MySQL连接失败</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">db, err = gorm.Open(mysql.Open(common.MySqlDSN))</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">   utils.Log.Fatal(<span class="string">&quot;数据库连接错误&quot;</span> + err.Error())</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">   utils.Log.Info(<span class="string">&quot;MySQL连接成功&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="四、项目设计"><a href="#四、项目设计" class="headerlink" title="四、项目设计"></a>四、项目设计</h1><h2 id="4-1-数据库设计"><a href="#4-1-数据库设计" class="headerlink" title="4.1 数据库设计"></a>4.1 数据库设计</h2><h3 id="4-1-1-数据库ER图"><a href="#4-1-1-数据库ER图" class="headerlink" title="4.1.1 数据库ER图"></a>4.1.1 数据库ER图</h3><p><img                       lazyload                     alt="image"                     data-src="https://s1.ax1x.com/2023/01/12/pSugF7d.png"                      alt="ER图"                ></p><h3 id="4-1-2-数据库表"><a href="#4-1-2-数据库表" class="headerlink" title="4.1.2 数据库表"></a>4.1.2 数据库表</h3><ol><li>user表<ul><li>username,deleted联合索引</li></ul></li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> <span class="keyword">user</span></span><br><span class="line">(</span><br><span class="line">    id          <span class="type">int</span> auto_increment comment <span class="string">&#x27;PK，直接自增&#x27;</span></span><br><span class="line">        <span class="keyword">primary</span> key,</span><br><span class="line">    username    <span class="type">varchar</span>(<span class="number">32</span>)                        <span class="keyword">not</span> <span class="keyword">null</span> comment <span class="string">&#x27;UK，账号&#x27;</span>,</span><br><span class="line">    password    <span class="type">varchar</span>(<span class="number">32</span>)                        <span class="keyword">not</span> <span class="keyword">null</span> comment <span class="string">&#x27;密码（MD5）&#x27;</span>,</span><br><span class="line">    enable      tinyint  <span class="keyword">default</span> <span class="number">1</span>                 <span class="keyword">null</span> comment <span class="string">&#x27;账号是否可用&#x27;</span>,</span><br><span class="line">    deleted     tinyint  <span class="keyword">default</span> <span class="number">0</span>                 <span class="keyword">null</span> comment <span class="string">&#x27;删除标识位&#x27;</span>,</span><br><span class="line">    login_time  datetime <span class="keyword">default</span> <span class="built_in">CURRENT_TIMESTAMP</span> <span class="keyword">null</span>,</span><br><span class="line">    create_time datetime <span class="keyword">default</span> <span class="built_in">CURRENT_TIMESTAMP</span> <span class="keyword">null</span> comment <span class="string">&#x27;注册时间&#x27;</span></span><br><span class="line">)</span><br><span class="line">    comment <span class="string">&#x27;用户表，储存用户信息&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> index user_username_deleted_index</span><br><span class="line">    <span class="keyword">on</span> <span class="keyword">user</span> (username, deleted);</span><br></pre></td></tr></table></figure><ol start="2"><li>video表<ol><li>author_id,removed,deleted联合索引</li><li>time,removed,deleted联合索引</li></ol></li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> video</span><br><span class="line">(</span><br><span class="line">    id        <span class="type">int</span> auto_increment</span><br><span class="line">        <span class="keyword">primary</span> key,</span><br><span class="line">    author_id <span class="type">int</span>               <span class="keyword">not</span> <span class="keyword">null</span>,</span><br><span class="line">    play_url  <span class="type">varchar</span>(<span class="number">32</span>)       <span class="keyword">not</span> <span class="keyword">null</span>,</span><br><span class="line">    cover_url <span class="type">varchar</span>(<span class="number">32</span>)       <span class="keyword">not</span> <span class="keyword">null</span>,</span><br><span class="line">    <span class="type">time</span>      <span class="type">int</span>               <span class="keyword">not</span> <span class="keyword">null</span>,</span><br><span class="line">    title     <span class="type">varchar</span>(<span class="number">128</span>)      <span class="keyword">not</span> <span class="keyword">null</span>,</span><br><span class="line">    removed   tinyint <span class="keyword">default</span> <span class="number">0</span> <span class="keyword">not</span> <span class="keyword">null</span>,</span><br><span class="line">    deleted   tinyint <span class="keyword">default</span> <span class="number">0</span> <span class="keyword">not</span> <span class="keyword">null</span>,</span><br><span class="line">    <span class="keyword">constraint</span> video_user_id_fk</span><br><span class="line">        <span class="keyword">foreign</span> key (author_id) <span class="keyword">references</span> <span class="keyword">user</span> (id)</span><br><span class="line">)</span><br><span class="line">    comment <span class="string">&#x27;存储视频信息&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> index video_author_id_removed_deleted_index</span><br><span class="line">    <span class="keyword">on</span> video (author_id, removed, deleted);</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> index video_time_removed_deleted_index</span><br><span class="line">    <span class="keyword">on</span> video (<span class="type">time</span>, removed, deleted);</span><br></pre></td></tr></table></figure><ol start="3"><li>follow表<ol><li>user_id,removed,deleted联合索引</li><li>fun_id,removed,deleted联合索引</li></ol></li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> follow</span><br><span class="line">(</span><br><span class="line">    id      <span class="type">int</span> auto_increment</span><br><span class="line">        <span class="keyword">primary</span> key,</span><br><span class="line">    user_id <span class="type">int</span>               <span class="keyword">null</span>,</span><br><span class="line">    fun_id  <span class="type">int</span>               <span class="keyword">not</span> <span class="keyword">null</span>,</span><br><span class="line">    removed tinyint <span class="keyword">default</span> <span class="number">0</span> <span class="keyword">not</span> <span class="keyword">null</span>,</span><br><span class="line">    deleted tinyint <span class="keyword">default</span> <span class="number">0</span> <span class="keyword">not</span> <span class="keyword">null</span>,</span><br><span class="line">    <span class="keyword">constraint</span> follow_user_id2fun_fk_2</span><br><span class="line">        <span class="keyword">foreign</span> key (fun_id) <span class="keyword">references</span> <span class="keyword">user</span> (id),</span><br><span class="line">    <span class="keyword">constraint</span> follow_user_id2user_fk</span><br><span class="line">        <span class="keyword">foreign</span> key (user_id) <span class="keyword">references</span> <span class="keyword">user</span> (id)</span><br><span class="line">)</span><br><span class="line">    comment <span class="string">&#x27;关注表&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> index follow_fun_id_removed_deleted_index</span><br><span class="line">    <span class="keyword">on</span> follow (fun_id, removed, deleted);</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> index follow_user_id_removed_deleted_index</span><br><span class="line">    <span class="keyword">on</span> follow (user_id, removed, deleted);</span><br></pre></td></tr></table></figure><ol start="4"><li>favorite表<ol><li>video_id,removed,deleted联合索引</li><li>user_id,removed,deleted联合索引</li></ol></li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> favorite</span><br><span class="line">(</span><br><span class="line">    id       <span class="type">int</span> auto_increment</span><br><span class="line">        <span class="keyword">primary</span> key,</span><br><span class="line">    video_id <span class="type">int</span>                <span class="keyword">not</span> <span class="keyword">null</span>,</span><br><span class="line">    user_id  <span class="type">int</span>                <span class="keyword">not</span> <span class="keyword">null</span>,</span><br><span class="line">    removed  tinyint <span class="keyword">default</span> <span class="number">-1</span> <span class="keyword">not</span> <span class="keyword">null</span>,</span><br><span class="line">    deleted  tinyint <span class="keyword">default</span> <span class="number">0</span>  <span class="keyword">not</span> <span class="keyword">null</span>,</span><br><span class="line">    <span class="keyword">constraint</span> favorite_user_id_fk</span><br><span class="line">        <span class="keyword">foreign</span> key (user_id) <span class="keyword">references</span> <span class="keyword">user</span> (id),</span><br><span class="line">    <span class="keyword">constraint</span> favorite_video_id_fk</span><br><span class="line">        <span class="keyword">foreign</span> key (video_id) <span class="keyword">references</span> video (id)</span><br><span class="line">)</span><br><span class="line">    comment <span class="string">&#x27;用户视频点赞表&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> index favorite_user_id_video_id_removed_deleted_index</span><br><span class="line">    <span class="keyword">on</span> favorite (user_id, video_id, removed, deleted);</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> index favorite_video_id_removed_deleted_user_id_index</span><br><span class="line">    <span class="keyword">on</span> favorite (video_id, removed, deleted, user_id);</span><br></pre></td></tr></table></figure><ol start="5"><li>comment表<ol><li>user_id</li><li>video_id,removed,deleted联合索引</li><li>create_time,removed,deleted联合索引</li></ol></li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> comment</span><br><span class="line">(</span><br><span class="line">    id          <span class="type">int</span> auto_increment</span><br><span class="line">        <span class="keyword">primary</span> key,</span><br><span class="line">    user_id     <span class="type">int</span>                                <span class="keyword">not</span> <span class="keyword">null</span>,</span><br><span class="line">    video_id    <span class="type">int</span>                                <span class="keyword">not</span> <span class="keyword">null</span>,</span><br><span class="line">    create_time datetime <span class="keyword">default</span> <span class="built_in">CURRENT_TIMESTAMP</span> <span class="keyword">not</span> <span class="keyword">null</span>,</span><br><span class="line">    removed     tinyint  <span class="keyword">default</span> <span class="number">0</span>                 <span class="keyword">not</span> <span class="keyword">null</span>,</span><br><span class="line">    deleted     tinyint  <span class="keyword">default</span> <span class="number">0</span>                 <span class="keyword">not</span> <span class="keyword">null</span>,</span><br><span class="line">    content     text                               <span class="keyword">not</span> <span class="keyword">null</span>,</span><br><span class="line">    <span class="keyword">constraint</span> comment_user_id_fk</span><br><span class="line">        <span class="keyword">foreign</span> key (user_id) <span class="keyword">references</span> <span class="keyword">user</span> (id),</span><br><span class="line">    <span class="keyword">constraint</span> comment_video_id_fk</span><br><span class="line">        <span class="keyword">foreign</span> key (video_id) <span class="keyword">references</span> video (id)</span><br><span class="line">)</span><br><span class="line">    comment <span class="string">&#x27;评论表&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> index comment_create_time_removed_deleted_index</span><br><span class="line">    <span class="keyword">on</span> comment (create_time, removed, deleted);</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> index comment_video_id_removed_deleted_index</span><br><span class="line">    <span class="keyword">on</span> comment (video_id, removed, deleted);</span><br></pre></td></tr></table></figure><hr><h2 id="4-2-项目结构设计"><a href="#4-2-项目结构设计" class="headerlink" title="4.2 项目结构设计"></a>4.2 项目结构设计</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">ByteDance</span><br><span class="line">│  .gitignore</span><br><span class="line">│  ffmpeg.exe  // 截取视频第一帧</span><br><span class="line">│  go.mod</span><br><span class="line">│  Readme.md</span><br><span class="line">│  router.go   // 创建路由</span><br><span class="line">│  server.go   // 项目启动入口</span><br><span class="line">│</span><br><span class="line">├─cmd</span><br><span class="line">│  ├─user</span><br><span class="line">│  │  │  user_common_model.go  // user模块中共用的结构体</span><br><span class="line">│  │  │</span><br><span class="line">│  │  ├─controller    // 控制层，接受参数，编写流程逻辑，返回信息</span><br><span class="line">│  │  │      query_user_info.go</span><br><span class="line">│  │  │</span><br><span class="line">│  │  ├─repository    // 负责与数据库的交互</span><br><span class="line">│  │  │      user.go</span><br><span class="line">│  │  │</span><br><span class="line">│  │  └─service          // 处理流程中的主要函数</span><br><span class="line">│  │          query_user_info.go</span><br><span class="line">│  │</span><br><span class="line">│  ├─comment      // 其他模块与user模块结构相同</span><br><span class="line">│  ├─favorite</span><br><span class="line">│  ├─follow</span><br><span class="line">│  └─video</span><br><span class="line">│</span><br><span class="line">├─dal     // MySQL、Redis初始化</span><br><span class="line">│  │  dal.go</span><br><span class="line">│  ├─method</span><br><span class="line">│  │      dal_common_method.go // 共用的查询方法</span><br><span class="line">│  │      method.go            // 自定义查询方法，用Gen生成</span><br><span class="line">│  │</span><br><span class="line">│  ├─model    // Gen生成的数据模型</span><br><span class="line">│  └─query    // Gen生成的数据库操作方法</span><br><span class="line">│</span><br><span class="line">├─logs    // 日志存放位置</span><br><span class="line">├─pkg</span><br><span class="line">│  ├─common</span><br><span class="line">│  │      common.go       // 模块公用部分</span><br><span class="line">│  │      config.go           // 配置项</span><br><span class="line">│  │</span><br><span class="line">│  ├─middleware        // 中间件</span><br><span class="line">│  │      middleware.go</span><br><span class="line">│  │</span><br><span class="line">│  └─msg   // 定义返回消息</span><br><span class="line">│          msg.go</span><br><span class="line">│</span><br><span class="line">└─utils        // 工具类</span><br><span class="line">    │  jwt.go           // 生成Token令牌</span><br><span class="line">    │  log.go           // 日志生成</span><br><span class="line">    │  password.go       // MD5加密，检测密码强度</span><br><span class="line">    │  SensitiveWords.txt       // 项目 </span><br><span class="line">    │  sensitive_word.go</span><br><span class="line">    │  snowflake.go          // 雪花算法</span><br><span class="line">    │  upload_file.go       // OSS中上传文件</span><br><span class="line">    └─generate</span><br><span class="line">            generate.go             // Gen生成模块与方法</span><br></pre></td></tr></table></figure><h1 id="五、项目亮点"><a href="#五、项目亮点" class="headerlink" title="五、项目亮点"></a>五、项目亮点</h1><h2 id="5-1-代码管理"><a href="#5-1-代码管理" class="headerlink" title="5.1 代码管理"></a>5.1 代码管理</h2><p>使用Git进行分工合作，对版本进行控制 （1）版本迭代更加清晰 （2）提升开发效率 （3）利于代码review的实现，规范团队项目开发</p><h2 id="5-2高性能"><a href="#5-2高性能" class="headerlink" title="5.2高性能"></a>5.2高性能</h2><h3 id="5-2-1-OSS对象存储"><a href="#5-2-1-OSS对象存储" class="headerlink" title="5.2.1 OSS对象存储"></a>5.2.1 OSS对象存储</h3><p>采用阿里云oss存储上传视频 （1）节省服务器空间，单独的文件管理界面，管理网站文件和本地电脑一样方便</p><h3 id="5-2-2-雪花算法"><a href="#5-2-2-雪花算法" class="headerlink" title="5.2.2 雪花算法"></a>5.2.2 雪花算法</h3><p>采用雪花算法生成给上传的视频设置随机id （1）高性能：ID在内存生成，不依赖数据库 （2）高可用：ID在内存生成，不依赖数据库 （3）容量大：每秒能生成百万量级的ID</p><h3 id="5-2-3-GEN自定义模型"><a href="#5-2-3-GEN自定义模型" class="headerlink" title="5.2.3 GEN自定义模型"></a>5.2.3 GEN自定义模型</h3><p>首先进行表设计，将数据库部署在服务器上，通过Gen生成模型和查询方式，对常用查询方法采用自定义方法的方式 （1）简化代码且减少编码时间</p><h3 id="5-2-4-MySQL索引"><a href="#5-2-4-MySQL索引" class="headerlink" title="5.2.4 MySQL索引"></a>5.2.4 MySQL索引</h3><p>数据库表统一采用InnoDB存储引擎，索引结构默认B+树，通过主键索引，二级索引中遵循最左前缀法则对数据进行搜索 （1）主键索引也为聚集索引，聚集索引的查询速度非常的快，因为整个 B+树本身就是一颗多叉平衡树，叶子节点也都是有序的，定位到索引的节点，就相当于定位到了数据 （2）二级索引也为非聚集索引，更新代价比聚集索引要小。非聚集索引的更新代价就没有聚集索引那么大了，非聚集索引的叶子节点是不存放数据的，只存放主键信息或指针</p><h3 id="5-2-5-单例模式"><a href="#5-2-5-单例模式" class="headerlink" title="5.2.5 单例模式"></a>5.2.5 单例模式</h3><p>用init函数对每个模块的dao对象，数据库连接等进行初始化，放在内存当中，当要使用的时候，即可以从内存中直接取出，不用新建对象 （1）提供了对唯一实例的受控访问 （2）由于在系统内存中只存在一个对象，因此可以 节约系统资源，当需要频繁创建和销毁的对象时单例模式无疑可以提高系统的性能 （3）避免对共享资源的多重占用 （4）通过饿汉模式，在所有程序执行开始前被调用直接创建并初始化单例对象，所以并不存在线程安全的问题</p><h3 id="5-2-6-并发编程"><a href="#5-2-6-并发编程" class="headerlink" title="5.2.6 并发编程"></a>5.2.6 并发编程</h3><p>通过go语言的协程，优雅地进行并发编程，以此并发对数据库进行操作，大大提升其响应速度，因为MySQL的InnoDB引擎支持事务，所以不用担心起并发安全问题 （1）Goroutine所需要的内存通常只有2kb，而线程则需要1Mb,内存消耗更少 （2）由于线程创建时需要向操作系统申请资源，并且在销毁时将资源归还，因此它的创建和销毁的开销比较大。相比之下，goroutine的创建和销毁是由go语言在运行时自己管理的，因此开销更低</p><h2 id="5-3-安全问题"><a href="#5-3-安全问题" class="headerlink" title="5.3 安全问题"></a>5.3 安全问题</h2><h3 id="5-3-1-Token验证"><a href="#5-3-1-Token验证" class="headerlink" title="5.3.1 Token验证"></a>5.3.1 Token验证</h3><p>采用JWT进行Token验证，中间件中对Token进行解析和判断，阻止Token不合法或已过期的请求，将token中携带的user_id信息写入 *gin.Context 声明的参数中供后续使用，考虑到前端未采用refresh_token进行刷新，将Token过期时间设置为14天 （1）解决了用户鉴权问题 （2）防止 CSRF攻击</p><h3 id="5-3-2-防止SQL注入"><a href="#5-3-2-防止SQL注入" class="headerlink" title="5.3.2 防止SQL注入"></a>5.3.2 <strong>防止SQL注入</strong></h3><p>根据所选框架为Gen，Gen 提供了自动同步数据表结构体到 GORM 模型，使用非常简单，即使数据库字段信息改变，可以一键同步，数据库查询相关代码可以一键生成，CRUD 只需要调用对应的方法，开发体验飞起 （1）GEN 采用了类型安全限制，所有参数都做了安全限制，完全不用担心存在注入 （2）自定义 SQL 只需要通过模板注释到 interface 的方法上，自动生成安全的代码SQL ，也不会出现SQL 注入问题</p><h3 id="5-3-3-参数校验"><a href="#5-3-3-参数校验" class="headerlink" title="5.3.3 参数校验"></a>5.3.3 参数校验</h3><p>采用Validate对请求参数进行合法性校验，阻止不符合参数要求的请求，二次避免SQL、XSS注入，防止通过发送请求对程序进破坏。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// FavoriteListResponse 点赞列表返回值</span></span><br><span class="line"><span class="keyword">type</span> FavoriteListResponse <span class="keyword">struct</span> &#123;</span><br><span class="line">common.Response</span><br><span class="line">VideoList []video.TheVideoInfo <span class="string">`json:&quot;video_list&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// FavoriteActionRequest 点赞与取消请求</span></span><br><span class="line"><span class="keyword">type</span> FavoriteActionRequest <span class="keyword">struct</span> &#123;</span><br><span class="line">Token      <span class="type">string</span> <span class="string">`form:&quot;token&quot;        validate:&quot;required,jwt&quot;`</span></span><br><span class="line">VideoId    <span class="type">int64</span>  <span class="string">`form:&quot;video_id&quot;     validate:&quot;required,numeric,min=1&quot;`</span></span><br><span class="line">ActionType <span class="type">int32</span>  <span class="string">`form:&quot;action_type&quot;  validate:&quot;required,numeric,oneof=1 2&quot;`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-3-4-密码安全"><a href="#5-3-4-密码安全" class="headerlink" title="5.3.4 密码安全"></a>5.3.4 密码安全</h3><p>对参数进行校验，要求用户名必须小于32位字符，密码大于8位小于32位字符，至少包含一位数字，字母和特殊字符。 将用户密码加盐使用<code>md5</code>加密再存入数据库中确保用户密码的安全性</p><h3 id="5-3-5-敏感词检测"><a href="#5-3-5-敏感词检测" class="headerlink" title="5.3.5 敏感词检测"></a>5.3.5 敏感词检测</h3><p>采用go-wordsfilter对评论和发布视频请求中的文本信息进行敏感词检测，敏感词类型涉及黄赌毒、党政、欺骗消费者等方面。检测到敏感词后，阻止本次请求，并写入日志。</p><h2 id="5-4-高可用"><a href="#5-4-高可用" class="headerlink" title="5.4 高可用"></a>5.4 高可用</h2><h3 id="5-4-1-恶意请求限流"><a href="#5-4-1-恶意请求限流" class="headerlink" title="5.4.1 恶意请求限流"></a>5.4.1 恶意请求限流</h3><p>采用Redis记录请求ip，设置过期时间为5秒，同一ip5秒内访问超过100次的其余请求在中间件中被阻止，避免网站负载升高或者造成网站带宽阻塞而拒绝或无法响应正常用户的请求，防止通过发送请求对程序进破坏。</p><h3 id="5-4-2-性能测试"><a href="#5-4-2-性能测试" class="headerlink" title="5.4.2 性能测试"></a>5.4.2 性能测试</h3><p>测试工具:Apifox v2.1.16，Jmeter 采用Apifox进行测试集接口自动化，根据不同测试环境和测试数据，生成压力测试报告进行局部调优 假设实际运行开发中 以最大流量的视频流为例 40线程数 RT平均耗时为1.2s 吞吐量为37.3&#x2F;min</p><p><img                       lazyload                     alt="image"                     data-src="https://s1.ax1x.com/2023/01/12/pSugVht.png"                                     ></p><p><img                       lazyload                     alt="image"                     data-src="https://s1.ax1x.com/2023/01/12/pSugEtI.png"                                     ></p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;基本信息：本文档主要介绍2022字节跳动后端青训营抖音项目&lt;/p&gt;
&lt;p&gt;时间：2022.05-2022.06&lt;/p&gt;
&lt;p&gt;成员：田冰航、徐洪湘、向政昌&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;图片有点多，飞书这里不能直接引用，重新下载有点不方</summary>
      
    
    
    
    <category term="uncategorized" scheme="https://tbghg.github.io/categories/uncategorized/"/>
    
    
    <category term="后端" scheme="https://tbghg.github.io/tags/%E5%90%8E%E7%AB%AF/"/>
    
    <category term="字节" scheme="https://tbghg.github.io/tags/%E5%AD%97%E8%8A%82/"/>
    
  </entry>
  
</feed>
