<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <meta name="keywords" content="TBgHg">
    <meta name="description" content="这里是TBH的博客，用于技术分享，记录日常。">
    <meta name="author" content="TBgHg">
    
    <title>
        
            背包做题笔记 |
        
        TBH的博客
    </title>
    
<link rel="stylesheet" href="/css/style.css">

    <link rel="shortcut icon" href="https://s1.ax1x.com/2023/01/12/pSurRG8.png">
    <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.6.1/source/font/css/fontawesome.min.css">
    <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.6.1/source/font/css/regular.min.css">
    <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.6.1/source/font/css/solid.min.css">
    <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.6.1/source/font/css/brands.min.css">
    <script id="hexo-configurations">
    let KEEP = window.KEEP || {}
    KEEP.hexo_config = {"hostname":"tbghg.github.io","root":"/","language":"zh-CN","path":"search.json"}
    KEEP.theme_config = {"toc":{"enable":true,"number":true,"expand_all":true,"init_open":true},"style":{"primary_color":"#0066cc","logo":"https://s1.ax1x.com/2023/01/12/pSurRG8.png","favicon":"https://s1.ax1x.com/2023/01/12/pSurRG8.png","avatar":"https://s1.ax1x.com/2023/01/12/pSurRG8.png","font_size":null,"font_family":"STHeiti","hover":{"shadow":true,"scale":true},"first_screen":{"enable":true,"header_transparent":true,"background_img":"/images/bg.svg","description":"如果结果不如你所愿||那就在尘埃落定前奋起一搏","font_color":null,"hitokoto":false},"scroll":{"progress_bar":false,"percent":false}},"local_search":{"enable":true,"preload":true},"code_copy":{},"code_block":{"tools":{"enable":true,"style":"default"},"highlight_theme":"default"},"side_tools":{},"pjax":{"enable":true},"lazyload":{"enable":true},"comment":{"enable":true,"use":"valine","valine":{"appid":"0HepQGr76M5xNgWk2Ecac7CC-gzGzoHsz","appkey":"9bWzVBcRI0aSocVHtX3OBSYo","server_urls":null,"placeholder":null},"gitalk":{"github_id":null,"github_admins":null,"repository":null,"client_id":null,"client_secret":null,"proxy":null},"twikoo":{"env_id":null,"region":null,"version":"1.6.8"},"waline":{"server_url":null,"reaction":false,"version":2}},"post":{"author_label":{"enable":false,"auto":false,"custom_label_list":["苦逼后端人"]},"word_count":{"enable":true,"wordcount":true,"min2read":true},"img_align":"center","copyright_info":false},"version":"3.6.1"}
    KEEP.language_ago = {"second":"%s 秒前","minute":"%s 分钟前","hour":"%s 小时前","day":"%s 天前","week":"%s 周前","month":"%s 个月前","year":"%s 年前"}
    KEEP.language_code_block = {"copy":"复制代码","copied":"已复制","fold":"折叠代码块","folded":"已折叠"}
    KEEP.language_copy_copyright = {"copy":"复制版权信息","copied":"已复制","title":"原文标题","author":"原文作者","link":"原文链接"}
  </script>
<meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="TBH个人博客" type="application/atom+xml">
</head>


<body>
<div class="progress-bar-container">
    

    
        <span class="pjax-progress-bar"></span>
        <i class="pjax-progress-icon fas fa-circle-notch fa-spin"></i>
    
</div>


<main class="page-container">

    

    <div class="page-main-content">

        <div class="page-main-content-top">
            
<header class="header-wrapper">

    <div class="header-content">
        <div class="left">
            
                <a class="logo-image" href="/">
                    <img src="https://s1.ax1x.com/2023/01/12/pSurRG8.png">
                </a>
            
            <a class="logo-title" href="/">
               TBH的博客
            </a>
        </div>

        <div class="right">
            <div class="pc">
                <ul class="menu-list">
                    
                        <li class="menu-item">
                            <a class=""
                               href="/"
                            >
                                首页
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/archives"
                            >
                                归档
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/tags"
                            >
                                标签
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/about"
                            >
                                关于
                            </a>
                        </li>
                    
                    
                        <li class="menu-item search search-popup-trigger">
                            <i class="fas fa-search"></i>
                        </li>
                    
                </ul>
            </div>
            <div class="mobile">
                
                    <div class="icon-item search search-popup-trigger"><i class="fas fa-search"></i></div>
                
                <div class="icon-item menu-bar">
                    <div class="menu-bar-middle"></div>
                </div>
            </div>
        </div>
    </div>

    <div class="header-drawer">
        <ul class="drawer-menu-list">
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/">首页</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/archives">归档</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/tags">标签</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/about">关于</a>
                </li>
            
        </ul>
    </div>

    <div class="window-mask"></div>

</header>


        </div>

        <div class="page-main-content-middle">

            <div class="main-content">

                
                    <div class="fade-in-down-animation">
    <div class="post-page-container">
        <div class="article-content-container">

            <div class="article-title">
                <span class="title-hover-animation">背包做题笔记</span>
            </div>

            
                <div class="article-header">
                    <div class="avatar">
                        <img src="https://s1.ax1x.com/2023/01/12/pSurRG8.png">
                    </div>
                    <div class="info">
                        <div class="author">
                            <span class="name">TBgHg</span>
                            
                        </div>
                        <div class="meta-info">
                            
<div class="article-meta-info">
    <span class="article-date article-meta-item">
        
            <i class="fa-regular fa-calendar-plus"></i>&nbsp;
        
        <span class="pc">2023-01-13 21:43:13</span>
        <span class="mobile">2023-01-13 21:43</span>
    </span>
    
        <span class="article-update-date article-meta-item">
        <i class="fas fa-file-pen"></i>&nbsp;
        <span class="pc">2023-01-13 21:43:13</span>
    </span>
    
    
    
        <span class="article-tags article-meta-item">
            <i class="fas fa-tags"></i>&nbsp;
            <ul>
                
                    <li>
                        <a href="/tags/%E7%AE%97%E6%B3%95/">算法</a>&nbsp;
                    </li>
                
            </ul>
        </span>
    

    
    
        <span class="article-wordcount article-meta-item">
            <i class="fas fa-file-word"></i>&nbsp;<span>7.3k 字</span>
        </span>
    
    
        <span class="article-min2read article-meta-item">
            <i class="fas fa-clock"></i>&nbsp;<span>30 分钟</span>
        </span>
    
    
        <span class="article-pv article-meta-item">
            <i class="fas fa-eye"></i>&nbsp;<span id="busuanzi_value_page_pv"></span>
        </span>
    
</div>

                        </div>
                    </div>
                </div>
            

            <div class="article-content keep-markdown-body">
                

                <p>你的背包~🎵</p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这个是刷代码随想录的做题笔记，分析部分大多是我自己的理解，代码我用go写的，现在回头再看一遍还是觉得代码随想录总结的很棒，强推一波！</p>
<h2 id="背包概括"><a href="#背包概括" class="headerlink" title="背包概括"></a>背包概括</h2><p><img  
                     lazyload
                     alt="image"
                     data-src="https://s2.loli.net/2023/01/13/3YInUimcOks7N5w.png"
                      alt="416.分割等和子集1"
                ></p>
<p>面试的话，其实掌握 01背包 完全背包，就够用了，leetcode上连多重背包的题目都没有</p>
<p>完全背包又是也是01背包稍作变化而来，即：完全背包的物品数量是无限的。01背包是基础，需要重点掌握。</p>
<h2 id="01背包"><a href="#01背包" class="headerlink" title="01背包"></a>01背包</h2><h3 id="01背包初介绍"><a href="#01背包初介绍" class="headerlink" title="01背包初介绍"></a>01背包初介绍</h3><p>有n件物品和一个最多能背重量为w的背包。第i件物品的重量是weight[i]，得到的价值是value[i] 。<strong>每件物品只能用一次</strong>，求解将哪些物品装入背包里物品价值总和最大。</p>
<p>先从暴力的角度来看，通过回溯实现暴力，每一件物品其实只有两个状态，取或者不取，所以可以使用回溯法搜索出所有的情况，那么时间复杂度就是o(2^n)，这里的n表示物品数量。</p>
<p>所以暴力的解法是指数级别的时间复杂度。进而才需要动态规划的解法来进行优化</p>
<h3 id="入门例题"><a href="#入门例题" class="headerlink" title="入门例题"></a>入门例题</h3><p>背包最大重量为4，物品为：</p>
<table>
<thead>
<tr>
<th></th>
<th>重量</th>
<th>价值</th>
</tr>
</thead>
<tbody><tr>
<td>物品0</td>
<td>1</td>
<td>15</td>
</tr>
<tr>
<td>物品1</td>
<td>3</td>
<td>20</td>
</tr>
<tr>
<td>物品2</td>
<td>4</td>
<td>30</td>
</tr>
</tbody></table>
<p>问背包能背的物品最大价值是多少？</p>
<h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><p><strong>动规五部曲</strong></p>
<ol>
<li>确定dp数组以及下标的含义</li>
</ol>
<p>对于背包问题，有一种写法， 是使用二维数组，即<strong>dp[i][j] 表示从下标为[0-i]的物品里任意取，放进容量为j的背包，价值总和最大是多少</strong></p>
<table>
<thead>
<tr>
<th></th>
<th>0</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
</tr>
</thead>
<tbody><tr>
<td>物品0</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>物品1</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>物品2</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<ol start="2">
<li>确定递推公式</li>
</ol>
<p>再回顾一下dp[i][j]的含义：从下标为[0-i]的物品里任意取，放进容量为j的背包，价值总和最大是多少</p>
<p>那么可以有两个方向推出来dp[i][j]：</p>
<ul>
<li><strong>不放物品i</strong>：由dp[i - 1][j]推出，即背包容量为j，里面不放物品i的最大价值，此时dp[i][j]就是dp[i - 1][j]。(其实就是当物品i的重量大于背包j的重量时，物品i无法放进背包中，所以被背包内的价值依然和前面相同)</li>
<li><strong>放物品i</strong>：由dp[i - 1][j - weight[i]]推出，dp[i - 1][j - weight[i]] 为背包容量为j - weight[i]的时候不放物品i的最大价值，那么dp[i - 1][j - weight[i]] + value[i] （物品i的价值），就是背包放物品i得到的最大价值</li>
</ul>
<p>所以递归公式： <code>dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i])</code></p>
<ol start="3">
<li>dp数组如何初始化</li>
</ol>
<p>首先从dp[i][j]的定义出发，如果背包容量j为0的话，即dp[i][0]，无论是选取哪些物品，背包价值总和一定为0。</p>
<table>
<thead>
<tr>
<th></th>
<th>0</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
</tr>
</thead>
<tbody><tr>
<td>物品0</td>
<td>0</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>物品1</td>
<td>0</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>物品2</td>
<td>0</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>状态转移方程 <code>dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i])</code> 可以看出i 是由 i-1 推导出来，那么i为0的时候就一定要初始化</p>
<p>dp[0][j]，即：i为0，存放编号0的物品的时候，各个容量的背包所能存放的最大价值</p>
<table>
<thead>
<tr>
<th></th>
<th>0</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
</tr>
</thead>
<tbody><tr>
<td>物品0</td>
<td>0</td>
<td>15</td>
<td>15</td>
<td>15</td>
<td>15</td>
</tr>
<tr>
<td>物品1</td>
<td>0</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>物品2</td>
<td>0</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>首先j&#x3D;0(容量为0)这里是可以初始值不用管的，并且根据遍历顺序来说也是不用管，这个后面会看到</p>
<p>初始化的代码：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	weight := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line">	value := []<span class="type">int</span>&#123;<span class="number">15</span>, <span class="number">20</span>, <span class="number">30</span>&#125;</span><br><span class="line">	bigWeight := <span class="number">4</span></span><br><span class="line">	dp := <span class="built_in">make</span>([][]<span class="type">int</span>, <span class="built_in">len</span>(weight))</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(weight); i++ &#123;</span><br><span class="line">		<span class="comment">// 因为容量包含0，所以要+1</span></span><br><span class="line">		dp[i] = <span class="built_in">make</span>([]<span class="type">int</span>, bigWeight+<span class="number">1</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 这里直接从weight[0]起步，前面的肯定是0</span></span><br><span class="line">	<span class="keyword">for</span> j := weight[<span class="number">0</span>]; j &lt;= bigWeight; j++ &#123;</span><br><span class="line">		dp[<span class="number">0</span>][j] = value[<span class="number">0</span>]</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(dp)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// output:[[0 15 15 15 15] [0 0 0 0 0] [0 0 0 0 0]]</span></span><br></pre></td></tr></table></figure>

<ol start="4">
<li>确定遍历顺序</li>
</ol>
<p>01背包遍历顺序两种都行，<strong>但是先遍历物品更好理解</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 遍历物品</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">1</span>; i &lt; <span class="built_in">len</span>(weight); i++ &#123;</span><br><span class="line">    <span class="comment">// 遍历容量</span></span><br><span class="line">    <span class="keyword">for</span> j := <span class="number">0</span>; j &lt;= bagWeight; j++ &#123;</span><br><span class="line">        <span class="keyword">if</span> j &lt; weight[i] &#123;</span><br><span class="line">            dp[i][j] = dp[i<span class="number">-1</span>][j]</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            dp[i][j] = max(dp[i<span class="number">-1</span>][j], dp[i<span class="number">-1</span>][j-weight[i]]+value[i])</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(dp)</span><br><span class="line"><span class="comment">//output:[[0 15 15 15 15] [0 15 15 20 35] [0 15 15 20 35]]</span></span><br></pre></td></tr></table></figure>

<h4 id="滚动数组空间优化"><a href="#滚动数组空间优化" class="headerlink" title="滚动数组空间优化"></a>滚动数组空间优化</h4><p>dp[i][j] 表示从下标为[0-i]的物品里任意取，放进容量为j的背包，价值总和最大是多少</p>
<p>一维数组：dp[j]表示：容量为j的背包，所背的物品价值可以最大为dp[j]</p>
<p><strong>动规五部曲</strong></p>
<ol>
<li>确定dp数组的定义</li>
</ol>
<p>在一维dp数组中，dp[j]表示：容量为j的背包，所背的物品价值可以最大为dp[j]</p>
<ol start="2">
<li>dp数组的递推公式</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[j] = max(dp[j], dp[j - weight[i]] + value[i])</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>dp数组初始化</li>
</ol>
<p>dp[0]&#x3D;0，其他情况下可以通过dp[0]直接横着推过来</p>
<ol start="4">
<li><strong>遍历顺序</strong></li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	weight := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line">	value := []<span class="type">int</span>&#123;<span class="number">15</span>, <span class="number">20</span>, <span class="number">30</span>&#125;</span><br><span class="line">	bagWeight := <span class="number">4</span></span><br><span class="line">	<span class="comment">// 因为容量包含0，所以要+1</span></span><br><span class="line">	dp := <span class="built_in">make</span>([]<span class="type">int</span>, bagWeight+<span class="number">1</span>)</span><br><span class="line">	<span class="comment">// 遍历物品</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(weight); i++ &#123;</span><br><span class="line">		<span class="comment">// 遍历容量</span></span><br><span class="line">		<span class="keyword">for</span> j := bagWeight; j &gt;= weight[i]; j-- &#123;</span><br><span class="line">			dp[j] = max(dp[j], dp[j-weight[i]]+value[i])</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(dp)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//output:[0 15 15 20 35]</span></span><br></pre></td></tr></table></figure>

<p>这块是重点，注意：<strong>必须先遍历物品再遍历背包</strong>；<strong>必须倒序遍历</strong></p>
<p>先遍历物品再遍历背包：因为一维dp的写法，背包容量一定是要倒序遍历，如果遍历背包容量放在上一层，那么每个dp[j]就只会放入一个物品，即：背包里只放入了一个物品（举个例子自己走一遍就差不多理解了）</p>
<p>倒顺遍历：无法知道物品装了没装，容易装多次，倒着来的话本容量下前面的肯定没装该物品，因为还没遍历到</p>
<h3 id="分割等和子集"><a href="#分割等和子集" class="headerlink" title="分割等和子集"></a>分割等和子集</h3><p><a class="link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/partition-equal-subset-sum/" >题目链接<i class="fas fa-external-link-alt"></i></a></p>
<p>给你一个 <strong>只包含正整数</strong> 的 <strong>非空</strong> 数组 <code>nums</code> 。请你判断是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1,5,11,5]</span><br><span class="line">输出：true</span><br><span class="line">解释：数组可以分割成 [1, 5, 5] 和 [11] 。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1,2,3,5]</span><br><span class="line">输出：false</span><br><span class="line">解释：数组不能分割成两个元素和相等的子集。</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 200</code></li>
<li><code>1 &lt;= nums[i] &lt;= 100</code></li>
</ul>
<h4 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h4><p><code>[1,5,11,5]</code>为例，和为22，相当于一个11的背包看看最多可以装多少个，如果小于11输出false，等于11输出true，一道简单的01背包问题</p>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">canPartition</span><span class="params">(nums []<span class="type">int</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">	<span class="keyword">var</span> sum <span class="type">int</span></span><br><span class="line">	<span class="keyword">for</span> _, v := <span class="keyword">range</span> nums &#123;</span><br><span class="line">		sum += v</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> sum%<span class="number">2</span> != <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line">	sum /= <span class="number">2</span></span><br><span class="line">	dp := <span class="built_in">make</span>([]<span class="type">int</span>, sum+<span class="number">1</span>)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(nums); i++ &#123;</span><br><span class="line">		<span class="keyword">for</span> j := sum; j &gt;= nums[i]; j-- &#123;</span><br><span class="line">			dp[j] = max(dp[j], dp[j-nums[i]]+nums[i])</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> dp[sum] == sum</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">max</span><span class="params">(a, b <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> a &gt; b &#123;</span><br><span class="line">		<span class="keyword">return</span> a</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="最后一块石头的重量-II"><a href="#最后一块石头的重量-II" class="headerlink" title="最后一块石头的重量 II"></a>最后一块石头的重量 II</h3><p><a class="link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/last-stone-weight-ii/" >题目链接<i class="fas fa-external-link-alt"></i></a></p>
<p>有一堆石头，用整数数组 <code>stones</code> 表示。其中 <code>stones[i]</code> 表示第 <code>i</code> 块石头的重量。</p>
<p>每一回合，从中选出<strong>任意两块石头</strong>，然后将它们一起粉碎。假设石头的重量分别为 <code>x</code> 和 <code>y</code>，且 <code>x &lt;= y</code>。那么粉碎的可能结果如下：</p>
<ul>
<li>如果 <code>x == y</code>，那么两块石头都会被完全粉碎；</li>
<li>如果 <code>x != y</code>，那么重量为 <code>x</code> 的石头将会完全粉碎，而重量为 <code>y</code> 的石头新重量为 <code>y-x</code>。</li>
</ul>
<p>最后，<strong>最多只会剩下一块</strong> 石头。返回此石头 <strong>最小的可能重量</strong> 。如果没有石头剩下，就返回 <code>0</code></p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：stones = [2,7,4,1,8,1]</span><br><span class="line">输出：1</span><br><span class="line">解释：</span><br><span class="line">组合 2 和 4，得到 2，所以数组转化为 [2,7,1,8,1]，</span><br><span class="line">组合 7 和 8，得到 1，所以数组转化为 [2,1,1,1]，</span><br><span class="line">组合 2 和 1，得到 1，所以数组转化为 [1,1,1]，</span><br><span class="line">组合 1 和 1，得到 0，所以数组转化为 [1]，这就是最优值。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：stones = [31,26,33,21,40]</span><br><span class="line">输出：5</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= stones.length &lt;= 30</code></li>
<li><code>1 &lt;= stones[i] &lt;= 100</code></li>
</ul>
<h4 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h4><p>乍一看一脸懵逼，仔细想想的话反正一个是加数一个是减数，分成两拨来碰，和上面那道题好像一样：一组数，分两拨，两拨之间差值如何最小，输出即可，那也就相当于一组数，sum&#x2F;2为容量，看看最大是多少，最后输出sum&#x2F;2-该数</p>
<p>但是需要考虑sum%2为1的情况，以sum&#x3D;9为例，肯定有一波小于等于4，一波小于等于5，不管是哪一波，一个向中间聚拢，另一个也是，所以背包容量取哪个都没影响。我们可以直接向下取整，因为sum&#x2F;2就是，并且容量小的话for层数也少。</p>
<p>因为背包容量算出来的是小于等于sum&#x2F;2的，并且还有可能向下取整，所以最后结果为<code>sum-dp[bagWeight] - dp[bagWeight]</code></p>
<h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">lastStoneWeightII</span><span class="params">(stones []<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	<span class="keyword">var</span> sum <span class="type">int</span></span><br><span class="line">	<span class="keyword">for</span> _, stone := <span class="keyword">range</span> stones &#123;</span><br><span class="line">		sum += stone</span><br><span class="line">	&#125;</span><br><span class="line">	bagWeight := sum / <span class="number">2</span></span><br><span class="line">	dp := <span class="built_in">make</span>([]<span class="type">int</span>, bagWeight+<span class="number">1</span>)</span><br><span class="line">	<span class="comment">// 遍历物品</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(stones); i++ &#123;</span><br><span class="line">		<span class="comment">// 遍历容量</span></span><br><span class="line">		<span class="keyword">for</span> j := bagWeight; j &gt;= stones[i]; j-- &#123;</span><br><span class="line">			dp[j] = max(dp[j], dp[j-stones[i]]+stones[i])</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> sum - dp[bagWeight]*<span class="number">2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="目标和"><a href="#目标和" class="headerlink" title="目标和"></a>目标和</h3><p>给你一个整数数组 <code>nums</code> 和一个整数 <code>target</code> 。</p>
<p>向数组中的每个整数前添加 <code>&#39;+&#39;</code> 或 <code>&#39;-&#39;</code> ，然后串联起所有整数，可以构造一个 <strong>表达式</strong> ：</p>
<ul>
<li>例如，<code>nums = [2, 1]</code> ，可以在 <code>2</code> 之前添加 <code>&#39;+&#39;</code> ，在 <code>1</code> 之前添加 <code>&#39;-&#39;</code> ，然后串联起来得到表达式 <code>&quot;+2-1&quot;</code></li>
</ul>
<p>返回可以通过上述方法构造的、运算结果等于 <code>target</code> 的不同 <strong>表达式</strong> 的数目。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1,1,1,1,1], target = 3</span><br><span class="line">输出：5</span><br><span class="line">解释：一共有 5 种方法让最终目标和为 3 。</span><br><span class="line">-1 + 1 + 1 + 1 + 1 = 3</span><br><span class="line">+1 - 1 + 1 + 1 + 1 = 3</span><br><span class="line">+1 + 1 - 1 + 1 + 1 = 3</span><br><span class="line">+1 + 1 + 1 - 1 + 1 = 3</span><br><span class="line">+1 + 1 + 1 + 1 - 1 = 3</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1], target = 1</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 20</code></li>
<li><code>0 &lt;= nums[i] &lt;= 1000</code></li>
<li><code>0 &lt;= sum(nums[i]) &lt;= 1000</code></li>
<li><code>-1000 &lt;= target &lt;= 1000</code></li>
</ul>
<h4 id="分析-3"><a href="#分析-3" class="headerlink" title="分析"></a>分析</h4><p>这道题比较难想，但是有过这一次之后以后同类型的会好很多。</p>
<p>加号的分为一波，减号的分为一波，假设加法的总和为x，那么减法对应的总和就是sum - x。所以我们要求的是 x - (sum - x) &#x3D; target，x &#x3D; (target + sum) &#x2F; 2</p>
<p><strong>此时问题就转化为，装满容量为x的背包，有几种方法</strong></p>
<p>bagSize就是(target + sum) &#x2F; 2 ，如果这个数不能整除，那就不可能凑不来方法，<code>return 0</code>即可</p>
<p>这次和之前遇到的背包问题不一样了，之前都是求容量为j的背包，最多能装多少。本题则是装满有几种方法。其实这就是一个<strong>组合问题</strong>了</p>
<ol>
<li>确定dp数组以及下标的含义</li>
</ol>
<p>dp[j] 表示：填满j（包括j）这么大容积的包，有dp[j]种方法</p>
<ol start="2">
<li>确定递推公式</li>
</ol>
<p>dp[j]，j 为5</p>
<ul>
<li>已经有一个1（nums[i]） 的话，有 dp[4]种方法 凑成 容量为5的背包。</li>
<li>已经有一个2（nums[i]） 的话，有 dp[3]种方法 凑成 容量为5的背包。</li>
<li>已经有一个3（nums[i]） 的话，有 dp[2]中方法 凑成 容量为5的背包</li>
<li>已经有一个4（nums[i]） 的话，有 dp[1]中方法 凑成 容量为5的背包</li>
<li>已经有一个5 （nums[i]）的话，有 dp[0]中方法 凑成 容量为5的背包</li>
</ul>
<p>那么凑整dp[5]有多少方法呢，也就是把 所有的 dp[j - nums[i]] 累加起来。</p>
<p>所以求<strong>组合类问题</strong>的公式，都是类似这种：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[j] += dp[j - nums[i]]</span><br></pre></td></tr></table></figure>

<p><strong>这个公式在后面在讲解背包解决排列组合问题的时候还会用到！</strong></p>
<ol start="3">
<li>dp数组如何初始化</li>
</ol>
<p>从0开始推，容量为0装满的方式有1种，这个是初始值，其他通过这个推过来。</p>
<p>从递推公式可以看出，在初始化的时候dp[0] 一定要初始化为1，因为dp[0]是在公式中一切递推结果的起源，如果dp[0]是0的话，递推结果将都是0。</p>
<ol start="4">
<li>确定遍历顺序</li>
</ol>
<p>一维dp数组，先物品再容量</p>
<h4 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findTargetSumWays</span><span class="params">(nums []<span class="type">int</span>, target <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	sum := target</span><br><span class="line">	<span class="keyword">for</span> _, num := <span class="keyword">range</span> nums &#123;</span><br><span class="line">		sum += num</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> sum%<span class="number">2</span> == <span class="number">1</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">	&#125;</span><br><span class="line">	bagWeight := sum / <span class="number">2</span></span><br><span class="line">	<span class="comment">// 这里需要判断bagWeight是否小于0</span></span><br><span class="line">    <span class="comment">// 例如 [100],-200 的输入</span></span><br><span class="line">    <span class="keyword">if</span> bagWeight &lt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// dp[j] 表示：填满j这么大容积的包，有dp[j]种方法</span></span><br><span class="line">	dp := <span class="built_in">make</span>([]<span class="type">int</span>, bagWeight+<span class="number">1</span>)</span><br><span class="line">	dp[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(nums); i++ &#123;</span><br><span class="line">		<span class="keyword">for</span> j := bagWeight; j &gt;= nums[i]; j-- &#123;</span><br><span class="line">			dp[j] += dp[j-nums[i]]</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(dp)</span><br><span class="line">	<span class="keyword">return</span> dp[bagWeight]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="一和零"><a href="#一和零" class="headerlink" title="一和零"></a>一和零</h3><p>给你一个二进制字符串数组 <code>strs</code> 和两个整数 <code>m</code> 和 <code>n</code> 。</p>
<p>请你找出并返回 <code>strs</code> 的最大子集的长度，该子集中 <strong>最多</strong> 有 <code>m</code> 个 <code>0</code> 和 <code>n</code> 个 <code>1</code> 。</p>
<p>如果 <code>x</code> 的所有元素也是 <code>y</code> 的元素，集合 <code>x</code> 是集合 <code>y</code> 的 <strong>子集</strong> 。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：strs = [&quot;10&quot;, &quot;0001&quot;, &quot;111001&quot;, &quot;1&quot;, &quot;0&quot;], m = 5, n = 3</span><br><span class="line">输出：4</span><br><span class="line">解释：最多有 5 个 0 和 3 个 1 的最大子集是 &#123;&quot;10&quot;,&quot;0001&quot;,&quot;1&quot;,&quot;0&quot;&#125; ，因此答案是 4 。</span><br><span class="line">其他满足题意但较小的子集包括 &#123;&quot;0001&quot;,&quot;1&quot;&#125; 和 &#123;&quot;10&quot;,&quot;1&quot;,&quot;0&quot;&#125; 。&#123;&quot;111001&quot;&#125; 不满足题意，因为它含 4 个 1 ，大于 n 的值 3 。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：strs = [&quot;10&quot;, &quot;0&quot;, &quot;1&quot;], m = 1, n = 1</span><br><span class="line">输出：2</span><br><span class="line">解释：最大的子集是 &#123;&quot;0&quot;, &quot;1&quot;&#125; ，所以答案是 2 。</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= strs.length &lt;= 600</code></li>
<li><code>1 &lt;= strs[i].length &lt;= 100</code></li>
<li><code>strs[i]</code> 仅由 <code>&#39;0&#39;</code> 和 <code>&#39;1&#39;</code> 组成</li>
<li><code>1 &lt;= m, n &lt;= 100</code></li>
</ul>
<h4 id="分析-4"><a href="#分析-4" class="headerlink" title="分析"></a>分析</h4><p>这个题其实不难看出来是01背包问题但是有两个维度限制（经常见这类型的题），就像有的大招既扣蓝也扣血，<u>这俩都算是背包的容量</u>，所以我们for循环遍历需要三层了：物品、容量0、容量1（<u>我们需要把dp[m][n]中，m、n取值的各种情况都填满！</u>）</p>
<p>创建dp数组的时候再多创建一个维度即可，例如我们用滚动数组，一维数组即可解决，这里要变成二维</p>
<ol>
<li>确定dp数组及下标的含义</li>
</ol>
<p>dp[i][j]：最多有i个0和j个1的strs的最大子集的大小为dp[i][j]</p>
<ol start="2">
<li>确定递推公式</li>
</ol>
<p>dp[i][j] 可以由前一个strs里的字符串推导出来，strs里的字符串有zeroNum个0，oneNum个1。</p>
<p>dp[i][j] 就可以是 dp[i - zeroNum][j - oneNum] + 1。</p>
<p>然后我们在遍历的过程中，取dp[i][j]的最大值。</p>
<p>所以递推公式：dp[i][j] &#x3D; max(dp[i][j], dp[i - zeroNum][j - oneNum] + 1);</p>
<p>此时大家可以回想一下01背包的递推公式：dp[j] &#x3D; max(dp[j], dp[j - weight[i]] + value[i]);</p>
<p>对比一下就会发现，字符串的zeroNum和oneNum相当于物品的重量（weight[i]），字符串本身的个数相当于物品的价值（value[i]）</p>
<ol start="3">
<li>dp数组如何初始化</li>
</ol>
<p>根据含义dp[0][0]直接为0就行，滚动数组的话也不会覆盖掉什么的</p>
<ol start="4">
<li>确定遍历顺序</li>
</ol>
<p>先遍历物品再遍历背包，从后往前遍历</p>
<h4 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h4><p>自我感觉注释写的挺清晰的</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findMaxForm</span><span class="params">(strs []<span class="type">string</span>, m <span class="type">int</span>, n <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	<span class="comment">// 滚动数组，所以 创建dp数组时无需考虑物品的容量</span></span><br><span class="line">	<span class="comment">// 因为是两个容量限制，所以是dp[m+1][n+1] (加一是因为含有0)</span></span><br><span class="line">	dp := <span class="built_in">make</span>([][]<span class="type">int</span>, m+<span class="number">1</span>)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt;= m; i++ &#123;</span><br><span class="line">		dp[i] = <span class="built_in">make</span>([]<span class="type">int</span>, n+<span class="number">1</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 遍历物品</span></span><br><span class="line">	<span class="keyword">for</span> _, str := <span class="keyword">range</span> strs &#123;</span><br><span class="line">		zeroNum,oneNum := <span class="number">0</span>,<span class="number">0</span></span><br><span class="line">		<span class="keyword">for</span> _, ch := <span class="keyword">range</span> str &#123;</span><br><span class="line">			<span class="keyword">if</span> ch == <span class="string">&#x27;0&#x27;</span> &#123;</span><br><span class="line">				zeroNum++</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				oneNum++</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 遍历容量</span></span><br><span class="line">		<span class="keyword">for</span> i := m; i &gt;= zeroNum; i-- &#123; <span class="comment">// 遍历0的容量</span></span><br><span class="line">			<span class="keyword">for</span> j := n ; j &gt;= oneNum; j-- &#123; <span class="comment">// 遍历1的容量</span></span><br><span class="line">				dp[i][j] = max(dp[i][j],dp[i-zeroNum][j-oneNum]+<span class="number">1</span>)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> dp[m][n]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="01背包总结"><a href="#01背包总结" class="headerlink" title="01背包总结"></a>01背包总结</h3><p>刚刚刷过的题目总结一下：</p>
<ul>
<li><a class="link"   target="_blank" rel="noopener" href="https://programmercarl.com/%E8%83%8C%E5%8C%85%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%8001%E8%83%8C%E5%8C%85-2.html" >纯 0 - 1 背包<i class="fas fa-external-link-alt"></i></a> 求 给定背包容量，尽可能装，最大价值是多少</li>
<li><a class="link"   target="_blank" rel="noopener" href="https://programmercarl.com/0416.%E5%88%86%E5%89%B2%E7%AD%89%E5%92%8C%E5%AD%90%E9%9B%86.html" >416. 分割等和子集<i class="fas fa-external-link-alt"></i></a> 求 给定背包容量，能不能装满这个背包</li>
<li><a class="link"   target="_blank" rel="noopener" href="https://programmercarl.com/1049.%E6%9C%80%E5%90%8E%E4%B8%80%E5%9D%97%E7%9F%B3%E5%A4%B4%E7%9A%84%E9%87%8D%E9%87%8FII.html" >1049. 最后一块石头的重量 II<i class="fas fa-external-link-alt"></i></a> 求 给定背包容量，尽可能装，最多能装多少</li>
<li><a class="link"   target="_blank" rel="noopener" href="https://programmercarl.com/0494.%E7%9B%AE%E6%A0%87%E5%92%8C.html" >494. 目标和<i class="fas fa-external-link-alt"></i></a> 求 给定背包容量，装满背包，有多少种方法</li>
<li><a class="link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/ones-and-zeroes/description/" >474. 一和零<i class="fas fa-external-link-alt"></i></a> 求 给定背包容量，尽可能装，最多有多少个物品</li>
</ul>
<p>所以在代码随想录中所列举的题目，都是 0-1背包不同维度上的应用</p>
<p>【不得不说卡哥找的这些题都太典型了，每道题是一种类型，有些佩服】</p>
<h2 id="完全背包"><a href="#完全背包" class="headerlink" title="完全背包"></a>完全背包</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p><u>完全背包和01背包问题唯一不同的地方就是，每种物品有无限件</u></p>
<p>以例题为切入，背包最大重量为4，物品如下：</p>
<table>
<thead>
<tr>
<th>重量</th>
<th>价值</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>物品0</td>
<td>1</td>
<td>15</td>
</tr>
<tr>
<td>物品1</td>
<td>3</td>
<td>20</td>
</tr>
<tr>
<td>物品2</td>
<td>4</td>
<td>30</td>
</tr>
</tbody></table>
<p><u>每件商品都有无限个</u>，问背包能背的物品最大价值是多少？</p>
<p>回顾一下01背包的核心代码：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 遍历物品</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(weight); i++ &#123;</span><br><span class="line">	<span class="comment">// 遍历容量</span></span><br><span class="line">	<span class="keyword">for</span> j := bagWeight; j &gt;= weight[i]; j-- &#123;</span><br><span class="line">		dp[j] = max(dp[j], dp[j-weight[i]]+value[i])</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中容量倒序遍历，为了保证每个物品仅被添加一次，而完全背包的物品是可以添加多次的，所以要从小到大去遍历，即：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 遍历物品</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(weight); i++ &#123;</span><br><span class="line">	<span class="comment">// 遍历容量</span></span><br><span class="line">	<span class="keyword">for</span> j := weight[i]; j &lt;= bagWeight; j-- &#123;</span><br><span class="line">		dp[j] = max(dp[j], dp[j-weight[i]]+value[i])</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>01背包中必须先遍历物品，再遍历容量，但完全背包中两种遍历方式都可以，因为dp[j]是根据 下标j之前所对应的dp[j]计算出来的，只要保证下标j之前的dp[j]都是经过计算的就可以了，而完全背包从前往后遍历，所以前面的数都是全的，咋遍历都没问题。</p>
<p><strong>背包遍历顺序</strong></p>
<ul>
<li>01背包：先物品后容量，容量倒序遍历</li>
<li>完全背包：容量正序遍历，两种遍历方式都可以</li>
</ul>
<p>但是！具体问题要具体分析，这里说的仅仅是纯背包问题的遍历顺序</p>
<p>顺便把例题做了吧，代码如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   weight := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line">   value := []<span class="type">int</span>&#123;<span class="number">15</span>, <span class="number">20</span>, <span class="number">30</span>&#125;</span><br><span class="line">   bagWeight := <span class="number">4</span></span><br><span class="line">   <span class="comment">// 因为容量包含0，所以要+1</span></span><br><span class="line">   dp := <span class="built_in">make</span>([]<span class="type">int</span>, bagWeight+<span class="number">1</span>)</span><br><span class="line">   <span class="comment">// 遍历物品</span></span><br><span class="line">   <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(weight); i++ &#123;</span><br><span class="line">      <span class="comment">// 遍历容量</span></span><br><span class="line">      <span class="keyword">for</span> j := weight[i]; j &lt;= bagWeight; j++ &#123;</span><br><span class="line">         dp[j] = max(dp[j], dp[j-weight[i]]+value[i])</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   fmt.Println(dp)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="零钱兑换-II"><a href="#零钱兑换-II" class="headerlink" title="零钱兑换 II"></a>零钱兑换 II</h3><p><a class="link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/coin-change-ii/description/" >题目链接<i class="fas fa-external-link-alt"></i></a></p>
<p>给你一个整数数组 <code>coins</code> 表示不同面额的硬币，另给一个整数 <code>amount</code> 表示总金额。</p>
<p>请你计算并返回可以凑成总金额的硬币组合数。如果任何硬币组合都无法凑出总金额，返回 <code>0</code> </p>
<p>假设每一种面额的硬币有无限个。 题目数据保证结果符合 32 位带符号整数。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：amount = 5, coins = [1, 2, 5]</span><br><span class="line">输出：4</span><br><span class="line">解释：有四种方式可以凑成总金额：</span><br><span class="line">5=5</span><br><span class="line">5=2+2+1</span><br><span class="line">5=2+1+1+1</span><br><span class="line">5=1+1+1+1+1</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：amount = 3, coins = [2]</span><br><span class="line">输出：0</span><br><span class="line">解释：只用面额 2 的硬币不能凑成总金额 3 。</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：amount = 10, coins = [10] </span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= coins.length &lt;= 300</code></li>
<li><code>1 &lt;= coins[i] &lt;= 5000</code></li>
<li><code>coins</code> 中的所有值 <strong>互不相同</strong></li>
<li><code>0 &lt;= amount &lt;= 5000</code></li>
</ul>
<h4 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h4><p>和01背包中的那个题一样，组合问题：<code>dp[j] += dp[j - nums[i]]</code>，没啥好解释的</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">change</span><span class="params">(amount <span class="type">int</span>, coins []<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	dp := <span class="built_in">make</span>([]<span class="type">int</span>, amount+<span class="number">1</span>) <span class="comment">//总金额为i时，有dp[i]种兑换方法</span></span><br><span class="line">	dp[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(coins); i++ &#123;</span><br><span class="line">		<span class="keyword">for</span> j := coins[i]; j &lt;= amount; j++ &#123;</span><br><span class="line">			dp[j] += dp[j-coins[i]]</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> dp[amount]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="遍历顺序分析"><a href="#遍历顺序分析" class="headerlink" title="遍历顺序分析"></a>遍历顺序分析</h4><p>但是注意，这里遍历顺序必须时先物品后容量！</p>
<p>因为纯完全背包求得装满背包的最大价值是多少，和凑成总和的元素有没有顺序没关系，即：有顺序也行，没有顺序也行！而本题要求凑成总和的组合数，元素之间明确要求没有顺序。所以纯完全背包是能凑成总和就行，不用管怎么凑的。本题是求凑出来的方案个数，且每个方案个数是为组合数。</p>
<p>外层for循环遍历物品（钱币），内层for遍历背包（金钱总额）的情况，得到的方法数量只有{1, 5}这种情况。而不会出现{5, 1}的情况。</p>
<p>如果把两个for交换顺序，背包容量的每一个值，都是经过 1 和 5 的计算，包含了{1, 5} 和 {5, 1}两种情况。<strong>此时dp[j]里算出来的就是排列数！</strong></p>
<p><strong>总结</strong></p>
<ul>
<li><strong>如果求组合数就是外层for循环遍历物品，内层for遍历背包</strong></li>
<li><strong>如果求排列数就是外层for遍历背包，内层for循环遍历物品</strong></li>
</ul>
<h3 id="组合总和-Ⅳ"><a href="#组合总和-Ⅳ" class="headerlink" title="组合总和 Ⅳ"></a>组合总和 Ⅳ</h3><p><a class="link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/combination-sum-iv/description/" >题目链接<i class="fas fa-external-link-alt"></i></a></p>
<p>给你一个由 <strong>不同</strong> 整数组成的数组 <code>nums</code> ，和一个目标整数 <code>target</code> 。请你从 <code>nums</code> 中找出并返回总和为 <code>target</code> 的元素组合的个数。</p>
<p><strong>进阶：</strong>如果给定的数组中含有负数会发生什么？问题会产生何种变化？如果允许负数出现，需要向题目中添加哪些限制条件？</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1,2,3], target = 4</span><br><span class="line">输出：7</span><br><span class="line">解释：</span><br><span class="line">所有可能的组合为：</span><br><span class="line">(1, 1, 1, 1)</span><br><span class="line">(1, 1, 2)</span><br><span class="line">(1, 2, 1)</span><br><span class="line">(1, 3)</span><br><span class="line">(2, 1, 1)</span><br><span class="line">(2, 2)</span><br><span class="line">(3, 1)</span><br><span class="line">请注意，顺序不同的序列被视作不同的组合。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [9], target = 3</span><br><span class="line">输出：0</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 200</code></li>
<li><code>1 &lt;= nums[i] &lt;= 1000</code></li>
<li><code>nums</code> 中的所有元素 <strong>互不相同</strong></li>
<li><code>1 &lt;= target &lt;= 1000</code></li>
</ul>
<h4 id="分析-5"><a href="#分析-5" class="headerlink" title="分析"></a>分析</h4><p>标题写的时组合，实际上时排序，没啥好说的，for循环调换一下，换的时候注意需要把<code>j-nums[i]&lt;0</code>的部刨掉</p>
<ul>
<li>如果求组合数就是外层for循环遍历物品，内层for遍历背包</li>
<li>如果求排列数就是外层for遍历背包，内层for循环遍历物品</li>
</ul>
<p>进阶：如果给定的数组中含有负数，则会导致出现无限长度的排列。例如1、-1那就没完了，所以需要单独处理一下</p>
<h4 id="代码-5"><a href="#代码-5" class="headerlink" title="代码"></a>代码</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">combinationSum4</span><span class="params">(nums []<span class="type">int</span>, target <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">   dp := <span class="built_in">make</span>([]<span class="type">int</span>, target+<span class="number">1</span>)</span><br><span class="line">   dp[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">   <span class="keyword">for</span> j := <span class="number">0</span>; j &lt;= target; j++ &#123;</span><br><span class="line">      <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(nums); i++ &#123;</span><br><span class="line">         <span class="keyword">if</span> j-nums[i] &gt;= <span class="number">0</span> &#123; <span class="comment">// 这个判断得单独处理</span></span><br><span class="line">            dp[j] += dp[j-nums[i]]</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> dp[target]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="爬楼梯进阶版"><a href="#爬楼梯进阶版" class="headerlink" title="爬楼梯进阶版"></a>爬楼梯进阶版</h3><p>假设你正在爬楼梯。需要 <code>n</code> 阶你才能到达楼顶，你每次可以上1至m个台阶，n、m均为输入。你有多少种不同的方法可以爬到楼顶呢？</p>
<h4 id="分析-6"><a href="#分析-6" class="headerlink" title="分析"></a>分析</h4><ul>
<li>每一阶可以重复使用，例如跳了1阶，还可以继续跳1阶——完全背包</li>
<li>跳到楼顶有几种方法——排序问题</li>
</ul>
<p>从而确定遍历顺序：</p>
<ul>
<li>完全背包：容量正序遍历</li>
<li>排序问题：先容量再物品</li>
</ul>
<p><code>dp[i]</code>：爬到有i个台阶的楼顶，有dp[i]种方法。递推公式：<code>dp[i] += dp[i - j]</code>。初始化：<code>dp[0]=0</code></p>
<h4 id="代码-6"><a href="#代码-6" class="headerlink" title="代码"></a>代码</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">climbStairs</span><span class="params">(n <span class="type">int</span>,m <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">   dp := <span class="built_in">make</span>([]<span class="type">int</span>,n+<span class="number">1</span>)</span><br><span class="line">   dp[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">   <span class="keyword">for</span> j := <span class="number">0</span>; j &lt;= n; j++ &#123;</span><br><span class="line">      <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; m; i++ &#123;</span><br><span class="line">         dp[j] += dp[j-i]</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> dp[n]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="零钱兑换"><a href="#零钱兑换" class="headerlink" title="零钱兑换"></a>零钱兑换</h3><p>给你一个整数数组 <code>coins</code> ，表示不同面额的硬币；以及一个整数 <code>amount</code> ，表示总金额。</p>
<p>计算并返回可以凑成总金额所需的 <strong>最少的硬币个数</strong> 。如果没有任何一种硬币组合能组成总金额，返回 <code>-1</code> 。</p>
<p>你可以认为每种硬币的数量是无限的。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：coins = [1, 2, 5], amount = 11</span><br><span class="line">输出：3 </span><br><span class="line">解释：11 = 5 + 5 + 1</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：coins = [2], amount = 3</span><br><span class="line">输出：-1</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：coins = [1], amount = 0</span><br><span class="line">输出：0</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= coins.length &lt;= 12</code></li>
<li><code>1 &lt;= coins[i] &lt;= 2^31 - 1</code></li>
<li><code>0 &lt;= amount &lt;= 10^4</code></li>
</ul>
<h4 id="分析-7"><a href="#分析-7" class="headerlink" title="分析"></a>分析</h4><ul>
<li>确定dp数组：凑足总额为j所需钱币的最少个数为dp[j]</li>
<li>确定递推公式：<code>dp[j] = min(dp[j - coins[i]] + 1, dp[j])</code></li>
<li>dp数组如何初始化[值得注意]：非0的元素都是应该是最大值，dp[0]&#x3D;0</li>
<li>遍历顺序：求钱币最小个数，那么钱币有顺序和没有顺序都可以，都不影响钱币的最小个数</li>
</ul>
<h4 id="代码-7"><a href="#代码-7" class="headerlink" title="代码"></a>代码</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">coinChange</span><span class="params">(coins []<span class="type">int</span>, amount <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	dp := <span class="built_in">make</span>([]<span class="type">int</span>, amount+<span class="number">1</span>) <span class="comment">// 总金额为i时，最少硬币数为dp[i]</span></span><br><span class="line">	<span class="comment">// dp[j] = min(dp[j],dp[j-coins[i]]+1)</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= amount; i++ &#123;</span><br><span class="line">		dp[i] = math.MaxInt32</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt;= <span class="built_in">len</span>(coins); i++ &#123;</span><br><span class="line">		<span class="keyword">for</span> j := coins[i]; j &lt;= amount; j++ &#123;</span><br><span class="line">			dp[j] = min(dp[j], dp[j-coins[i]]+<span class="number">1</span>)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> dp[amount]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="完全平方数"><a href="#完全平方数" class="headerlink" title="完全平方数"></a>完全平方数</h3><p>给你一个整数 <code>n</code> ，返回 和为 <code>n</code> 的完全平方数的最少数量</p>
<p><strong>完全平方数</strong> 是一个整数，其值等于另一个整数的平方；换句话说，其值等于一个整数自乘的积。例如，<code>1</code>、<code>4</code>、<code>9</code> 和 <code>16</code> 都是完全平方数，而 <code>3</code> 和 <code>11</code> 不是。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 12</span><br><span class="line">输出：3 </span><br><span class="line">解释：12 = 4 + 4 + 4</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 13</span><br><span class="line">输出：2</span><br><span class="line">解释：13 = 4 + 9</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= n &lt;= 10^4</code></li>
</ul>
<h4 id="分析-8"><a href="#分析-8" class="headerlink" title="分析"></a>分析</h4><p>题目翻译：完全平方数就是物品（可以无限件使用），凑个正整数n就是背包，问凑满这个背包最少有多少物品</p>
<ul>
<li>完全背包</li>
<li>遍历顺序没要求</li>
</ul>
<h4 id="代码-8"><a href="#代码-8" class="headerlink" title="代码"></a>代码</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">numSquares</span><span class="params">(n <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	dp := <span class="built_in">make</span>([]<span class="type">int</span>, n+<span class="number">1</span>) <span class="comment">// j需要的最少平方数个数</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= n; i++ &#123;</span><br><span class="line">		dp[i] = math.MaxInt32</span><br><span class="line">	&#125;</span><br><span class="line">	m := <span class="type">int</span>(math.Pow(<span class="type">float64</span>(n), <span class="number">0.5</span>))</span><br><span class="line">	<span class="comment">// 遍历物品</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt;= m; i++ &#123;</span><br><span class="line">		<span class="comment">// 遍历容量</span></span><br><span class="line">		<span class="keyword">for</span> j := i * i; j &lt;= n; j++ &#123;</span><br><span class="line">			dp[j] = min(dp[j], dp[j-i*i]+<span class="number">1</span>)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> dp[n]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="多重背包"><a href="#多重背包" class="headerlink" title="多重背包"></a>多重背包</h2><p>有N种物品和一个容量为V 的背包。第i种物品最多有Mi件可用，每件耗费的空间是Ci ，价值是Wi 。求解将哪些物品装入背包可使这些物品的耗费的空间 总和不超过背包容量，且价值总和最大。</p>
<p>多重背包和01背包是非常像的，每件物品最多有Mi件可用，把Mi件摊开，其实就是一个01背包问题了。</p>
<p>例如：</p>
<p>背包最大重量为10。</p>
<p>物品为：</p>
<table>
<thead>
<tr>
<th></th>
<th>重量</th>
<th>价值</th>
<th>数量</th>
</tr>
</thead>
<tbody><tr>
<td>物品0</td>
<td>1</td>
<td>15</td>
<td>2</td>
</tr>
<tr>
<td>物品1</td>
<td>3</td>
<td>20</td>
<td>3</td>
</tr>
<tr>
<td>物品2</td>
<td>4</td>
<td>30</td>
<td>2</td>
</tr>
</tbody></table>
<p>问背包能背的物品最大价值是多少？</p>
<p>和如下情况有区别么？</p>
<table>
<thead>
<tr>
<th></th>
<th>重量</th>
<th>价值</th>
<th>数量</th>
</tr>
</thead>
<tbody><tr>
<td>物品0</td>
<td>1</td>
<td>15</td>
<td>1</td>
</tr>
<tr>
<td>物品0</td>
<td>1</td>
<td>15</td>
<td>1</td>
</tr>
<tr>
<td>物品1</td>
<td>3</td>
<td>20</td>
<td>1</td>
</tr>
<tr>
<td>物品1</td>
<td>3</td>
<td>20</td>
<td>1</td>
</tr>
<tr>
<td>物品1</td>
<td>3</td>
<td>20</td>
<td>1</td>
</tr>
<tr>
<td>物品2</td>
<td>4</td>
<td>30</td>
<td>1</td>
</tr>
<tr>
<td>物品2</td>
<td>4</td>
<td>30</td>
<td>1</td>
</tr>
</tbody></table>
<p>毫无区别，这就转成了一个01背包问题了，且每个物品只用一次。</p>
<p>所以可以直接把它看成01背包来做。当然另一种实现方式，就是把每种商品遍历的个数放在01背包里面在遍历一遍。即01背包里面在加一个for循环遍历一个每种商品的数量。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 多重背包可以化解为 01 背包</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">multiplePack</span><span class="params">(weight, value, nums []<span class="type">int</span>, bagWeight <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    </span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(nums); i++ &#123;</span><br><span class="line">		<span class="keyword">for</span> nums[i] &gt; <span class="number">1</span> &#123;</span><br><span class="line">			weight = <span class="built_in">append</span>(weight, weight[i])</span><br><span class="line">			value = <span class="built_in">append</span>(value, value[i])</span><br><span class="line">			nums[i]--</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	res := <span class="built_in">make</span>([]<span class="type">int</span>, bagWeight+<span class="number">1</span>)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(weight); i++ &#123;</span><br><span class="line">		<span class="keyword">for</span> j := bagWeight; j &gt;= weight[i]; j-- &#123;</span><br><span class="line">			res[j] = getMax(res[j], res[j-weight[i]]+value[i])</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> res[bagWeight]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="背包总结"><a href="#背包总结" class="headerlink" title="背包总结"></a>背包总结</h2><p>01背包：</p>
<ul>
<li>物品只能用一次</li>
<li>二维数组时，遍历顺序均可</li>
<li>一维数组只能先物品后容量，容量倒序遍历</li>
</ul>
<p>完全背包：</p>
<ul>
<li>物品可用无限次</li>
<li>容量正序遍历（保证无限次）</li>
<li>一维数组遍历顺序均可，常见特例如下：<ul>
<li><u>组合数</u>：先遍历物品，再遍历容量(背包)</li>
<li><u>排序数</u>：先遍历容量(背包)，再遍历物品</li>
</ul>
</li>
</ul>
<p>多重背包：转换成01背包来做</p>
<p>组合、排序问题递推通常公式为：<code>dp[i] += dp[i - j]</code>，初始化<code>dp[0]=0</code></p>
<p>OK，你已经掌握01背包、完全背包、多重背包了，快去solo面试官吧！</p>

            </div>

            

            
                <ul class="post-tags-box">
                    
                        <li class="tag-item">
                            <a href="/tags/%E7%AE%97%E6%B3%95/">#算法</a>&nbsp;
                        </li>
                    
                </ul>
            

            
                <div class="article-nav">
                    
                        <div class="article-prev">
                            <a class="prev"
                               rel="prev"
                               href="/2023-01-31/63ddef404aa2/"
                            >
                            <span class="left arrow-icon flex-center">
                              <i class="fas fa-chevron-left"></i>
                            </span>
                                <span class="title flex-center">
                                <span class="post-nav-title-item">go-设计模式-精简版-创建型模式</span>
                                <span class="post-nav-item">上一篇</span>
                            </span>
                            </a>
                        </div>
                    
                    
                        <div class="article-next">
                            <a class="next"
                               rel="next"
                               href="/2023-01-07/f7735ae40302/"
                            >
                            <span class="title flex-center">
                                <span class="post-nav-title-item">MySQL RR隔离级别</span>
                                <span class="post-nav-item">下一篇</span>
                            </span>
                                <span class="right arrow-icon flex-center">
                              <i class="fas fa-chevron-right"></i>
                            </span>
                            </a>
                        </div>
                    
                </div>
            

            
                <div class="comment-container">
                    
<div class="comments-container">
    <div id="comments-anchor"></div>
    <div class="comment-area-title">
        <i class="fas fa-comments"></i>&nbsp;评论
    </div>
    
        
            

    <div class="valine-container">
        <script data-pjax src="//cdn.jsdelivr.net/npm/valine@latest/dist/Valine.min.js"></script>
        <div id="vcomments"></div>
        <script data-pjax>
          function loadValine() {

            const config = {
              el: '#vcomments',
              appId: '0HepQGr76M5xNgWk2Ecac7CC-gzGzoHsz',
              appKey: '9bWzVBcRI0aSocVHtX3OBSYo',
              meta: ['nick', 'mail', 'link'],
              avatar: 'wavatar',
              enableQQ: true,
              placeholder: '',
              lang: 'zh-CN'.toLowerCase()
            }

            if ('') {
              config.serverURLs = ''
            }

            new Valine(config)

            function getAuthor(language) {
              switch (language) {
                case 'en':
                  return 'Author'
                case 'zh-CN':
                  return '博主'
                default:
                  return 'Master'
              }
            }

            // Add "Author" identify
            const getValineDomTimer = setInterval(() => {
              const vcards = document.querySelectorAll('#vcomments .vcards .vcard')
              if (vcards.length > 0) {
                let author = 'TBgHg'

                if (author) {
                  for (let vcard of vcards) {
                    const vnick_dom = vcard.querySelector('.vhead .vnick')
                    const vnick = vnick_dom.innerHTML
                    if (vnick === author) {
                      vnick_dom.innerHTML = `${vnick} <span class="author">${getAuthor(KEEP.hexo_config.language)}</span>`
                    }
                  }
                }
                clearInterval(getValineDomTimer)
              } else {
                clearInterval(getValineDomTimer)
              }
            }, 2000)
          }

          if ('true' === 'true') {
            const loadValineTimeout = setTimeout(() => {
              loadValine()
              clearTimeout(loadValineTimeout)
            }, 1000)
          } else {
            window.addEventListener('DOMContentLoaded', loadValine)
          }
        </script>
    </div>



        
    
</div>

                </div>
            
        </div>

        
            <div class="toc-content-container">
                <div class="post-toc-wrap">
    <div class="post-toc">
        <ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%89%8D%E8%A8%80"><span class="nav-number">1.</span> <span class="nav-text">前言</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%83%8C%E5%8C%85%E6%A6%82%E6%8B%AC"><span class="nav-number">2.</span> <span class="nav-text">背包概括</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#01%E8%83%8C%E5%8C%85"><span class="nav-number">3.</span> <span class="nav-text">01背包</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#01%E8%83%8C%E5%8C%85%E5%88%9D%E4%BB%8B%E7%BB%8D"><span class="nav-number">3.1.</span> <span class="nav-text">01背包初介绍</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%A5%E9%97%A8%E4%BE%8B%E9%A2%98"><span class="nav-number">3.2.</span> <span class="nav-text">入门例题</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%86%E6%9E%90"><span class="nav-number">3.2.1.</span> <span class="nav-text">分析</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%BB%9A%E5%8A%A8%E6%95%B0%E7%BB%84%E7%A9%BA%E9%97%B4%E4%BC%98%E5%8C%96"><span class="nav-number">3.2.2.</span> <span class="nav-text">滚动数组空间优化</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%86%E5%89%B2%E7%AD%89%E5%92%8C%E5%AD%90%E9%9B%86"><span class="nav-number">3.3.</span> <span class="nav-text">分割等和子集</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%86%E6%9E%90-1"><span class="nav-number">3.3.1.</span> <span class="nav-text">分析</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81"><span class="nav-number">3.3.2.</span> <span class="nav-text">代码</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%80%E5%90%8E%E4%B8%80%E5%9D%97%E7%9F%B3%E5%A4%B4%E7%9A%84%E9%87%8D%E9%87%8F-II"><span class="nav-number">3.4.</span> <span class="nav-text">最后一块石头的重量 II</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%86%E6%9E%90-2"><span class="nav-number">3.4.1.</span> <span class="nav-text">分析</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81-1"><span class="nav-number">3.4.2.</span> <span class="nav-text">代码</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%9B%AE%E6%A0%87%E5%92%8C"><span class="nav-number">3.5.</span> <span class="nav-text">目标和</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%86%E6%9E%90-3"><span class="nav-number">3.5.1.</span> <span class="nav-text">分析</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81-2"><span class="nav-number">3.5.2.</span> <span class="nav-text">代码</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%80%E5%92%8C%E9%9B%B6"><span class="nav-number">3.6.</span> <span class="nav-text">一和零</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%86%E6%9E%90-4"><span class="nav-number">3.6.1.</span> <span class="nav-text">分析</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81-3"><span class="nav-number">3.6.2.</span> <span class="nav-text">代码</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#01%E8%83%8C%E5%8C%85%E6%80%BB%E7%BB%93"><span class="nav-number">3.7.</span> <span class="nav-text">01背包总结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85"><span class="nav-number">4.</span> <span class="nav-text">完全背包</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A6%82%E8%BF%B0"><span class="nav-number">4.1.</span> <span class="nav-text">概述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2-II"><span class="nav-number">4.2.</span> <span class="nav-text">零钱兑换 II</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81-4"><span class="nav-number">4.2.1.</span> <span class="nav-text">代码</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%81%8D%E5%8E%86%E9%A1%BA%E5%BA%8F%E5%88%86%E6%9E%90"><span class="nav-number">4.2.2.</span> <span class="nav-text">遍历顺序分析</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C-%E2%85%A3"><span class="nav-number">4.3.</span> <span class="nav-text">组合总和 Ⅳ</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%86%E6%9E%90-5"><span class="nav-number">4.3.1.</span> <span class="nav-text">分析</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81-5"><span class="nav-number">4.3.2.</span> <span class="nav-text">代码</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%88%AC%E6%A5%BC%E6%A2%AF%E8%BF%9B%E9%98%B6%E7%89%88"><span class="nav-number">4.4.</span> <span class="nav-text">爬楼梯进阶版</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%86%E6%9E%90-6"><span class="nav-number">4.4.1.</span> <span class="nav-text">分析</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81-6"><span class="nav-number">4.4.2.</span> <span class="nav-text">代码</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2"><span class="nav-number">4.5.</span> <span class="nav-text">零钱兑换</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%86%E6%9E%90-7"><span class="nav-number">4.5.1.</span> <span class="nav-text">分析</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81-7"><span class="nav-number">4.5.2.</span> <span class="nav-text">代码</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%8C%E5%85%A8%E5%B9%B3%E6%96%B9%E6%95%B0"><span class="nav-number">4.6.</span> <span class="nav-text">完全平方数</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%86%E6%9E%90-8"><span class="nav-number">4.6.1.</span> <span class="nav-text">分析</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81-8"><span class="nav-number">4.6.2.</span> <span class="nav-text">代码</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A4%9A%E9%87%8D%E8%83%8C%E5%8C%85"><span class="nav-number">5.</span> <span class="nav-text">多重背包</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%83%8C%E5%8C%85%E6%80%BB%E7%BB%93"><span class="nav-number">6.</span> <span class="nav-text">背包总结</span></a></li></ol>
    </div>
</div>

            </div>
        
    </div>
</div>


                
            </div>

        </div>

        <div class="page-main-content-bottom">
            
<footer class="footer">
    <div class="info-container">
        <div class="copyright-info info-item">
            &copy;
            
                <span>2020</span> -
            
            2023
            
                &nbsp;<i class="fas fa-heart icon-animate"></i>
                &nbsp;<a href="/">TBgHg</a>
            
        </div>
        
            <script async data-pjax
                    src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
            <div class="website-count info-item">
                
                    访问人数&nbsp;<span id="busuanzi_value_site_uv"></span>&ensp;
                
                
                    总访问量&nbsp;<span id="busuanzi_value_site_pv"></span>
                
            </div>
        
        <div class="theme-info info-item">
            由 <a target="_blank" href="https://hexo.io">Hexo</a> 驱动&nbsp;|&nbsp;主题&nbsp;<a class="theme-version" target="_blank" href="https://github.com/XPoet/hexo-theme-keep">Keep v3.6.1</a>
        </div>
        
        
    </div>
</footer>

        </div>
    </div>

    
        <div class="post-tools">
            <div class="post-tools-container">
    <ul class="tools-list">
        <!-- TOC aside toggle -->
        
            <li class="tools-item flex-center toggle-show-toc">
                <i class="fas fa-list"></i>
            </li>
        

        <!-- go comment -->
        
            <li class="tools-item flex-center go-to-comments">
                <i class="fas fa-comment"></i>
                <span class="post-comments-count"></span>
            </li>
        
    </ul>
</div>

        </div>
    

    <div class="right-bottom-side-tools">
        <div class="side-tools-container">
    <ul class="side-tools-list">
        <li class="tools-item tool-font-adjust-plus flex-center">
            <i class="fas fa-search-plus"></i>
        </li>

        <li class="tools-item tool-font-adjust-minus flex-center">
            <i class="fas fa-search-minus"></i>
        </li>

        <li class="tools-item tool-dark-light-toggle flex-center">
            <i class="fas fa-moon"></i>
        </li>

        <!-- rss -->
        
            <li class="tools-item rss flex-center">
                <a class="flex-center"
                   href="/atom.xml"
                   target="_blank"
                >
                    <i class="fas fa-rss"></i>
                </a>
            </li>
        

        
            <li class="tools-item tool-scroll-to-top flex-center">
                <i class="fas fa-arrow-up"></i>
            </li>
        

        <li class="tools-item tool-scroll-to-bottom flex-center">
            <i class="fas fa-arrow-down"></i>
        </li>
    </ul>

    <ul class="exposed-tools-list">
        <li class="tools-item tool-toggle-show flex-center">
            <i class="fas fa-cog fa-spin"></i>
        </li>
        
    </ul>
</div>

    </div>

    <div class="zoom-in-image-mask">
    <img class="zoom-in-image">
</div>


    
        <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
          <span class="search-input-field-pre">
            <i class="fas fa-keyboard"></i>
          </span>
            <div class="search-input-container">
                <input autocomplete="off"
                       autocorrect="off"
                       autocapitalize="off"
                       placeholder="搜索..."
                       spellcheck="false"
                       type="search"
                       class="search-input"
                >
            </div>
            <span class="close-popup-btn">
                <i class="fas fa-times"></i>
            </span>
        </div>
        <div id="search-result">
            <div id="no-result">
                <i class="fas fa-spinner fa-pulse fa-5x fa-fw"></i>
            </div>
        </div>
    </div>
</div>

    

</main>



<script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.6.1/source/js/utils.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.6.1/source/js/main.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.6.1/source/js/header-shrink.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.6.1/source/js/back2top.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.6.1/source/js/dark-light-toggle.js"></script>




    <script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.6.1/source/js/local-search.js"></script>



    <script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.6.1/source/js/code-block.js"></script>



    <script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.6.1/source/js/lazyload.js"></script>


<div class="post-scripts pjax">
    
        <script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.6.1/source/js/post-helper.js"></script>
        
            <script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.6.1/source/js/libs/anime.min.js"></script>
        
        
            <script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.6.1/source/js/toc.js"></script>
        
    
</div>


    <script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.6.1/source/js/libs/pjax.min.js"></script>
<script>
    window.addEventListener('DOMContentLoaded', () => {
        window.pjax = new Pjax({
            selectors: [
                'head title',
                '.page-container',
                '.pjax'
            ],
            history: true,
            debug: false,
            cacheBust: false,
            timeout: 0,
            analytics: false,
            currentUrlFullReload: false,
            scrollRestoration: false,
            // scrollTo: true,
        });

        document.addEventListener('pjax:send', () => {
            KEEP.utils.pjaxProgressBarStart();
        });

        document.addEventListener('pjax:complete', () => {
            KEEP.utils.pjaxProgressBarEnd();
            window.pjax.executeScripts(document.querySelectorAll('script[data-pjax], .pjax script'));
            KEEP.refresh();
        });
    });
</script>



</body>
</html>
